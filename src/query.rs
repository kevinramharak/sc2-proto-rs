// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/query.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQuery {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQuery.pathing)
    pub pathing: ::std::vec::Vec<RequestQueryPathing>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQuery.abilities)
    pub abilities: ::std::vec::Vec<RequestQueryAvailableAbilities>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQuery.placements)
    pub placements: ::std::vec::Vec<RequestQueryBuildingPlacement>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQuery.ignore_resource_requirements)
    pub ignore_resource_requirements: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQuery {
    fn default() -> &'a RequestQuery {
        <RequestQuery as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuery {
    pub fn new() -> RequestQuery {
        ::std::default::Default::default()
    }

    // optional bool ignore_resource_requirements = 4;

    pub fn ignore_resource_requirements(&self) -> bool {
        self.ignore_resource_requirements.unwrap_or(false)
    }

    pub fn clear_ignore_resource_requirements(&mut self) {
        self.ignore_resource_requirements = ::std::option::Option::None;
    }

    pub fn has_ignore_resource_requirements(&self) -> bool {
        self.ignore_resource_requirements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_resource_requirements(&mut self, v: bool) {
        self.ignore_resource_requirements = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pathing",
            |m: &RequestQuery| { &m.pathing },
            |m: &mut RequestQuery| { &mut m.pathing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &RequestQuery| { &m.abilities },
            |m: &mut RequestQuery| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "placements",
            |m: &RequestQuery| { &m.placements },
            |m: &mut RequestQuery| { &mut m.placements },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore_resource_requirements",
            |m: &RequestQuery| { &m.ignore_resource_requirements },
            |m: &mut RequestQuery| { &mut m.ignore_resource_requirements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQuery>(
            "RequestQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQuery {
    const NAME: &'static str = "RequestQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pathing.push(is.read_message()?);
                },
                18 => {
                    self.abilities.push(is.read_message()?);
                },
                26 => {
                    self.placements.push(is.read_message()?);
                },
                32 => {
                    self.ignore_resource_requirements = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pathing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.placements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ignore_resource_requirements {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pathing {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.placements {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.ignore_resource_requirements {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQuery {
        RequestQuery::new()
    }

    fn clear(&mut self) {
        self.pathing.clear();
        self.abilities.clear();
        self.placements.clear();
        self.ignore_resource_requirements = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQuery {
        static instance: RequestQuery = RequestQuery {
            pathing: ::std::vec::Vec::new(),
            abilities: ::std::vec::Vec::new(),
            placements: ::std::vec::Vec::new(),
            ignore_resource_requirements: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQuery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQuery {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQuery.pathing)
    pub pathing: ::std::vec::Vec<ResponseQueryPathing>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQuery.abilities)
    pub abilities: ::std::vec::Vec<ResponseQueryAvailableAbilities>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQuery.placements)
    pub placements: ::std::vec::Vec<ResponseQueryBuildingPlacement>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQuery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQuery {
    fn default() -> &'a ResponseQuery {
        <ResponseQuery as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuery {
    pub fn new() -> ResponseQuery {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pathing",
            |m: &ResponseQuery| { &m.pathing },
            |m: &mut ResponseQuery| { &mut m.pathing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &ResponseQuery| { &m.abilities },
            |m: &mut ResponseQuery| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "placements",
            |m: &ResponseQuery| { &m.placements },
            |m: &mut ResponseQuery| { &mut m.placements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQuery>(
            "ResponseQuery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQuery {
    const NAME: &'static str = "ResponseQuery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pathing.push(is.read_message()?);
                },
                18 => {
                    self.abilities.push(is.read_message()?);
                },
                26 => {
                    self.placements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pathing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.placements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pathing {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.placements {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQuery {
        ResponseQuery::new()
    }

    fn clear(&mut self) {
        self.pathing.clear();
        self.abilities.clear();
        self.placements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQuery {
        static instance: ResponseQuery = ResponseQuery {
            pathing: ::std::vec::Vec::new(),
            abilities: ::std::vec::Vec::new(),
            placements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQuery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQuery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQueryPathing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQueryPathing {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQueryPathing.end_pos)
    pub end_pos: ::protobuf::MessageField<super::common::Point2D>,
    // message oneof groups
    pub start: ::std::option::Option<request_query_pathing::Start>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQueryPathing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQueryPathing {
    fn default() -> &'a RequestQueryPathing {
        <RequestQueryPathing as ::protobuf::Message>::default_instance()
    }
}

impl RequestQueryPathing {
    pub fn new() -> RequestQueryPathing {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Point2D start_pos = 1;

    pub fn start_pos(&self) -> &super::common::Point2D {
        match self.start {
            ::std::option::Option::Some(request_query_pathing::Start::StartPos(ref v)) => v,
            _ => <super::common::Point2D as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_start_pos(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start_pos(&self) -> bool {
        match self.start {
            ::std::option::Option::Some(request_query_pathing::Start::StartPos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_pos(&mut self, v: super::common::Point2D) {
        self.start = ::std::option::Option::Some(request_query_pathing::Start::StartPos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_pos(&mut self) -> &mut super::common::Point2D {
        if let ::std::option::Option::Some(request_query_pathing::Start::StartPos(_)) = self.start {
        } else {
            self.start = ::std::option::Option::Some(request_query_pathing::Start::StartPos(super::common::Point2D::new()));
        }
        match self.start {
            ::std::option::Option::Some(request_query_pathing::Start::StartPos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_pos(&mut self) -> super::common::Point2D {
        if self.has_start_pos() {
            match self.start.take() {
                ::std::option::Option::Some(request_query_pathing::Start::StartPos(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::Point2D::new()
        }
    }

    // optional uint64 unit_tag = 2;

    pub fn unit_tag(&self) -> u64 {
        match self.start {
            ::std::option::Option::Some(request_query_pathing::Start::UnitTag(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_unit_tag(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        match self.start {
            ::std::option::Option::Some(request_query_pathing::Start::UnitTag(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.start = ::std::option::Option::Some(request_query_pathing::Start::UnitTag(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::common::Point2D>(
            "start_pos",
            RequestQueryPathing::has_start_pos,
            RequestQueryPathing::start_pos,
            RequestQueryPathing::mut_start_pos,
            RequestQueryPathing::set_start_pos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "unit_tag",
            RequestQueryPathing::has_unit_tag,
            RequestQueryPathing::unit_tag,
            RequestQueryPathing::set_unit_tag,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point2D>(
            "end_pos",
            |m: &RequestQueryPathing| { &m.end_pos },
            |m: &mut RequestQueryPathing| { &mut m.end_pos },
        ));
        oneofs.push(request_query_pathing::Start::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQueryPathing>(
            "RequestQueryPathing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQueryPathing {
    const NAME: &'static str = "RequestQueryPathing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.start = ::std::option::Option::Some(request_query_pathing::Start::StartPos(is.read_message()?));
                },
                16 => {
                    self.start = ::std::option::Option::Some(request_query_pathing::Start::UnitTag(is.read_uint64()?));
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_pos)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.end_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.start {
            match v {
                &request_query_pathing::Start::StartPos(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request_query_pathing::Start::UnitTag(v) => {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.end_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.start {
            match v {
                &request_query_pathing::Start::StartPos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &request_query_pathing::Start::UnitTag(v) => {
                    os.write_uint64(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQueryPathing {
        RequestQueryPathing::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end_pos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQueryPathing {
        static instance: RequestQueryPathing = RequestQueryPathing {
            end_pos: ::protobuf::MessageField::none(),
            start: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQueryPathing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQueryPathing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQueryPathing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQueryPathing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RequestQueryPathing`
pub mod request_query_pathing {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.RequestQueryPathing.start)
    pub enum Start {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestQueryPathing.start_pos)
        StartPos(super::super::common::Point2D),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestQueryPathing.unit_tag)
        UnitTag(u64),
    }

    impl ::protobuf::Oneof for Start {
    }

    impl ::protobuf::OneofFull for Start {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RequestQueryPathing as ::protobuf::MessageFull>::descriptor().oneof_by_name("start").unwrap()).clone()
        }
    }

    impl Start {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Start>("start")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQueryPathing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQueryPathing {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQueryPathing.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQueryPathing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQueryPathing {
    fn default() -> &'a ResponseQueryPathing {
        <ResponseQueryPathing as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQueryPathing {
    pub fn new() -> ResponseQueryPathing {
        ::std::default::Default::default()
    }

    // optional float distance = 1;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance",
            |m: &ResponseQueryPathing| { &m.distance },
            |m: &mut ResponseQueryPathing| { &mut m.distance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQueryPathing>(
            "ResponseQueryPathing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQueryPathing {
    const NAME: &'static str = "ResponseQueryPathing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.distance {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQueryPathing {
        ResponseQueryPathing::new()
    }

    fn clear(&mut self) {
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQueryPathing {
        static instance: ResponseQueryPathing = ResponseQueryPathing {
            distance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQueryPathing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQueryPathing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQueryPathing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQueryPathing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQueryAvailableAbilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQueryAvailableAbilities {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQueryAvailableAbilities.unit_tag)
    pub unit_tag: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQueryAvailableAbilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQueryAvailableAbilities {
    fn default() -> &'a RequestQueryAvailableAbilities {
        <RequestQueryAvailableAbilities as ::protobuf::Message>::default_instance()
    }
}

impl RequestQueryAvailableAbilities {
    pub fn new() -> RequestQueryAvailableAbilities {
        ::std::default::Default::default()
    }

    // optional uint64 unit_tag = 1;

    pub fn unit_tag(&self) -> u64 {
        self.unit_tag.unwrap_or(0)
    }

    pub fn clear_unit_tag(&mut self) {
        self.unit_tag = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        self.unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.unit_tag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_tag",
            |m: &RequestQueryAvailableAbilities| { &m.unit_tag },
            |m: &mut RequestQueryAvailableAbilities| { &mut m.unit_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQueryAvailableAbilities>(
            "RequestQueryAvailableAbilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQueryAvailableAbilities {
    const NAME: &'static str = "RequestQueryAvailableAbilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_tag {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_tag {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQueryAvailableAbilities {
        RequestQueryAvailableAbilities::new()
    }

    fn clear(&mut self) {
        self.unit_tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQueryAvailableAbilities {
        static instance: RequestQueryAvailableAbilities = RequestQueryAvailableAbilities {
            unit_tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQueryAvailableAbilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQueryAvailableAbilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQueryAvailableAbilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQueryAvailableAbilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQueryAvailableAbilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQueryAvailableAbilities {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQueryAvailableAbilities.abilities)
    pub abilities: ::std::vec::Vec<super::common::AvailableAbility>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQueryAvailableAbilities.unit_tag)
    pub unit_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQueryAvailableAbilities.unit_type_id)
    pub unit_type_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQueryAvailableAbilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQueryAvailableAbilities {
    fn default() -> &'a ResponseQueryAvailableAbilities {
        <ResponseQueryAvailableAbilities as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQueryAvailableAbilities {
    pub fn new() -> ResponseQueryAvailableAbilities {
        ::std::default::Default::default()
    }

    // optional uint64 unit_tag = 2;

    pub fn unit_tag(&self) -> u64 {
        self.unit_tag.unwrap_or(0)
    }

    pub fn clear_unit_tag(&mut self) {
        self.unit_tag = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        self.unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.unit_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_type_id = 3;

    pub fn unit_type_id(&self) -> u32 {
        self.unit_type_id.unwrap_or(0)
    }

    pub fn clear_unit_type_id(&mut self) {
        self.unit_type_id = ::std::option::Option::None;
    }

    pub fn has_unit_type_id(&self) -> bool {
        self.unit_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type_id(&mut self, v: u32) {
        self.unit_type_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &ResponseQueryAvailableAbilities| { &m.abilities },
            |m: &mut ResponseQueryAvailableAbilities| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_tag",
            |m: &ResponseQueryAvailableAbilities| { &m.unit_tag },
            |m: &mut ResponseQueryAvailableAbilities| { &mut m.unit_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type_id",
            |m: &ResponseQueryAvailableAbilities| { &m.unit_type_id },
            |m: &mut ResponseQueryAvailableAbilities| { &mut m.unit_type_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQueryAvailableAbilities>(
            "ResponseQueryAvailableAbilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQueryAvailableAbilities {
    const NAME: &'static str = "ResponseQueryAvailableAbilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.abilities.push(is.read_message()?);
                },
                16 => {
                    self.unit_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.unit_type_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.unit_tag {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.unit_type_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.unit_tag {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.unit_type_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQueryAvailableAbilities {
        ResponseQueryAvailableAbilities::new()
    }

    fn clear(&mut self) {
        self.abilities.clear();
        self.unit_tag = ::std::option::Option::None;
        self.unit_type_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQueryAvailableAbilities {
        static instance: ResponseQueryAvailableAbilities = ResponseQueryAvailableAbilities {
            abilities: ::std::vec::Vec::new(),
            unit_tag: ::std::option::Option::None,
            unit_type_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQueryAvailableAbilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQueryAvailableAbilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQueryAvailableAbilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQueryAvailableAbilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQueryBuildingPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQueryBuildingPlacement {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQueryBuildingPlacement.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQueryBuildingPlacement.target_pos)
    pub target_pos: ::protobuf::MessageField<super::common::Point2D>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestQueryBuildingPlacement.placing_unit_tag)
    pub placing_unit_tag: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQueryBuildingPlacement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQueryBuildingPlacement {
    fn default() -> &'a RequestQueryBuildingPlacement {
        <RequestQueryBuildingPlacement as ::protobuf::Message>::default_instance()
    }
}

impl RequestQueryBuildingPlacement {
    pub fn new() -> RequestQueryBuildingPlacement {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint64 placing_unit_tag = 3;

    pub fn placing_unit_tag(&self) -> u64 {
        self.placing_unit_tag.unwrap_or(0)
    }

    pub fn clear_placing_unit_tag(&mut self) {
        self.placing_unit_tag = ::std::option::Option::None;
    }

    pub fn has_placing_unit_tag(&self) -> bool {
        self.placing_unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placing_unit_tag(&mut self, v: u64) {
        self.placing_unit_tag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &RequestQueryBuildingPlacement| { &m.ability_id },
            |m: &mut RequestQueryBuildingPlacement| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point2D>(
            "target_pos",
            |m: &RequestQueryBuildingPlacement| { &m.target_pos },
            |m: &mut RequestQueryBuildingPlacement| { &mut m.target_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "placing_unit_tag",
            |m: &RequestQueryBuildingPlacement| { &m.placing_unit_tag },
            |m: &mut RequestQueryBuildingPlacement| { &mut m.placing_unit_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQueryBuildingPlacement>(
            "RequestQueryBuildingPlacement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQueryBuildingPlacement {
    const NAME: &'static str = "RequestQueryBuildingPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.target_pos)?;
                },
                24 => {
                    self.placing_unit_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.target_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.placing_unit_tag {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.target_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.placing_unit_tag {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQueryBuildingPlacement {
        RequestQueryBuildingPlacement::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target_pos.clear();
        self.placing_unit_tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQueryBuildingPlacement {
        static instance: RequestQueryBuildingPlacement = RequestQueryBuildingPlacement {
            ability_id: ::std::option::Option::None,
            target_pos: ::protobuf::MessageField::none(),
            placing_unit_tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQueryBuildingPlacement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQueryBuildingPlacement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQueryBuildingPlacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQueryBuildingPlacement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQueryBuildingPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQueryBuildingPlacement {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseQueryBuildingPlacement.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<super::error::ActionResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQueryBuildingPlacement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQueryBuildingPlacement {
    fn default() -> &'a ResponseQueryBuildingPlacement {
        <ResponseQueryBuildingPlacement as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQueryBuildingPlacement {
    pub fn new() -> ResponseQueryBuildingPlacement {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionResult result = 1;

    pub fn result(&self) -> super::error::ActionResult {
        match self.result {
            Some(e) => e.enum_value_or(super::error::ActionResult::Success),
            None => super::error::ActionResult::Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::error::ActionResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &ResponseQueryBuildingPlacement| { &m.result },
            |m: &mut ResponseQueryBuildingPlacement| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQueryBuildingPlacement>(
            "ResponseQueryBuildingPlacement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQueryBuildingPlacement {
    const NAME: &'static str = "ResponseQueryBuildingPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQueryBuildingPlacement {
        ResponseQueryBuildingPlacement::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQueryBuildingPlacement {
        static instance: ResponseQueryBuildingPlacement = ResponseQueryBuildingPlacement {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQueryBuildingPlacement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQueryBuildingPlacement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQueryBuildingPlacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQueryBuildingPlacement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cs2clientprotocol/query.proto\x12\x0eSC2APIProtocol\x1a\x1ds2client\
    protocol/common.proto\x1a\x1cs2clientprotocol/error.proto\"\xac\x02\n\
    \x0cRequestQuery\x12=\n\x07pathing\x18\x01\x20\x03(\x0b2#.SC2APIProtocol\
    .RequestQueryPathingR\x07pathing\x12L\n\tabilities\x18\x02\x20\x03(\x0b2\
    ..SC2APIProtocol.RequestQueryAvailableAbilitiesR\tabilities\x12M\n\nplac\
    ements\x18\x03\x20\x03(\x0b2-.SC2APIProtocol.RequestQueryBuildingPlaceme\
    ntR\nplacements\x12@\n\x1cignore_resource_requirements\x18\x04\x20\x01(\
    \x08R\x1aignoreResourceRequirements\"\xee\x01\n\rResponseQuery\x12>\n\
    \x07pathing\x18\x01\x20\x03(\x0b2$.SC2APIProtocol.ResponseQueryPathingR\
    \x07pathing\x12M\n\tabilities\x18\x02\x20\x03(\x0b2/.SC2APIProtocol.Resp\
    onseQueryAvailableAbilitiesR\tabilities\x12N\n\nplacements\x18\x03\x20\
    \x03(\x0b2..SC2APIProtocol.ResponseQueryBuildingPlacementR\nplacements\"\
    \xa5\x01\n\x13RequestQueryPathing\x126\n\tstart_pos\x18\x01\x20\x01(\x0b\
    2\x17.SC2APIProtocol.Point2DH\0R\x08startPos\x12\x1b\n\x08unit_tag\x18\
    \x02\x20\x01(\x04H\0R\x07unitTag\x120\n\x07end_pos\x18\x03\x20\x01(\x0b2\
    \x17.SC2APIProtocol.Point2DR\x06endPosB\x07\n\x05start\"2\n\x14ResponseQ\
    ueryPathing\x12\x1a\n\x08distance\x18\x01\x20\x01(\x02R\x08distance\";\n\
    \x1eRequestQueryAvailableAbilities\x12\x19\n\x08unit_tag\x18\x01\x20\x01\
    (\x04R\x07unitTag\"\x9e\x01\n\x1fResponseQueryAvailableAbilities\x12>\n\
    \tabilities\x18\x01\x20\x03(\x0b2\x20.SC2APIProtocol.AvailableAbilityR\t\
    abilities\x12\x19\n\x08unit_tag\x18\x02\x20\x01(\x04R\x07unitTag\x12\x20\
    \n\x0cunit_type_id\x18\x03\x20\x01(\rR\nunitTypeId\"\xa0\x01\n\x1dReques\
    tQueryBuildingPlacement\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabi\
    lityId\x126\n\ntarget_pos\x18\x02\x20\x01(\x0b2\x17.SC2APIProtocol.Point\
    2DR\ttargetPos\x12(\n\x10placing_unit_tag\x18\x03\x20\x01(\x04R\x0eplaci\
    ngUnitTag\"V\n\x1eResponseQueryBuildingPlacement\x124\n\x06result\x18\
    \x01\x20\x01(\x0e2\x1c.SC2APIProtocol.ActionResultR\x06result\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::common::file_descriptor().clone());
            deps.push(super::error::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(RequestQuery::generated_message_descriptor_data());
            messages.push(ResponseQuery::generated_message_descriptor_data());
            messages.push(RequestQueryPathing::generated_message_descriptor_data());
            messages.push(ResponseQueryPathing::generated_message_descriptor_data());
            messages.push(RequestQueryAvailableAbilities::generated_message_descriptor_data());
            messages.push(ResponseQueryAvailableAbilities::generated_message_descriptor_data());
            messages.push(RequestQueryBuildingPlacement::generated_message_descriptor_data());
            messages.push(ResponseQueryBuildingPlacement::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

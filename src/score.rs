// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 28.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/score.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:SC2APIProtocol.Score)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Score {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Score.score_type)
    pub score_type: ::std::option::Option<::protobuf::EnumOrUnknown<score::ScoreType>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Score.score)
    pub score: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Score.score_details)
    pub score_details: ::protobuf::MessageField<ScoreDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Score.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Score {
    fn default() -> &'a Score {
        <Score as ::protobuf::Message>::default_instance()
    }
}

impl Score {
    pub fn new() -> Score {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_type",
            |m: &Score| { &m.score_type },
            |m: &mut Score| { &mut m.score_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &Score| { &m.score },
            |m: &mut Score| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScoreDetails>(
            "score_details",
            |m: &Score| { &m.score_details },
            |m: &mut Score| { &mut m.score_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Score>(
            "Score",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Score {
    const NAME: &'static str = "Score";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.score_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.score = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.score_details)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.score_type {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.score_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.score_type {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.score {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.score_details.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Score {
        Score::new()
    }

    fn clear(&mut self) {
        self.score_type = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.score_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Score {
        static instance: Score = Score {
            score_type: ::std::option::Option::None,
            score: ::std::option::Option::None,
            score_details: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Score {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Score").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Score {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Score {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Score`
pub mod score {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.Score.ScoreType)
    pub enum ScoreType {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.Score.ScoreType.Curriculum)
        Curriculum = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.Score.ScoreType.Melee)
        Melee = 2,
    }

    impl ::protobuf::Enum for ScoreType {
        const NAME: &'static str = "ScoreType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ScoreType> {
            match value {
                1 => ::std::option::Option::Some(ScoreType::Curriculum),
                2 => ::std::option::Option::Some(ScoreType::Melee),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ScoreType> {
            match str {
                "Curriculum" => ::std::option::Option::Some(ScoreType::Curriculum),
                "Melee" => ::std::option::Option::Some(ScoreType::Melee),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ScoreType] = &[
            ScoreType::Curriculum,
            ScoreType::Melee,
        ];
    }

    impl ::protobuf::EnumFull for ScoreType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Score.ScoreType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ScoreType::Curriculum => 0,
                ScoreType::Melee => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ScoreType {
        fn default() -> Self {
            ScoreType::Curriculum
        }
    }

    impl ScoreType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ScoreType>("Score.ScoreType")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.CategoryScoreDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CategoryScoreDetails {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.CategoryScoreDetails.none)
    pub none: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.CategoryScoreDetails.army)
    pub army: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.CategoryScoreDetails.economy)
    pub economy: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.CategoryScoreDetails.technology)
    pub technology: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.CategoryScoreDetails.upgrade)
    pub upgrade: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.CategoryScoreDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CategoryScoreDetails {
    fn default() -> &'a CategoryScoreDetails {
        <CategoryScoreDetails as ::protobuf::Message>::default_instance()
    }
}

impl CategoryScoreDetails {
    pub fn new() -> CategoryScoreDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "none",
            |m: &CategoryScoreDetails| { &m.none },
            |m: &mut CategoryScoreDetails| { &mut m.none },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "army",
            |m: &CategoryScoreDetails| { &m.army },
            |m: &mut CategoryScoreDetails| { &mut m.army },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "economy",
            |m: &CategoryScoreDetails| { &m.economy },
            |m: &mut CategoryScoreDetails| { &mut m.economy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "technology",
            |m: &CategoryScoreDetails| { &m.technology },
            |m: &mut CategoryScoreDetails| { &mut m.technology },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgrade",
            |m: &CategoryScoreDetails| { &m.upgrade },
            |m: &mut CategoryScoreDetails| { &mut m.upgrade },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryScoreDetails>(
            "CategoryScoreDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CategoryScoreDetails {
    const NAME: &'static str = "CategoryScoreDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.none = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.army = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.economy = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.technology = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.upgrade = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.none {
            my_size += 1 + 4;
        }
        if let Some(v) = self.army {
            my_size += 1 + 4;
        }
        if let Some(v) = self.economy {
            my_size += 1 + 4;
        }
        if let Some(v) = self.technology {
            my_size += 1 + 4;
        }
        if let Some(v) = self.upgrade {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.none {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.army {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.economy {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.technology {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.upgrade {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CategoryScoreDetails {
        CategoryScoreDetails::new()
    }

    fn clear(&mut self) {
        self.none = ::std::option::Option::None;
        self.army = ::std::option::Option::None;
        self.economy = ::std::option::Option::None;
        self.technology = ::std::option::Option::None;
        self.upgrade = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CategoryScoreDetails {
        static instance: CategoryScoreDetails = CategoryScoreDetails {
            none: ::std::option::Option::None,
            army: ::std::option::Option::None,
            economy: ::std::option::Option::None,
            technology: ::std::option::Option::None,
            upgrade: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CategoryScoreDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CategoryScoreDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CategoryScoreDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryScoreDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.VitalScoreDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VitalScoreDetails {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.VitalScoreDetails.life)
    pub life: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.VitalScoreDetails.shields)
    pub shields: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.VitalScoreDetails.energy)
    pub energy: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.VitalScoreDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VitalScoreDetails {
    fn default() -> &'a VitalScoreDetails {
        <VitalScoreDetails as ::protobuf::Message>::default_instance()
    }
}

impl VitalScoreDetails {
    pub fn new() -> VitalScoreDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "life",
            |m: &VitalScoreDetails| { &m.life },
            |m: &mut VitalScoreDetails| { &mut m.life },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shields",
            |m: &VitalScoreDetails| { &m.shields },
            |m: &mut VitalScoreDetails| { &mut m.shields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "energy",
            |m: &VitalScoreDetails| { &m.energy },
            |m: &mut VitalScoreDetails| { &mut m.energy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VitalScoreDetails>(
            "VitalScoreDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VitalScoreDetails {
    const NAME: &'static str = "VitalScoreDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.life = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.shields = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.energy = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.life {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shields {
            my_size += 1 + 4;
        }
        if let Some(v) = self.energy {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.life {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.shields {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.energy {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VitalScoreDetails {
        VitalScoreDetails::new()
    }

    fn clear(&mut self) {
        self.life = ::std::option::Option::None;
        self.shields = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VitalScoreDetails {
        static instance: VitalScoreDetails = VitalScoreDetails {
            life: ::std::option::Option::None,
            shields: ::std::option::Option::None,
            energy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VitalScoreDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VitalScoreDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VitalScoreDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VitalScoreDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ScoreDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScoreDetails {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.idle_production_time)
    pub idle_production_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.idle_worker_time)
    pub idle_worker_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_value_units)
    pub total_value_units: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_value_structures)
    pub total_value_structures: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.killed_value_units)
    pub killed_value_units: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.killed_value_structures)
    pub killed_value_structures: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.collected_minerals)
    pub collected_minerals: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.collected_vespene)
    pub collected_vespene: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.collection_rate_minerals)
    pub collection_rate_minerals: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.collection_rate_vespene)
    pub collection_rate_vespene: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.spent_minerals)
    pub spent_minerals: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.spent_vespene)
    pub spent_vespene: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.food_used)
    pub food_used: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.killed_minerals)
    pub killed_minerals: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.killed_vespene)
    pub killed_vespene: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.lost_minerals)
    pub lost_minerals: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.lost_vespene)
    pub lost_vespene: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.friendly_fire_minerals)
    pub friendly_fire_minerals: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.friendly_fire_vespene)
    pub friendly_fire_vespene: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.used_minerals)
    pub used_minerals: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.used_vespene)
    pub used_vespene: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_used_minerals)
    pub total_used_minerals: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_used_vespene)
    pub total_used_vespene: ::protobuf::MessageField<CategoryScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_damage_dealt)
    pub total_damage_dealt: ::protobuf::MessageField<VitalScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_damage_taken)
    pub total_damage_taken: ::protobuf::MessageField<VitalScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.total_healed)
    pub total_healed: ::protobuf::MessageField<VitalScoreDetails>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.current_apm)
    pub current_apm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ScoreDetails.current_effective_apm)
    pub current_effective_apm: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ScoreDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScoreDetails {
    fn default() -> &'a ScoreDetails {
        <ScoreDetails as ::protobuf::Message>::default_instance()
    }
}

impl ScoreDetails {
    pub fn new() -> ScoreDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_production_time",
            |m: &ScoreDetails| { &m.idle_production_time },
            |m: &mut ScoreDetails| { &mut m.idle_production_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_worker_time",
            |m: &ScoreDetails| { &m.idle_worker_time },
            |m: &mut ScoreDetails| { &mut m.idle_worker_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_value_units",
            |m: &ScoreDetails| { &m.total_value_units },
            |m: &mut ScoreDetails| { &mut m.total_value_units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_value_structures",
            |m: &ScoreDetails| { &m.total_value_structures },
            |m: &mut ScoreDetails| { &mut m.total_value_structures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killed_value_units",
            |m: &ScoreDetails| { &m.killed_value_units },
            |m: &mut ScoreDetails| { &mut m.killed_value_units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killed_value_structures",
            |m: &ScoreDetails| { &m.killed_value_structures },
            |m: &mut ScoreDetails| { &mut m.killed_value_structures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collected_minerals",
            |m: &ScoreDetails| { &m.collected_minerals },
            |m: &mut ScoreDetails| { &mut m.collected_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collected_vespene",
            |m: &ScoreDetails| { &m.collected_vespene },
            |m: &mut ScoreDetails| { &mut m.collected_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collection_rate_minerals",
            |m: &ScoreDetails| { &m.collection_rate_minerals },
            |m: &mut ScoreDetails| { &mut m.collection_rate_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collection_rate_vespene",
            |m: &ScoreDetails| { &m.collection_rate_vespene },
            |m: &mut ScoreDetails| { &mut m.collection_rate_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spent_minerals",
            |m: &ScoreDetails| { &m.spent_minerals },
            |m: &mut ScoreDetails| { &mut m.spent_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spent_vespene",
            |m: &ScoreDetails| { &m.spent_vespene },
            |m: &mut ScoreDetails| { &mut m.spent_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "food_used",
            |m: &ScoreDetails| { &m.food_used },
            |m: &mut ScoreDetails| { &mut m.food_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "killed_minerals",
            |m: &ScoreDetails| { &m.killed_minerals },
            |m: &mut ScoreDetails| { &mut m.killed_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "killed_vespene",
            |m: &ScoreDetails| { &m.killed_vespene },
            |m: &mut ScoreDetails| { &mut m.killed_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "lost_minerals",
            |m: &ScoreDetails| { &m.lost_minerals },
            |m: &mut ScoreDetails| { &mut m.lost_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "lost_vespene",
            |m: &ScoreDetails| { &m.lost_vespene },
            |m: &mut ScoreDetails| { &mut m.lost_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "friendly_fire_minerals",
            |m: &ScoreDetails| { &m.friendly_fire_minerals },
            |m: &mut ScoreDetails| { &mut m.friendly_fire_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "friendly_fire_vespene",
            |m: &ScoreDetails| { &m.friendly_fire_vespene },
            |m: &mut ScoreDetails| { &mut m.friendly_fire_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "used_minerals",
            |m: &ScoreDetails| { &m.used_minerals },
            |m: &mut ScoreDetails| { &mut m.used_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "used_vespene",
            |m: &ScoreDetails| { &m.used_vespene },
            |m: &mut ScoreDetails| { &mut m.used_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "total_used_minerals",
            |m: &ScoreDetails| { &m.total_used_minerals },
            |m: &mut ScoreDetails| { &mut m.total_used_minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CategoryScoreDetails>(
            "total_used_vespene",
            |m: &ScoreDetails| { &m.total_used_vespene },
            |m: &mut ScoreDetails| { &mut m.total_used_vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VitalScoreDetails>(
            "total_damage_dealt",
            |m: &ScoreDetails| { &m.total_damage_dealt },
            |m: &mut ScoreDetails| { &mut m.total_damage_dealt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VitalScoreDetails>(
            "total_damage_taken",
            |m: &ScoreDetails| { &m.total_damage_taken },
            |m: &mut ScoreDetails| { &mut m.total_damage_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VitalScoreDetails>(
            "total_healed",
            |m: &ScoreDetails| { &m.total_healed },
            |m: &mut ScoreDetails| { &mut m.total_healed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_apm",
            |m: &ScoreDetails| { &m.current_apm },
            |m: &mut ScoreDetails| { &mut m.current_apm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_effective_apm",
            |m: &ScoreDetails| { &m.current_effective_apm },
            |m: &mut ScoreDetails| { &mut m.current_effective_apm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScoreDetails>(
            "ScoreDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScoreDetails {
    const NAME: &'static str = "ScoreDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.idle_production_time = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.idle_worker_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.total_value_units = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.total_value_structures = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.killed_value_units = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.killed_value_structures = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.collected_minerals = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.collected_vespene = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.collection_rate_minerals = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.collection_rate_vespene = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.spent_minerals = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.spent_vespene = ::std::option::Option::Some(is.read_float()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.food_used)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.killed_minerals)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.killed_vespene)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lost_minerals)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lost_vespene)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.friendly_fire_minerals)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.friendly_fire_vespene)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.used_minerals)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.used_vespene)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_used_minerals)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_used_vespene)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_damage_dealt)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_damage_taken)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_healed)?;
                },
                221 => {
                    self.current_apm = ::std::option::Option::Some(is.read_float()?);
                },
                229 => {
                    self.current_effective_apm = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.idle_production_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.idle_worker_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.total_value_units {
            my_size += 1 + 4;
        }
        if let Some(v) = self.total_value_structures {
            my_size += 1 + 4;
        }
        if let Some(v) = self.killed_value_units {
            my_size += 1 + 4;
        }
        if let Some(v) = self.killed_value_structures {
            my_size += 1 + 4;
        }
        if let Some(v) = self.collected_minerals {
            my_size += 1 + 4;
        }
        if let Some(v) = self.collected_vespene {
            my_size += 1 + 4;
        }
        if let Some(v) = self.collection_rate_minerals {
            my_size += 1 + 4;
        }
        if let Some(v) = self.collection_rate_vespene {
            my_size += 1 + 4;
        }
        if let Some(v) = self.spent_minerals {
            my_size += 1 + 4;
        }
        if let Some(v) = self.spent_vespene {
            my_size += 1 + 4;
        }
        if let Some(v) = self.food_used.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.killed_minerals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.killed_vespene.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lost_minerals.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lost_vespene.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.friendly_fire_minerals.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.friendly_fire_vespene.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.used_minerals.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.used_vespene.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_used_minerals.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_used_vespene.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_damage_dealt.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_damage_taken.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_healed.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_apm {
            my_size += 2 + 4;
        }
        if let Some(v) = self.current_effective_apm {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.idle_production_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.idle_worker_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.total_value_units {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.total_value_structures {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.killed_value_units {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.killed_value_structures {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.collected_minerals {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.collected_vespene {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.collection_rate_minerals {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.collection_rate_vespene {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.spent_minerals {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.spent_vespene {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.food_used.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.killed_minerals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.killed_vespene.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.lost_minerals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.lost_vespene.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.friendly_fire_minerals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.friendly_fire_vespene.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.used_minerals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.used_vespene.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.total_used_minerals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.total_used_vespene.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.total_damage_dealt.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.total_damage_taken.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.total_healed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.current_apm {
            os.write_float(27, v)?;
        }
        if let Some(v) = self.current_effective_apm {
            os.write_float(28, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScoreDetails {
        ScoreDetails::new()
    }

    fn clear(&mut self) {
        self.idle_production_time = ::std::option::Option::None;
        self.idle_worker_time = ::std::option::Option::None;
        self.total_value_units = ::std::option::Option::None;
        self.total_value_structures = ::std::option::Option::None;
        self.killed_value_units = ::std::option::Option::None;
        self.killed_value_structures = ::std::option::Option::None;
        self.collected_minerals = ::std::option::Option::None;
        self.collected_vespene = ::std::option::Option::None;
        self.collection_rate_minerals = ::std::option::Option::None;
        self.collection_rate_vespene = ::std::option::Option::None;
        self.spent_minerals = ::std::option::Option::None;
        self.spent_vespene = ::std::option::Option::None;
        self.food_used.clear();
        self.killed_minerals.clear();
        self.killed_vespene.clear();
        self.lost_minerals.clear();
        self.lost_vespene.clear();
        self.friendly_fire_minerals.clear();
        self.friendly_fire_vespene.clear();
        self.used_minerals.clear();
        self.used_vespene.clear();
        self.total_used_minerals.clear();
        self.total_used_vespene.clear();
        self.total_damage_dealt.clear();
        self.total_damage_taken.clear();
        self.total_healed.clear();
        self.current_apm = ::std::option::Option::None;
        self.current_effective_apm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScoreDetails {
        static instance: ScoreDetails = ScoreDetails {
            idle_production_time: ::std::option::Option::None,
            idle_worker_time: ::std::option::Option::None,
            total_value_units: ::std::option::Option::None,
            total_value_structures: ::std::option::Option::None,
            killed_value_units: ::std::option::Option::None,
            killed_value_structures: ::std::option::Option::None,
            collected_minerals: ::std::option::Option::None,
            collected_vespene: ::std::option::Option::None,
            collection_rate_minerals: ::std::option::Option::None,
            collection_rate_vespene: ::std::option::Option::None,
            spent_minerals: ::std::option::Option::None,
            spent_vespene: ::std::option::Option::None,
            food_used: ::protobuf::MessageField::none(),
            killed_minerals: ::protobuf::MessageField::none(),
            killed_vespene: ::protobuf::MessageField::none(),
            lost_minerals: ::protobuf::MessageField::none(),
            lost_vespene: ::protobuf::MessageField::none(),
            friendly_fire_minerals: ::protobuf::MessageField::none(),
            friendly_fire_vespene: ::protobuf::MessageField::none(),
            used_minerals: ::protobuf::MessageField::none(),
            used_vespene: ::protobuf::MessageField::none(),
            total_used_minerals: ::protobuf::MessageField::none(),
            total_used_vespene: ::protobuf::MessageField::none(),
            total_damage_dealt: ::protobuf::MessageField::none(),
            total_damage_taken: ::protobuf::MessageField::none(),
            total_healed: ::protobuf::MessageField::none(),
            current_apm: ::std::option::Option::None,
            current_effective_apm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScoreDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScoreDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScoreDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cs2clientprotocol/score.proto\x12\x0eSC2APIProtocol\"\xc8\x01\n\x05\
    Score\x12>\n\nscore_type\x18\x06\x20\x01(\x0e2\x1f.SC2APIProtocol.Score.\
    ScoreTypeR\tscoreType\x12\x14\n\x05score\x18\x07\x20\x01(\x05R\x05score\
    \x12A\n\rscore_details\x18\x08\x20\x01(\x0b2\x1c.SC2APIProtocol.ScoreDet\
    ailsR\x0cscoreDetails\"&\n\tScoreType\x12\x0e\n\nCurriculum\x10\x01\x12\
    \t\n\x05Melee\x10\x02\"\x92\x01\n\x14CategoryScoreDetails\x12\x12\n\x04n\
    one\x18\x01\x20\x01(\x02R\x04none\x12\x12\n\x04army\x18\x02\x20\x01(\x02\
    R\x04army\x12\x18\n\x07economy\x18\x03\x20\x01(\x02R\x07economy\x12\x1e\
    \n\ntechnology\x18\x04\x20\x01(\x02R\ntechnology\x12\x18\n\x07upgrade\
    \x18\x05\x20\x01(\x02R\x07upgrade\"Y\n\x11VitalScoreDetails\x12\x12\n\
    \x04life\x18\x01\x20\x01(\x02R\x04life\x12\x18\n\x07shields\x18\x02\x20\
    \x01(\x02R\x07shields\x12\x16\n\x06energy\x18\x03\x20\x01(\x02R\x06energ\
    y\"\xf0\r\n\x0cScoreDetails\x120\n\x14idle_production_time\x18\x01\x20\
    \x01(\x02R\x12idleProductionTime\x12(\n\x10idle_worker_time\x18\x02\x20\
    \x01(\x02R\x0eidleWorkerTime\x12*\n\x11total_value_units\x18\x03\x20\x01\
    (\x02R\x0ftotalValueUnits\x124\n\x16total_value_structures\x18\x04\x20\
    \x01(\x02R\x14totalValueStructures\x12,\n\x12killed_value_units\x18\x05\
    \x20\x01(\x02R\x10killedValueUnits\x126\n\x17killed_value_structures\x18\
    \x06\x20\x01(\x02R\x15killedValueStructures\x12-\n\x12collected_minerals\
    \x18\x07\x20\x01(\x02R\x11collectedMinerals\x12+\n\x11collected_vespene\
    \x18\x08\x20\x01(\x02R\x10collectedVespene\x128\n\x18collection_rate_min\
    erals\x18\t\x20\x01(\x02R\x16collectionRateMinerals\x126\n\x17collection\
    _rate_vespene\x18\n\x20\x01(\x02R\x15collectionRateVespene\x12%\n\x0espe\
    nt_minerals\x18\x0b\x20\x01(\x02R\rspentMinerals\x12#\n\rspent_vespene\
    \x18\x0c\x20\x01(\x02R\x0cspentVespene\x12A\n\tfood_used\x18\r\x20\x01(\
    \x0b2$.SC2APIProtocol.CategoryScoreDetailsR\x08foodUsed\x12M\n\x0fkilled\
    _minerals\x18\x0e\x20\x01(\x0b2$.SC2APIProtocol.CategoryScoreDetailsR\
    \x0ekilledMinerals\x12K\n\x0ekilled_vespene\x18\x0f\x20\x01(\x0b2$.SC2AP\
    IProtocol.CategoryScoreDetailsR\rkilledVespene\x12I\n\rlost_minerals\x18\
    \x10\x20\x01(\x0b2$.SC2APIProtocol.CategoryScoreDetailsR\x0clostMinerals\
    \x12G\n\x0clost_vespene\x18\x11\x20\x01(\x0b2$.SC2APIProtocol.CategorySc\
    oreDetailsR\x0blostVespene\x12Z\n\x16friendly_fire_minerals\x18\x12\x20\
    \x01(\x0b2$.SC2APIProtocol.CategoryScoreDetailsR\x14friendlyFireMinerals\
    \x12X\n\x15friendly_fire_vespene\x18\x13\x20\x01(\x0b2$.SC2APIProtocol.C\
    ategoryScoreDetailsR\x13friendlyFireVespene\x12I\n\rused_minerals\x18\
    \x14\x20\x01(\x0b2$.SC2APIProtocol.CategoryScoreDetailsR\x0cusedMinerals\
    \x12G\n\x0cused_vespene\x18\x15\x20\x01(\x0b2$.SC2APIProtocol.CategorySc\
    oreDetailsR\x0busedVespene\x12T\n\x13total_used_minerals\x18\x16\x20\x01\
    (\x0b2$.SC2APIProtocol.CategoryScoreDetailsR\x11totalUsedMinerals\x12R\n\
    \x12total_used_vespene\x18\x17\x20\x01(\x0b2$.SC2APIProtocol.CategorySco\
    reDetailsR\x10totalUsedVespene\x12O\n\x12total_damage_dealt\x18\x18\x20\
    \x01(\x0b2!.SC2APIProtocol.VitalScoreDetailsR\x10totalDamageDealt\x12O\n\
    \x12total_damage_taken\x18\x19\x20\x01(\x0b2!.SC2APIProtocol.VitalScoreD\
    etailsR\x10totalDamageTaken\x12D\n\x0ctotal_healed\x18\x1a\x20\x01(\x0b2\
    !.SC2APIProtocol.VitalScoreDetailsR\x0btotalHealed\x12\x1f\n\x0bcurrent_\
    apm\x18\x1b\x20\x01(\x02R\ncurrentApm\x122\n\x15current_effective_apm\
    \x18\x1c\x20\x01(\x02R\x13currentEffectiveApm\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(4);
            messages.push(Score::generated_message_descriptor_data());
            messages.push(CategoryScoreDetails::generated_message_descriptor_data());
            messages.push(VitalScoreDetails::generated_message_descriptor_data());
            messages.push(ScoreDetails::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(score::ScoreType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

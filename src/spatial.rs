// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/spatial.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:SC2APIProtocol.ObservationFeatureLayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObservationFeatureLayer {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationFeatureLayer.renders)
    pub renders: ::protobuf::MessageField<FeatureLayers>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationFeatureLayer.minimap_renders)
    pub minimap_renders: ::protobuf::MessageField<FeatureLayersMinimap>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ObservationFeatureLayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObservationFeatureLayer {
    fn default() -> &'a ObservationFeatureLayer {
        <ObservationFeatureLayer as ::protobuf::Message>::default_instance()
    }
}

impl ObservationFeatureLayer {
    pub fn new() -> ObservationFeatureLayer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeatureLayers>(
            "renders",
            |m: &ObservationFeatureLayer| { &m.renders },
            |m: &mut ObservationFeatureLayer| { &mut m.renders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FeatureLayersMinimap>(
            "minimap_renders",
            |m: &ObservationFeatureLayer| { &m.minimap_renders },
            |m: &mut ObservationFeatureLayer| { &mut m.minimap_renders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObservationFeatureLayer>(
            "ObservationFeatureLayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObservationFeatureLayer {
    const NAME: &'static str = "ObservationFeatureLayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.renders)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.minimap_renders)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.renders.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minimap_renders.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.renders.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.minimap_renders.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObservationFeatureLayer {
        ObservationFeatureLayer::new()
    }

    fn clear(&mut self) {
        self.renders.clear();
        self.minimap_renders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObservationFeatureLayer {
        static instance: ObservationFeatureLayer = ObservationFeatureLayer {
            renders: ::protobuf::MessageField::none(),
            minimap_renders: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObservationFeatureLayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObservationFeatureLayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObservationFeatureLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationFeatureLayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.FeatureLayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureLayers {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.height_map)
    pub height_map: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.visibility_map)
    pub visibility_map: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.creep)
    pub creep: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.power)
    pub power: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.player_id)
    pub player_id: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_type)
    pub unit_type: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.selected)
    pub selected: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_hit_points)
    pub unit_hit_points: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_hit_points_ratio)
    pub unit_hit_points_ratio: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_energy)
    pub unit_energy: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_energy_ratio)
    pub unit_energy_ratio: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_shields)
    pub unit_shields: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_shields_ratio)
    pub unit_shields_ratio: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.player_relative)
    pub player_relative: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_density_aa)
    pub unit_density_aa: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.unit_density)
    pub unit_density: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.effects)
    pub effects: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.hallucinations)
    pub hallucinations: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.cloaked)
    pub cloaked: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.blip)
    pub blip: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.buffs)
    pub buffs: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.buff_duration)
    pub buff_duration: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.active)
    pub active: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.build_progress)
    pub build_progress: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.buildable)
    pub buildable: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.pathable)
    pub pathable: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayers.placeholder)
    pub placeholder: ::protobuf::MessageField<super::common::ImageData>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.FeatureLayers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureLayers {
    fn default() -> &'a FeatureLayers {
        <FeatureLayers as ::protobuf::Message>::default_instance()
    }
}

impl FeatureLayers {
    pub fn new() -> FeatureLayers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "height_map",
            |m: &FeatureLayers| { &m.height_map },
            |m: &mut FeatureLayers| { &mut m.height_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "visibility_map",
            |m: &FeatureLayers| { &m.visibility_map },
            |m: &mut FeatureLayers| { &mut m.visibility_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "creep",
            |m: &FeatureLayers| { &m.creep },
            |m: &mut FeatureLayers| { &mut m.creep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "power",
            |m: &FeatureLayers| { &m.power },
            |m: &mut FeatureLayers| { &mut m.power },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "player_id",
            |m: &FeatureLayers| { &m.player_id },
            |m: &mut FeatureLayers| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_type",
            |m: &FeatureLayers| { &m.unit_type },
            |m: &mut FeatureLayers| { &mut m.unit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "selected",
            |m: &FeatureLayers| { &m.selected },
            |m: &mut FeatureLayers| { &mut m.selected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_hit_points",
            |m: &FeatureLayers| { &m.unit_hit_points },
            |m: &mut FeatureLayers| { &mut m.unit_hit_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_hit_points_ratio",
            |m: &FeatureLayers| { &m.unit_hit_points_ratio },
            |m: &mut FeatureLayers| { &mut m.unit_hit_points_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_energy",
            |m: &FeatureLayers| { &m.unit_energy },
            |m: &mut FeatureLayers| { &mut m.unit_energy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_energy_ratio",
            |m: &FeatureLayers| { &m.unit_energy_ratio },
            |m: &mut FeatureLayers| { &mut m.unit_energy_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_shields",
            |m: &FeatureLayers| { &m.unit_shields },
            |m: &mut FeatureLayers| { &mut m.unit_shields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_shields_ratio",
            |m: &FeatureLayers| { &m.unit_shields_ratio },
            |m: &mut FeatureLayers| { &mut m.unit_shields_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "player_relative",
            |m: &FeatureLayers| { &m.player_relative },
            |m: &mut FeatureLayers| { &mut m.player_relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_density_aa",
            |m: &FeatureLayers| { &m.unit_density_aa },
            |m: &mut FeatureLayers| { &mut m.unit_density_aa },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_density",
            |m: &FeatureLayers| { &m.unit_density },
            |m: &mut FeatureLayers| { &mut m.unit_density },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "effects",
            |m: &FeatureLayers| { &m.effects },
            |m: &mut FeatureLayers| { &mut m.effects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "hallucinations",
            |m: &FeatureLayers| { &m.hallucinations },
            |m: &mut FeatureLayers| { &mut m.hallucinations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "cloaked",
            |m: &FeatureLayers| { &m.cloaked },
            |m: &mut FeatureLayers| { &mut m.cloaked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "blip",
            |m: &FeatureLayers| { &m.blip },
            |m: &mut FeatureLayers| { &mut m.blip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "buffs",
            |m: &FeatureLayers| { &m.buffs },
            |m: &mut FeatureLayers| { &mut m.buffs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "buff_duration",
            |m: &FeatureLayers| { &m.buff_duration },
            |m: &mut FeatureLayers| { &mut m.buff_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "active",
            |m: &FeatureLayers| { &m.active },
            |m: &mut FeatureLayers| { &mut m.active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "build_progress",
            |m: &FeatureLayers| { &m.build_progress },
            |m: &mut FeatureLayers| { &mut m.build_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "buildable",
            |m: &FeatureLayers| { &m.buildable },
            |m: &mut FeatureLayers| { &mut m.buildable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "pathable",
            |m: &FeatureLayers| { &m.pathable },
            |m: &mut FeatureLayers| { &mut m.pathable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "placeholder",
            |m: &FeatureLayers| { &m.placeholder },
            |m: &mut FeatureLayers| { &mut m.placeholder },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureLayers>(
            "FeatureLayers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureLayers {
    const NAME: &'static str = "FeatureLayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height_map)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility_map)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.creep)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.power)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_id)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_type)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selected)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_hit_points)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_hit_points_ratio)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_energy)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_energy_ratio)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_shields)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_shields_ratio)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_relative)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_density_aa)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_density)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.effects)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hallucinations)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cloaked)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.blip)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buffs)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buff_duration)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.active)?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_progress)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buildable)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pathable)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.placeholder)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.creep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.power.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_hit_points.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_hit_points_ratio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_energy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_energy_ratio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_shields.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_shields_ratio.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_relative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_density_aa.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_density.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effects.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hallucinations.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cloaked.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.blip.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buffs.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buff_duration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.active.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.build_progress.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buildable.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pathable.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.placeholder.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.visibility_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.creep.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.power.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.player_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.unit_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.selected.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.unit_hit_points.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.unit_hit_points_ratio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.unit_energy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.unit_energy_ratio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.unit_shields.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.unit_shields_ratio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.player_relative.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.unit_density_aa.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.unit_density.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.effects.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.hallucinations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.cloaked.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.blip.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.buffs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.buff_duration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.active.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.build_progress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.buildable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.pathable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.placeholder.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureLayers {
        FeatureLayers::new()
    }

    fn clear(&mut self) {
        self.height_map.clear();
        self.visibility_map.clear();
        self.creep.clear();
        self.power.clear();
        self.player_id.clear();
        self.unit_type.clear();
        self.selected.clear();
        self.unit_hit_points.clear();
        self.unit_hit_points_ratio.clear();
        self.unit_energy.clear();
        self.unit_energy_ratio.clear();
        self.unit_shields.clear();
        self.unit_shields_ratio.clear();
        self.player_relative.clear();
        self.unit_density_aa.clear();
        self.unit_density.clear();
        self.effects.clear();
        self.hallucinations.clear();
        self.cloaked.clear();
        self.blip.clear();
        self.buffs.clear();
        self.buff_duration.clear();
        self.active.clear();
        self.build_progress.clear();
        self.buildable.clear();
        self.pathable.clear();
        self.placeholder.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureLayers {
        static instance: FeatureLayers = FeatureLayers {
            height_map: ::protobuf::MessageField::none(),
            visibility_map: ::protobuf::MessageField::none(),
            creep: ::protobuf::MessageField::none(),
            power: ::protobuf::MessageField::none(),
            player_id: ::protobuf::MessageField::none(),
            unit_type: ::protobuf::MessageField::none(),
            selected: ::protobuf::MessageField::none(),
            unit_hit_points: ::protobuf::MessageField::none(),
            unit_hit_points_ratio: ::protobuf::MessageField::none(),
            unit_energy: ::protobuf::MessageField::none(),
            unit_energy_ratio: ::protobuf::MessageField::none(),
            unit_shields: ::protobuf::MessageField::none(),
            unit_shields_ratio: ::protobuf::MessageField::none(),
            player_relative: ::protobuf::MessageField::none(),
            unit_density_aa: ::protobuf::MessageField::none(),
            unit_density: ::protobuf::MessageField::none(),
            effects: ::protobuf::MessageField::none(),
            hallucinations: ::protobuf::MessageField::none(),
            cloaked: ::protobuf::MessageField::none(),
            blip: ::protobuf::MessageField::none(),
            buffs: ::protobuf::MessageField::none(),
            buff_duration: ::protobuf::MessageField::none(),
            active: ::protobuf::MessageField::none(),
            build_progress: ::protobuf::MessageField::none(),
            buildable: ::protobuf::MessageField::none(),
            pathable: ::protobuf::MessageField::none(),
            placeholder: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureLayers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureLayers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureLayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureLayers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.FeatureLayersMinimap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureLayersMinimap {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.height_map)
    pub height_map: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.visibility_map)
    pub visibility_map: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.creep)
    pub creep: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.camera)
    pub camera: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.player_id)
    pub player_id: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.player_relative)
    pub player_relative: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.selected)
    pub selected: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.alerts)
    pub alerts: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.buildable)
    pub buildable: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.pathable)
    pub pathable: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.FeatureLayersMinimap.unit_type)
    pub unit_type: ::protobuf::MessageField<super::common::ImageData>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.FeatureLayersMinimap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureLayersMinimap {
    fn default() -> &'a FeatureLayersMinimap {
        <FeatureLayersMinimap as ::protobuf::Message>::default_instance()
    }
}

impl FeatureLayersMinimap {
    pub fn new() -> FeatureLayersMinimap {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "height_map",
            |m: &FeatureLayersMinimap| { &m.height_map },
            |m: &mut FeatureLayersMinimap| { &mut m.height_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "visibility_map",
            |m: &FeatureLayersMinimap| { &m.visibility_map },
            |m: &mut FeatureLayersMinimap| { &mut m.visibility_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "creep",
            |m: &FeatureLayersMinimap| { &m.creep },
            |m: &mut FeatureLayersMinimap| { &mut m.creep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "camera",
            |m: &FeatureLayersMinimap| { &m.camera },
            |m: &mut FeatureLayersMinimap| { &mut m.camera },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "player_id",
            |m: &FeatureLayersMinimap| { &m.player_id },
            |m: &mut FeatureLayersMinimap| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "player_relative",
            |m: &FeatureLayersMinimap| { &m.player_relative },
            |m: &mut FeatureLayersMinimap| { &mut m.player_relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "selected",
            |m: &FeatureLayersMinimap| { &m.selected },
            |m: &mut FeatureLayersMinimap| { &mut m.selected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "alerts",
            |m: &FeatureLayersMinimap| { &m.alerts },
            |m: &mut FeatureLayersMinimap| { &mut m.alerts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "buildable",
            |m: &FeatureLayersMinimap| { &m.buildable },
            |m: &mut FeatureLayersMinimap| { &mut m.buildable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "pathable",
            |m: &FeatureLayersMinimap| { &m.pathable },
            |m: &mut FeatureLayersMinimap| { &mut m.pathable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "unit_type",
            |m: &FeatureLayersMinimap| { &m.unit_type },
            |m: &mut FeatureLayersMinimap| { &mut m.unit_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureLayersMinimap>(
            "FeatureLayersMinimap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureLayersMinimap {
    const NAME: &'static str = "FeatureLayersMinimap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.height_map)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility_map)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.creep)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.camera)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_id)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_relative)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selected)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.alerts)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buildable)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pathable)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit_type)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.height_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.visibility_map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.creep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.camera.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_relative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.alerts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buildable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pathable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unit_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.height_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.visibility_map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.creep.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.camera.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.player_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.player_relative.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.selected.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.alerts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.buildable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.pathable.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.unit_type.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureLayersMinimap {
        FeatureLayersMinimap::new()
    }

    fn clear(&mut self) {
        self.height_map.clear();
        self.visibility_map.clear();
        self.creep.clear();
        self.camera.clear();
        self.player_id.clear();
        self.player_relative.clear();
        self.selected.clear();
        self.alerts.clear();
        self.buildable.clear();
        self.pathable.clear();
        self.unit_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureLayersMinimap {
        static instance: FeatureLayersMinimap = FeatureLayersMinimap {
            height_map: ::protobuf::MessageField::none(),
            visibility_map: ::protobuf::MessageField::none(),
            creep: ::protobuf::MessageField::none(),
            camera: ::protobuf::MessageField::none(),
            player_id: ::protobuf::MessageField::none(),
            player_relative: ::protobuf::MessageField::none(),
            selected: ::protobuf::MessageField::none(),
            alerts: ::protobuf::MessageField::none(),
            buildable: ::protobuf::MessageField::none(),
            pathable: ::protobuf::MessageField::none(),
            unit_type: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureLayersMinimap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureLayersMinimap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureLayersMinimap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureLayersMinimap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ObservationRender)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObservationRender {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRender.map)
    pub map: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRender.minimap)
    pub minimap: ::protobuf::MessageField<super::common::ImageData>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ObservationRender.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObservationRender {
    fn default() -> &'a ObservationRender {
        <ObservationRender as ::protobuf::Message>::default_instance()
    }
}

impl ObservationRender {
    pub fn new() -> ObservationRender {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "map",
            |m: &ObservationRender| { &m.map },
            |m: &mut ObservationRender| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "minimap",
            |m: &ObservationRender| { &m.minimap },
            |m: &mut ObservationRender| { &mut m.minimap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObservationRender>(
            "ObservationRender",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObservationRender {
    const NAME: &'static str = "ObservationRender";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.map)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.minimap)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minimap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.minimap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObservationRender {
        ObservationRender::new()
    }

    fn clear(&mut self) {
        self.map.clear();
        self.minimap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObservationRender {
        static instance: ObservationRender = ObservationRender {
            map: ::protobuf::MessageField::none(),
            minimap: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObservationRender {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObservationRender").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObservationRender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRender {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionSpatial)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionSpatial {
    // message oneof groups
    pub action: ::std::option::Option<action_spatial::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSpatial.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSpatial {
    fn default() -> &'a ActionSpatial {
        <ActionSpatial as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatial {
    pub fn new() -> ActionSpatial {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionSpatialUnitCommand unit_command = 1;

    pub fn unit_command(&self) -> &ActionSpatialUnitCommand {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitCommand(ref v)) => v,
            _ => <ActionSpatialUnitCommand as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unit_command(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_command(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_command(&mut self, v: ActionSpatialUnitCommand) {
        self.action = ::std::option::Option::Some(action_spatial::Action::UnitCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_command(&mut self) -> &mut ActionSpatialUnitCommand {
        if let ::std::option::Option::Some(action_spatial::Action::UnitCommand(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_spatial::Action::UnitCommand(ActionSpatialUnitCommand::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_command(&mut self) -> ActionSpatialUnitCommand {
        if self.has_unit_command() {
            match self.action.take() {
                ::std::option::Option::Some(action_spatial::Action::UnitCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialUnitCommand::new()
        }
    }

    // optional .SC2APIProtocol.ActionSpatialCameraMove camera_move = 2;

    pub fn camera_move(&self) -> &ActionSpatialCameraMove {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::CameraMove(ref v)) => v,
            _ => <ActionSpatialCameraMove as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_camera_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::CameraMove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_move(&mut self, v: ActionSpatialCameraMove) {
        self.action = ::std::option::Option::Some(action_spatial::Action::CameraMove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_move(&mut self) -> &mut ActionSpatialCameraMove {
        if let ::std::option::Option::Some(action_spatial::Action::CameraMove(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_spatial::Action::CameraMove(ActionSpatialCameraMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::CameraMove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_move(&mut self) -> ActionSpatialCameraMove {
        if self.has_camera_move() {
            match self.action.take() {
                ::std::option::Option::Some(action_spatial::Action::CameraMove(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialCameraMove::new()
        }
    }

    // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint unit_selection_point = 3;

    pub fn unit_selection_point(&self) -> &ActionSpatialUnitSelectionPoint {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(ref v)) => v,
            _ => <ActionSpatialUnitSelectionPoint as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unit_selection_point(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_selection_point(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_selection_point(&mut self, v: ActionSpatialUnitSelectionPoint) {
        self.action = ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_selection_point(&mut self) -> &mut ActionSpatialUnitSelectionPoint {
        if let ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(ActionSpatialUnitSelectionPoint::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_selection_point(&mut self) -> ActionSpatialUnitSelectionPoint {
        if self.has_unit_selection_point() {
            match self.action.take() {
                ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialUnitSelectionPoint::new()
        }
    }

    // optional .SC2APIProtocol.ActionSpatialUnitSelectionRect unit_selection_rect = 4;

    pub fn unit_selection_rect(&self) -> &ActionSpatialUnitSelectionRect {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(ref v)) => v,
            _ => <ActionSpatialUnitSelectionRect as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unit_selection_rect(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_selection_rect(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_selection_rect(&mut self, v: ActionSpatialUnitSelectionRect) {
        self.action = ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_selection_rect(&mut self) -> &mut ActionSpatialUnitSelectionRect {
        if let ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(ActionSpatialUnitSelectionRect::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_selection_rect(&mut self) -> ActionSpatialUnitSelectionRect {
        if self.has_unit_selection_rect() {
            match self.action.take() {
                ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSpatialUnitSelectionRect::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSpatialUnitCommand>(
            "unit_command",
            ActionSpatial::has_unit_command,
            ActionSpatial::unit_command,
            ActionSpatial::mut_unit_command,
            ActionSpatial::set_unit_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSpatialCameraMove>(
            "camera_move",
            ActionSpatial::has_camera_move,
            ActionSpatial::camera_move,
            ActionSpatial::mut_camera_move,
            ActionSpatial::set_camera_move,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSpatialUnitSelectionPoint>(
            "unit_selection_point",
            ActionSpatial::has_unit_selection_point,
            ActionSpatial::unit_selection_point,
            ActionSpatial::mut_unit_selection_point,
            ActionSpatial::set_unit_selection_point,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSpatialUnitSelectionRect>(
            "unit_selection_rect",
            ActionSpatial::has_unit_selection_rect,
            ActionSpatial::unit_selection_rect,
            ActionSpatial::mut_unit_selection_rect,
            ActionSpatial::set_unit_selection_rect,
        ));
        oneofs.push(action_spatial::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSpatial>(
            "ActionSpatial",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSpatial {
    const NAME: &'static str = "ActionSpatial";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.action = ::std::option::Option::Some(action_spatial::Action::UnitCommand(is.read_message()?));
                },
                18 => {
                    self.action = ::std::option::Option::Some(action_spatial::Action::CameraMove(is.read_message()?));
                },
                26 => {
                    self.action = ::std::option::Option::Some(action_spatial::Action::UnitSelectionPoint(is.read_message()?));
                },
                34 => {
                    self.action = ::std::option::Option::Some(action_spatial::Action::UnitSelectionRect(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &action_spatial::Action::UnitCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_spatial::Action::CameraMove(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_spatial::Action::UnitSelectionPoint(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_spatial::Action::UnitSelectionRect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &action_spatial::Action::UnitCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &action_spatial::Action::CameraMove(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &action_spatial::Action::UnitSelectionPoint(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &action_spatial::Action::UnitSelectionRect(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSpatial {
        ActionSpatial::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSpatial {
        static instance: ActionSpatial = ActionSpatial {
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSpatial {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSpatial").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSpatial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatial {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionSpatial`
pub mod action_spatial {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ActionSpatial.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionSpatial.unit_command)
        UnitCommand(super::ActionSpatialUnitCommand),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionSpatial.camera_move)
        CameraMove(super::ActionSpatialCameraMove),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionSpatial.unit_selection_point)
        UnitSelectionPoint(super::ActionSpatialUnitSelectionPoint),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionSpatial.unit_selection_rect)
        UnitSelectionRect(super::ActionSpatialUnitSelectionRect),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ActionSpatial as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionSpatialUnitCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionSpatialUnitCommand {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialUnitCommand.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialUnitCommand.queue_command)
    pub queue_command: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<action_spatial_unit_command::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSpatialUnitCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSpatialUnitCommand {
    fn default() -> &'a ActionSpatialUnitCommand {
        <ActionSpatialUnitCommand as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialUnitCommand {
    pub fn new() -> ActionSpatialUnitCommand {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.PointI target_screen_coord = 2;

    pub fn target_screen_coord(&self) -> &super::common::PointI {
        match self.target {
            ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(ref v)) => v,
            _ => <super::common::PointI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_screen_coord(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_screen_coord(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_screen_coord(&mut self, v: super::common::PointI) {
        self.target = ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_screen_coord(&mut self) -> &mut super::common::PointI {
        if let ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(super::common::PointI::new()));
        }
        match self.target {
            ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_screen_coord(&mut self) -> super::common::PointI {
        if self.has_target_screen_coord() {
            match self.target.take() {
                ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::PointI::new()
        }
    }

    // optional .SC2APIProtocol.PointI target_minimap_coord = 3;

    pub fn target_minimap_coord(&self) -> &super::common::PointI {
        match self.target {
            ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(ref v)) => v,
            _ => <super::common::PointI as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_minimap_coord(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_minimap_coord(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_minimap_coord(&mut self, v: super::common::PointI) {
        self.target = ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_minimap_coord(&mut self) -> &mut super::common::PointI {
        if let ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(super::common::PointI::new()));
        }
        match self.target {
            ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_minimap_coord(&mut self) -> super::common::PointI {
        if self.has_target_minimap_coord() {
            match self.target.take() {
                ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::PointI::new()
        }
    }

    // optional bool queue_command = 4;

    pub fn queue_command(&self) -> bool {
        self.queue_command.unwrap_or(false)
    }

    pub fn clear_queue_command(&mut self) {
        self.queue_command = ::std::option::Option::None;
    }

    pub fn has_queue_command(&self) -> bool {
        self.queue_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_command(&mut self, v: bool) {
        self.queue_command = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &ActionSpatialUnitCommand| { &m.ability_id },
            |m: &mut ActionSpatialUnitCommand| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::common::PointI>(
            "target_screen_coord",
            ActionSpatialUnitCommand::has_target_screen_coord,
            ActionSpatialUnitCommand::target_screen_coord,
            ActionSpatialUnitCommand::mut_target_screen_coord,
            ActionSpatialUnitCommand::set_target_screen_coord,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::common::PointI>(
            "target_minimap_coord",
            ActionSpatialUnitCommand::has_target_minimap_coord,
            ActionSpatialUnitCommand::target_minimap_coord,
            ActionSpatialUnitCommand::mut_target_minimap_coord,
            ActionSpatialUnitCommand::set_target_minimap_coord,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_command",
            |m: &ActionSpatialUnitCommand| { &m.queue_command },
            |m: &mut ActionSpatialUnitCommand| { &mut m.queue_command },
        ));
        oneofs.push(action_spatial_unit_command::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSpatialUnitCommand>(
            "ActionSpatialUnitCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSpatialUnitCommand {
    const NAME: &'static str = "ActionSpatialUnitCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.target = ::std::option::Option::Some(action_spatial_unit_command::Target::TargetScreenCoord(is.read_message()?));
                },
                26 => {
                    self.target = ::std::option::Option::Some(action_spatial_unit_command::Target::TargetMinimapCoord(is.read_message()?));
                },
                32 => {
                    self.queue_command = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.queue_command {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &action_spatial_unit_command::Target::TargetScreenCoord(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_spatial_unit_command::Target::TargetMinimapCoord(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.queue_command {
            os.write_bool(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &action_spatial_unit_command::Target::TargetScreenCoord(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &action_spatial_unit_command::Target::TargetMinimapCoord(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSpatialUnitCommand {
        ActionSpatialUnitCommand::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.queue_command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSpatialUnitCommand {
        static instance: ActionSpatialUnitCommand = ActionSpatialUnitCommand {
            ability_id: ::std::option::Option::None,
            queue_command: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSpatialUnitCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSpatialUnitCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSpatialUnitCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionSpatialUnitCommand`
pub mod action_spatial_unit_command {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ActionSpatialUnitCommand.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionSpatialUnitCommand.target_screen_coord)
        TargetScreenCoord(super::super::common::PointI),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionSpatialUnitCommand.target_minimap_coord)
        TargetMinimapCoord(super::super::common::PointI),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ActionSpatialUnitCommand as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionSpatialCameraMove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionSpatialCameraMove {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialCameraMove.center_minimap)
    pub center_minimap: ::protobuf::MessageField<super::common::PointI>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSpatialCameraMove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSpatialCameraMove {
    fn default() -> &'a ActionSpatialCameraMove {
        <ActionSpatialCameraMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialCameraMove {
    pub fn new() -> ActionSpatialCameraMove {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::PointI>(
            "center_minimap",
            |m: &ActionSpatialCameraMove| { &m.center_minimap },
            |m: &mut ActionSpatialCameraMove| { &mut m.center_minimap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSpatialCameraMove>(
            "ActionSpatialCameraMove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSpatialCameraMove {
    const NAME: &'static str = "ActionSpatialCameraMove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.center_minimap)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.center_minimap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.center_minimap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSpatialCameraMove {
        ActionSpatialCameraMove::new()
    }

    fn clear(&mut self) {
        self.center_minimap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSpatialCameraMove {
        static instance: ActionSpatialCameraMove = ActionSpatialCameraMove {
            center_minimap: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSpatialCameraMove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSpatialCameraMove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSpatialCameraMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialCameraMove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionSpatialUnitSelectionPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionSpatialUnitSelectionPoint {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialUnitSelectionPoint.selection_screen_coord)
    pub selection_screen_coord: ::protobuf::MessageField<super::common::PointI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialUnitSelectionPoint.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<action_spatial_unit_selection_point::Type>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSpatialUnitSelectionPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSpatialUnitSelectionPoint {
    fn default() -> &'a ActionSpatialUnitSelectionPoint {
        <ActionSpatialUnitSelectionPoint as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialUnitSelectionPoint {
    pub fn new() -> ActionSpatialUnitSelectionPoint {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type type = 2;

    pub fn type_(&self) -> action_spatial_unit_selection_point::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(action_spatial_unit_selection_point::Type::Select),
            None => action_spatial_unit_selection_point::Type::Select,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: action_spatial_unit_selection_point::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::PointI>(
            "selection_screen_coord",
            |m: &ActionSpatialUnitSelectionPoint| { &m.selection_screen_coord },
            |m: &mut ActionSpatialUnitSelectionPoint| { &mut m.selection_screen_coord },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ActionSpatialUnitSelectionPoint| { &m.type_ },
            |m: &mut ActionSpatialUnitSelectionPoint| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSpatialUnitSelectionPoint>(
            "ActionSpatialUnitSelectionPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSpatialUnitSelectionPoint {
    const NAME: &'static str = "ActionSpatialUnitSelectionPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.selection_screen_coord)?;
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selection_screen_coord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selection_screen_coord.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSpatialUnitSelectionPoint {
        ActionSpatialUnitSelectionPoint::new()
    }

    fn clear(&mut self) {
        self.selection_screen_coord.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSpatialUnitSelectionPoint {
        static instance: ActionSpatialUnitSelectionPoint = ActionSpatialUnitSelectionPoint {
            selection_screen_coord: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSpatialUnitSelectionPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSpatialUnitSelectionPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSpatialUnitSelectionPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitSelectionPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionSpatialUnitSelectionPoint`
pub mod action_spatial_unit_selection_point {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type.Select)
        Select = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type.Toggle)
        Toggle = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type.AllType)
        AllType = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSpatialUnitSelectionPoint.Type.AddAllType)
        AddAllType = 4,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::Select),
                2 => ::std::option::Option::Some(Type::Toggle),
                3 => ::std::option::Option::Some(Type::AllType),
                4 => ::std::option::Option::Some(Type::AddAllType),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "Select" => ::std::option::Option::Some(Type::Select),
                "Toggle" => ::std::option::Option::Some(Type::Toggle),
                "AllType" => ::std::option::Option::Some(Type::AllType),
                "AddAllType" => ::std::option::Option::Some(Type::AddAllType),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::Select,
            Type::Toggle,
            Type::AllType,
            Type::AddAllType,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActionSpatialUnitSelectionPoint.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::Select => 0,
                Type::Toggle => 1,
                Type::AllType => 2,
                Type::AddAllType => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::Select
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("ActionSpatialUnitSelectionPoint.Type")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionSpatialUnitSelectionRect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionSpatialUnitSelectionRect {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_screen_coord)
    pub selection_screen_coord: ::std::vec::Vec<super::common::RectangleI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSpatialUnitSelectionRect.selection_add)
    pub selection_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSpatialUnitSelectionRect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSpatialUnitSelectionRect {
    fn default() -> &'a ActionSpatialUnitSelectionRect {
        <ActionSpatialUnitSelectionRect as ::protobuf::Message>::default_instance()
    }
}

impl ActionSpatialUnitSelectionRect {
    pub fn new() -> ActionSpatialUnitSelectionRect {
        ::std::default::Default::default()
    }

    // optional bool selection_add = 2;

    pub fn selection_add(&self) -> bool {
        self.selection_add.unwrap_or(false)
    }

    pub fn clear_selection_add(&mut self) {
        self.selection_add = ::std::option::Option::None;
    }

    pub fn has_selection_add(&self) -> bool {
        self.selection_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_add(&mut self, v: bool) {
        self.selection_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selection_screen_coord",
            |m: &ActionSpatialUnitSelectionRect| { &m.selection_screen_coord },
            |m: &mut ActionSpatialUnitSelectionRect| { &mut m.selection_screen_coord },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_add",
            |m: &ActionSpatialUnitSelectionRect| { &m.selection_add },
            |m: &mut ActionSpatialUnitSelectionRect| { &mut m.selection_add },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSpatialUnitSelectionRect>(
            "ActionSpatialUnitSelectionRect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSpatialUnitSelectionRect {
    const NAME: &'static str = "ActionSpatialUnitSelectionRect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selection_screen_coord.push(is.read_message()?);
                },
                16 => {
                    self.selection_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.selection_screen_coord {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.selection_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.selection_screen_coord {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.selection_add {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSpatialUnitSelectionRect {
        ActionSpatialUnitSelectionRect::new()
    }

    fn clear(&mut self) {
        self.selection_screen_coord.clear();
        self.selection_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSpatialUnitSelectionRect {
        static instance: ActionSpatialUnitSelectionRect = ActionSpatialUnitSelectionRect {
            selection_screen_coord: ::std::vec::Vec::new(),
            selection_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSpatialUnitSelectionRect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSpatialUnitSelectionRect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSpatialUnitSelectionRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSpatialUnitSelectionRect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1es2clientprotocol/spatial.proto\x12\x0eSC2APIProtocol\x1a\x1ds2clie\
    ntprotocol/common.proto\"\xa1\x01\n\x17ObservationFeatureLayer\x127\n\
    \x07renders\x18\x01\x20\x01(\x0b2\x1d.SC2APIProtocol.FeatureLayersR\x07r\
    enders\x12M\n\x0fminimap_renders\x18\x02\x20\x01(\x0b2$.SC2APIProtocol.F\
    eatureLayersMinimapR\x0eminimapRenders\"\xe3\x0c\n\rFeatureLayers\x128\n\
    \nheight_map\x18\x01\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\theight\
    Map\x12@\n\x0evisibility_map\x18\x02\x20\x01(\x0b2\x19.SC2APIProtocol.Im\
    ageDataR\rvisibilityMap\x12/\n\x05creep\x18\x03\x20\x01(\x0b2\x19.SC2API\
    Protocol.ImageDataR\x05creep\x12/\n\x05power\x18\x04\x20\x01(\x0b2\x19.S\
    C2APIProtocol.ImageDataR\x05power\x126\n\tplayer_id\x18\x05\x20\x01(\x0b\
    2\x19.SC2APIProtocol.ImageDataR\x08playerId\x126\n\tunit_type\x18\x06\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08unitType\x125\n\x08selec\
    ted\x18\x07\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08selected\x12A\
    \n\x0funit_hit_points\x18\x08\x20\x01(\x0b2\x19.SC2APIProtocol.ImageData\
    R\runitHitPoints\x12L\n\x15unit_hit_points_ratio\x18\x11\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x12unitHitPointsRatio\x12:\n\x0bunit_ener\
    gy\x18\t\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\nunitEnergy\x12E\n\
    \x11unit_energy_ratio\x18\x12\x20\x01(\x0b2\x19.SC2APIProtocol.ImageData\
    R\x0funitEnergyRatio\x12<\n\x0cunit_shields\x18\n\x20\x01(\x0b2\x19.SC2A\
    PIProtocol.ImageDataR\x0bunitShields\x12G\n\x12unit_shields_ratio\x18\
    \x13\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x10unitShieldsRatio\x12\
    B\n\x0fplayer_relative\x18\x0b\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDat\
    aR\x0eplayerRelative\x12A\n\x0funit_density_aa\x18\x0e\x20\x01(\x0b2\x19\
    .SC2APIProtocol.ImageDataR\runitDensityAa\x12<\n\x0cunit_density\x18\x0f\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0bunitDensity\x123\n\x07ef\
    fects\x18\x14\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x07effects\x12\
    A\n\x0ehallucinations\x18\x15\x20\x01(\x0b2\x19.SC2APIProtocol.ImageData\
    R\x0ehallucinations\x123\n\x07cloaked\x18\x16\x20\x01(\x0b2\x19.SC2APIPr\
    otocol.ImageDataR\x07cloaked\x12-\n\x04blip\x18\x17\x20\x01(\x0b2\x19.SC\
    2APIProtocol.ImageDataR\x04blip\x12/\n\x05buffs\x18\x18\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x05buffs\x12>\n\rbuff_duration\x18\x1a\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0cbuffDuration\x121\n\x06a\
    ctive\x18\x19\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x06active\x12@\
    \n\x0ebuild_progress\x18\x1b\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\
    \rbuildProgress\x127\n\tbuildable\x18\x1c\x20\x01(\x0b2\x19.SC2APIProtoc\
    ol.ImageDataR\tbuildable\x125\n\x08pathable\x18\x1d\x20\x01(\x0b2\x19.SC\
    2APIProtocol.ImageDataR\x08pathable\x12;\n\x0bplaceholder\x18\x1e\x20\
    \x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0bplaceholder\"\x84\x05\n\x14F\
    eatureLayersMinimap\x128\n\nheight_map\x18\x01\x20\x01(\x0b2\x19.SC2APIP\
    rotocol.ImageDataR\theightMap\x12@\n\x0evisibility_map\x18\x02\x20\x01(\
    \x0b2\x19.SC2APIProtocol.ImageDataR\rvisibilityMap\x12/\n\x05creep\x18\
    \x03\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x05creep\x121\n\x06came\
    ra\x18\x04\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x06camera\x126\n\
    \tplayer_id\x18\x05\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08playe\
    rId\x12B\n\x0fplayer_relative\x18\x06\x20\x01(\x0b2\x19.SC2APIProtocol.I\
    mageDataR\x0eplayerRelative\x125\n\x08selected\x18\x07\x20\x01(\x0b2\x19\
    .SC2APIProtocol.ImageDataR\x08selected\x121\n\x06alerts\x18\t\x20\x01(\
    \x0b2\x19.SC2APIProtocol.ImageDataR\x06alerts\x127\n\tbuildable\x18\n\
    \x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\tbuildable\x125\n\x08pathab\
    le\x18\x0b\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08pathable\x126\
    \n\tunit_type\x18\x08\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x08uni\
    tType\"u\n\x11ObservationRender\x12+\n\x03map\x18\x01\x20\x01(\x0b2\x19.\
    SC2APIProtocol.ImageDataR\x03map\x123\n\x07minimap\x18\x02\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x07minimap\"\xfb\x02\n\rActionSpatial\x12\
    M\n\x0cunit_command\x18\x01\x20\x01(\x0b2(.SC2APIProtocol.ActionSpatialU\
    nitCommandH\0R\x0bunitCommand\x12J\n\x0bcamera_move\x18\x02\x20\x01(\x0b\
    2'.SC2APIProtocol.ActionSpatialCameraMoveH\0R\ncameraMove\x12c\n\x14unit\
    _selection_point\x18\x03\x20\x01(\x0b2/.SC2APIProtocol.ActionSpatialUnit\
    SelectionPointH\0R\x12unitSelectionPoint\x12`\n\x13unit_selection_rect\
    \x18\x04\x20\x01(\x0b2..SC2APIProtocol.ActionSpatialUnitSelectionRectH\0\
    R\x11unitSelectionRectB\x08\n\x06action\"\xfe\x01\n\x18ActionSpatialUnit\
    Command\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilityId\x12H\n\
    \x13target_screen_coord\x18\x02\x20\x01(\x0b2\x16.SC2APIProtocol.PointIH\
    \0R\x11targetScreenCoord\x12J\n\x14target_minimap_coord\x18\x03\x20\x01(\
    \x0b2\x16.SC2APIProtocol.PointIH\0R\x12targetMinimapCoord\x12#\n\rqueue_\
    command\x18\x04\x20\x01(\x08R\x0cqueueCommandB\x08\n\x06target\"X\n\x17A\
    ctionSpatialCameraMove\x12=\n\x0ecenter_minimap\x18\x01\x20\x01(\x0b2\
    \x16.SC2APIProtocol.PointIR\rcenterMinimap\"\xf6\x01\n\x1fActionSpatialU\
    nitSelectionPoint\x12L\n\x16selection_screen_coord\x18\x01\x20\x01(\x0b2\
    \x16.SC2APIProtocol.PointIR\x14selectionScreenCoord\x12H\n\x04type\x18\
    \x02\x20\x01(\x0e24.SC2APIProtocol.ActionSpatialUnitSelectionPoint.TypeR\
    \x04type\";\n\x04Type\x12\n\n\x06Select\x10\x01\x12\n\n\x06Toggle\x10\
    \x02\x12\x0b\n\x07AllType\x10\x03\x12\x0e\n\nAddAllType\x10\x04\"\x97\
    \x01\n\x1eActionSpatialUnitSelectionRect\x12P\n\x16selection_screen_coor\
    d\x18\x01\x20\x03(\x0b2\x1a.SC2APIProtocol.RectangleIR\x14selectionScree\
    nCoord\x12#\n\rselection_add\x18\x02\x20\x01(\x08R\x0cselectionAdd\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(ObservationFeatureLayer::generated_message_descriptor_data());
            messages.push(FeatureLayers::generated_message_descriptor_data());
            messages.push(FeatureLayersMinimap::generated_message_descriptor_data());
            messages.push(ObservationRender::generated_message_descriptor_data());
            messages.push(ActionSpatial::generated_message_descriptor_data());
            messages.push(ActionSpatialUnitCommand::generated_message_descriptor_data());
            messages.push(ActionSpatialCameraMove::generated_message_descriptor_data());
            messages.push(ActionSpatialUnitSelectionPoint::generated_message_descriptor_data());
            messages.push(ActionSpatialUnitSelectionRect::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(action_spatial_unit_selection_point::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

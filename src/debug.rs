// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 28.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/debug.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:SC2APIProtocol.DebugCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugCommand {
    // message oneof groups
    pub command: ::std::option::Option<debug_command::Command>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugCommand {
    fn default() -> &'a DebugCommand {
        <DebugCommand as ::protobuf::Message>::default_instance()
    }
}

impl DebugCommand {
    pub fn new() -> DebugCommand {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugDraw draw = 1;

    pub fn draw(&self) -> &DebugDraw {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::Draw(ref v)) => v,
            _ => <DebugDraw as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_draw(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_draw(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::Draw(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_draw(&mut self, v: DebugDraw) {
        self.command = ::std::option::Option::Some(debug_command::Command::Draw(v))
    }

    // Mutable pointer to the field.
    pub fn mut_draw(&mut self) -> &mut DebugDraw {
        if let ::std::option::Option::Some(debug_command::Command::Draw(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::Draw(DebugDraw::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::Draw(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_draw(&mut self) -> DebugDraw {
        if self.has_draw() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::Draw(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugDraw::new()
        }
    }

    // optional .SC2APIProtocol.DebugGameState game_state = 2;

    pub fn game_state(&self) -> DebugGameState {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::GameState(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => DebugGameState::show_map,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::GameState(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: DebugGameState) {
        self.command = ::std::option::Option::Some(debug_command::Command::GameState(::protobuf::EnumOrUnknown::new(v)))
    }

    // optional .SC2APIProtocol.DebugCreateUnit create_unit = 3;

    pub fn create_unit(&self) -> &DebugCreateUnit {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::CreateUnit(ref v)) => v,
            _ => <DebugCreateUnit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_unit(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_create_unit(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::CreateUnit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_unit(&mut self, v: DebugCreateUnit) {
        self.command = ::std::option::Option::Some(debug_command::Command::CreateUnit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_unit(&mut self) -> &mut DebugCreateUnit {
        if let ::std::option::Option::Some(debug_command::Command::CreateUnit(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::CreateUnit(DebugCreateUnit::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::CreateUnit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_unit(&mut self) -> DebugCreateUnit {
        if self.has_create_unit() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::CreateUnit(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugCreateUnit::new()
        }
    }

    // optional .SC2APIProtocol.DebugKillUnit kill_unit = 4;

    pub fn kill_unit(&self) -> &DebugKillUnit {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::KillUnit(ref v)) => v,
            _ => <DebugKillUnit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_kill_unit(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_kill_unit(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::KillUnit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kill_unit(&mut self, v: DebugKillUnit) {
        self.command = ::std::option::Option::Some(debug_command::Command::KillUnit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kill_unit(&mut self) -> &mut DebugKillUnit {
        if let ::std::option::Option::Some(debug_command::Command::KillUnit(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::KillUnit(DebugKillUnit::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::KillUnit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kill_unit(&mut self) -> DebugKillUnit {
        if self.has_kill_unit() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::KillUnit(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugKillUnit::new()
        }
    }

    // optional .SC2APIProtocol.DebugTestProcess test_process = 5;

    pub fn test_process(&self) -> &DebugTestProcess {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::TestProcess(ref v)) => v,
            _ => <DebugTestProcess as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_test_process(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_test_process(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::TestProcess(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_process(&mut self, v: DebugTestProcess) {
        self.command = ::std::option::Option::Some(debug_command::Command::TestProcess(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_process(&mut self) -> &mut DebugTestProcess {
        if let ::std::option::Option::Some(debug_command::Command::TestProcess(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::TestProcess(DebugTestProcess::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::TestProcess(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_process(&mut self) -> DebugTestProcess {
        if self.has_test_process() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::TestProcess(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugTestProcess::new()
        }
    }

    // optional .SC2APIProtocol.DebugSetScore score = 6;

    pub fn score(&self) -> &DebugSetScore {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::Score(ref v)) => v,
            _ => <DebugSetScore as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_score(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::Score(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: DebugSetScore) {
        self.command = ::std::option::Option::Some(debug_command::Command::Score(v))
    }

    // Mutable pointer to the field.
    pub fn mut_score(&mut self) -> &mut DebugSetScore {
        if let ::std::option::Option::Some(debug_command::Command::Score(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::Score(DebugSetScore::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::Score(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_score(&mut self) -> DebugSetScore {
        if self.has_score() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::Score(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugSetScore::new()
        }
    }

    // optional .SC2APIProtocol.DebugEndGame end_game = 7;

    pub fn end_game(&self) -> &DebugEndGame {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::EndGame(ref v)) => v,
            _ => <DebugEndGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_end_game(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_end_game(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::EndGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_end_game(&mut self, v: DebugEndGame) {
        self.command = ::std::option::Option::Some(debug_command::Command::EndGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_end_game(&mut self) -> &mut DebugEndGame {
        if let ::std::option::Option::Some(debug_command::Command::EndGame(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::EndGame(DebugEndGame::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::EndGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_end_game(&mut self) -> DebugEndGame {
        if self.has_end_game() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::EndGame(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugEndGame::new()
        }
    }

    // optional .SC2APIProtocol.DebugSetUnitValue unit_value = 8;

    pub fn unit_value(&self) -> &DebugSetUnitValue {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::UnitValue(ref v)) => v,
            _ => <DebugSetUnitValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unit_value(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_unit_value(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(debug_command::Command::UnitValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_value(&mut self, v: DebugSetUnitValue) {
        self.command = ::std::option::Option::Some(debug_command::Command::UnitValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_value(&mut self) -> &mut DebugSetUnitValue {
        if let ::std::option::Option::Some(debug_command::Command::UnitValue(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(debug_command::Command::UnitValue(DebugSetUnitValue::new()));
        }
        match self.command {
            ::std::option::Option::Some(debug_command::Command::UnitValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_value(&mut self) -> DebugSetUnitValue {
        if self.has_unit_value() {
            match self.command.take() {
                ::std::option::Option::Some(debug_command::Command::UnitValue(v)) => v,
                _ => panic!(),
            }
        } else {
            DebugSetUnitValue::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugDraw>(
            "draw",
            DebugCommand::has_draw,
            DebugCommand::draw,
            DebugCommand::mut_draw,
            DebugCommand::set_draw,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "game_state",
            |message: &DebugCommand| match &message.command {
                ::std::option::Option::Some(debug_command::Command::GameState(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut DebugCommand, e: ::protobuf::EnumOrUnknown<DebugGameState>| {
                message.command = ::std::option::Option::Some(debug_command::Command::GameState(e));
            },
            DebugGameState::show_map,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugCreateUnit>(
            "create_unit",
            DebugCommand::has_create_unit,
            DebugCommand::create_unit,
            DebugCommand::mut_create_unit,
            DebugCommand::set_create_unit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugKillUnit>(
            "kill_unit",
            DebugCommand::has_kill_unit,
            DebugCommand::kill_unit,
            DebugCommand::mut_kill_unit,
            DebugCommand::set_kill_unit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugTestProcess>(
            "test_process",
            DebugCommand::has_test_process,
            DebugCommand::test_process,
            DebugCommand::mut_test_process,
            DebugCommand::set_test_process,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugSetScore>(
            "score",
            DebugCommand::has_score,
            DebugCommand::score,
            DebugCommand::mut_score,
            DebugCommand::set_score,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugEndGame>(
            "end_game",
            DebugCommand::has_end_game,
            DebugCommand::end_game,
            DebugCommand::mut_end_game,
            DebugCommand::set_end_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DebugSetUnitValue>(
            "unit_value",
            DebugCommand::has_unit_value,
            DebugCommand::unit_value,
            DebugCommand::mut_unit_value,
            DebugCommand::set_unit_value,
        ));
        oneofs.push(debug_command::Command::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugCommand>(
            "DebugCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugCommand {
    const NAME: &'static str = "DebugCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::Draw(is.read_message()?));
                },
                16 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::GameState(is.read_enum_or_unknown()?));
                },
                26 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::CreateUnit(is.read_message()?));
                },
                34 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::KillUnit(is.read_message()?));
                },
                42 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::TestProcess(is.read_message()?));
                },
                50 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::Score(is.read_message()?));
                },
                58 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::EndGame(is.read_message()?));
                },
                66 => {
                    self.command = ::std::option::Option::Some(debug_command::Command::UnitValue(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &debug_command::Command::Draw(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &debug_command::Command::GameState(v) => {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                },
                &debug_command::Command::CreateUnit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &debug_command::Command::KillUnit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &debug_command::Command::TestProcess(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &debug_command::Command::Score(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &debug_command::Command::EndGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &debug_command::Command::UnitValue(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &debug_command::Command::Draw(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &debug_command::Command::GameState(v) => {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &debug_command::Command::CreateUnit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &debug_command::Command::KillUnit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &debug_command::Command::TestProcess(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &debug_command::Command::Score(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &debug_command::Command::EndGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &debug_command::Command::UnitValue(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugCommand {
        DebugCommand::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugCommand {
        static instance: DebugCommand = DebugCommand {
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DebugCommand`
pub mod debug_command {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.DebugCommand.command)
    pub enum Command {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.draw)
        Draw(super::DebugDraw),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.game_state)
        GameState(::protobuf::EnumOrUnknown<super::DebugGameState>),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.create_unit)
        CreateUnit(super::DebugCreateUnit),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.kill_unit)
        KillUnit(super::DebugKillUnit),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.test_process)
        TestProcess(super::DebugTestProcess),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.score)
        Score(super::DebugSetScore),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.end_game)
        EndGame(super::DebugEndGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.DebugCommand.unit_value)
        UnitValue(super::DebugSetUnitValue),
    }

    impl ::protobuf::Oneof for Command {
    }

    impl ::protobuf::OneofFull for Command {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DebugCommand as ::protobuf::MessageFull>::descriptor().oneof_by_name("command").unwrap()).clone()
        }
    }

    impl Command {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Command>("command")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugDraw)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugDraw {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugDraw.text)
    pub text: ::std::vec::Vec<DebugText>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugDraw.lines)
    pub lines: ::std::vec::Vec<DebugLine>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugDraw.boxes)
    pub boxes: ::std::vec::Vec<DebugBox>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugDraw.spheres)
    pub spheres: ::std::vec::Vec<DebugSphere>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugDraw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugDraw {
    fn default() -> &'a DebugDraw {
        <DebugDraw as ::protobuf::Message>::default_instance()
    }
}

impl DebugDraw {
    pub fn new() -> DebugDraw {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "text",
            |m: &DebugDraw| { &m.text },
            |m: &mut DebugDraw| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lines",
            |m: &DebugDraw| { &m.lines },
            |m: &mut DebugDraw| { &mut m.lines },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "boxes",
            |m: &DebugDraw| { &m.boxes },
            |m: &mut DebugDraw| { &mut m.boxes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "spheres",
            |m: &DebugDraw| { &m.spheres },
            |m: &mut DebugDraw| { &mut m.spheres },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugDraw>(
            "DebugDraw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugDraw {
    const NAME: &'static str = "DebugDraw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text.push(is.read_message()?);
                },
                18 => {
                    self.lines.push(is.read_message()?);
                },
                26 => {
                    self.boxes.push(is.read_message()?);
                },
                34 => {
                    self.spheres.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.text {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.lines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.boxes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.spheres {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.text {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.lines {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.boxes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.spheres {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugDraw {
        DebugDraw::new()
    }

    fn clear(&mut self) {
        self.text.clear();
        self.lines.clear();
        self.boxes.clear();
        self.spheres.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugDraw {
        static instance: DebugDraw = DebugDraw {
            text: ::std::vec::Vec::new(),
            lines: ::std::vec::Vec::new(),
            boxes: ::std::vec::Vec::new(),
            spheres: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugDraw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugDraw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugDraw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugDraw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.Line)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Line {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Line.p0)
    pub p0: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Line.p1)
    pub p1: ::protobuf::MessageField<super::common::Point>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Line.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Line {
    fn default() -> &'a Line {
        <Line as ::protobuf::Message>::default_instance()
    }
}

impl Line {
    pub fn new() -> Line {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "p0",
            |m: &Line| { &m.p0 },
            |m: &mut Line| { &mut m.p0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "p1",
            |m: &Line| { &m.p1 },
            |m: &mut Line| { &mut m.p1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Line>(
            "Line",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Line {
    const NAME: &'static str = "Line";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p0)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p1)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.p0.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.p0.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.p1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Line {
        Line::new()
    }

    fn clear(&mut self) {
        self.p0.clear();
        self.p1.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Line {
        static instance: Line = Line {
            p0: ::protobuf::MessageField::none(),
            p1: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Line {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Line").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Line {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Line {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.Color)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Color {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Color.r)
    pub r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Color.g)
    pub g: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Color.b)
    pub b: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Color.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Color {
    fn default() -> &'a Color {
        <Color as ::protobuf::Message>::default_instance()
    }
}

impl Color {
    pub fn new() -> Color {
        ::std::default::Default::default()
    }

    // optional uint32 r = 1;

    pub fn r(&self) -> u32 {
        self.r.unwrap_or(0)
    }

    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: u32) {
        self.r = ::std::option::Option::Some(v);
    }

    // optional uint32 g = 2;

    pub fn g(&self) -> u32 {
        self.g.unwrap_or(0)
    }

    pub fn clear_g(&mut self) {
        self.g = ::std::option::Option::None;
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: u32) {
        self.g = ::std::option::Option::Some(v);
    }

    // optional uint32 b = 3;

    pub fn b(&self) -> u32 {
        self.b.unwrap_or(0)
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: u32) {
        self.b = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "r",
            |m: &Color| { &m.r },
            |m: &mut Color| { &mut m.r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "g",
            |m: &Color| { &m.g },
            |m: &mut Color| { &mut m.g },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b",
            |m: &Color| { &m.b },
            |m: &mut Color| { &mut m.b },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Color>(
            "Color",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Color {
    const NAME: &'static str = "Color";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.r = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.g = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.b = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.g {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.r {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.g {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.b {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Color {
        Color::new()
    }

    fn clear(&mut self) {
        self.r = ::std::option::Option::None;
        self.g = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Color {
        static instance: Color = Color {
            r: ::std::option::Option::None,
            g: ::std::option::Option::None,
            b: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Color {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Color").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Color {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Color {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugText {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugText.color)
    pub color: ::protobuf::MessageField<Color>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugText.virtual_pos)
    pub virtual_pos: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugText.world_pos)
    pub world_pos: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugText.size)
    pub size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugText {
    fn default() -> &'a DebugText {
        <DebugText as ::protobuf::Message>::default_instance()
    }
}

impl DebugText {
    pub fn new() -> DebugText {
        ::std::default::Default::default()
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 size = 5;

    pub fn size(&self) -> u32 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Color>(
            "color",
            |m: &DebugText| { &m.color },
            |m: &mut DebugText| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &DebugText| { &m.text },
            |m: &mut DebugText| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "virtual_pos",
            |m: &DebugText| { &m.virtual_pos },
            |m: &mut DebugText| { &mut m.virtual_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "world_pos",
            |m: &DebugText| { &m.world_pos },
            |m: &mut DebugText| { &mut m.world_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &DebugText| { &m.size },
            |m: &mut DebugText| { &mut m.size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugText>(
            "DebugText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugText {
    const NAME: &'static str = "DebugText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.virtual_pos)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.world_pos)?;
                },
                40 => {
                    self.size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.virtual_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.virtual_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.world_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.size {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugText {
        DebugText::new()
    }

    fn clear(&mut self) {
        self.color.clear();
        self.text = ::std::option::Option::None;
        self.virtual_pos.clear();
        self.world_pos.clear();
        self.size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugText {
        static instance: DebugText = DebugText {
            color: ::protobuf::MessageField::none(),
            text: ::std::option::Option::None,
            virtual_pos: ::protobuf::MessageField::none(),
            world_pos: ::protobuf::MessageField::none(),
            size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugLine)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugLine {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugLine.color)
    pub color: ::protobuf::MessageField<Color>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugLine.line)
    pub line: ::protobuf::MessageField<Line>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugLine.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugLine {
    fn default() -> &'a DebugLine {
        <DebugLine as ::protobuf::Message>::default_instance()
    }
}

impl DebugLine {
    pub fn new() -> DebugLine {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Color>(
            "color",
            |m: &DebugLine| { &m.color },
            |m: &mut DebugLine| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Line>(
            "line",
            |m: &DebugLine| { &m.line },
            |m: &mut DebugLine| { &mut m.line },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugLine>(
            "DebugLine",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugLine {
    const NAME: &'static str = "DebugLine";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.line)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.line.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.line.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugLine {
        DebugLine::new()
    }

    fn clear(&mut self) {
        self.color.clear();
        self.line.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugLine {
        static instance: DebugLine = DebugLine {
            color: ::protobuf::MessageField::none(),
            line: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugLine {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugLine").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugLine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugLine {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugBox {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugBox.color)
    pub color: ::protobuf::MessageField<Color>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugBox.min)
    pub min: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugBox.max)
    pub max: ::protobuf::MessageField<super::common::Point>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugBox {
    fn default() -> &'a DebugBox {
        <DebugBox as ::protobuf::Message>::default_instance()
    }
}

impl DebugBox {
    pub fn new() -> DebugBox {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Color>(
            "color",
            |m: &DebugBox| { &m.color },
            |m: &mut DebugBox| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "min",
            |m: &DebugBox| { &m.min },
            |m: &mut DebugBox| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "max",
            |m: &DebugBox| { &m.max },
            |m: &mut DebugBox| { &mut m.max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugBox>(
            "DebugBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugBox {
    const NAME: &'static str = "DebugBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.min.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.min.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.max.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugBox {
        DebugBox::new()
    }

    fn clear(&mut self) {
        self.color.clear();
        self.min.clear();
        self.max.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugBox {
        static instance: DebugBox = DebugBox {
            color: ::protobuf::MessageField::none(),
            min: ::protobuf::MessageField::none(),
            max: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugSphere)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugSphere {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSphere.color)
    pub color: ::protobuf::MessageField<Color>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSphere.p)
    pub p: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSphere.r)
    pub r: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugSphere.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugSphere {
    fn default() -> &'a DebugSphere {
        <DebugSphere as ::protobuf::Message>::default_instance()
    }
}

impl DebugSphere {
    pub fn new() -> DebugSphere {
        ::std::default::Default::default()
    }

    // optional float r = 3;

    pub fn r(&self) -> f32 {
        self.r.unwrap_or(0.)
    }

    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: f32) {
        self.r = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Color>(
            "color",
            |m: &DebugSphere| { &m.color },
            |m: &mut DebugSphere| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "p",
            |m: &DebugSphere| { &m.p },
            |m: &mut DebugSphere| { &mut m.p },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "r",
            |m: &DebugSphere| { &m.r },
            |m: &mut DebugSphere| { &mut m.r },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugSphere>(
            "DebugSphere",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugSphere {
    const NAME: &'static str = "DebugSphere";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.color)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p)?;
                },
                29 => {
                    self.r = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.p.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.r {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.color.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.p.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.r {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugSphere {
        DebugSphere::new()
    }

    fn clear(&mut self) {
        self.color.clear();
        self.p.clear();
        self.r = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugSphere {
        static instance: DebugSphere = DebugSphere {
            color: ::protobuf::MessageField::none(),
            p: ::protobuf::MessageField::none(),
            r: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugSphere {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugSphere").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugSphere {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSphere {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugCreateUnit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugCreateUnit {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugCreateUnit.unit_type)
    pub unit_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugCreateUnit.owner)
    pub owner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugCreateUnit.pos)
    pub pos: ::protobuf::MessageField<super::common::Point2D>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugCreateUnit.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugCreateUnit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugCreateUnit {
    fn default() -> &'a DebugCreateUnit {
        <DebugCreateUnit as ::protobuf::Message>::default_instance()
    }
}

impl DebugCreateUnit {
    pub fn new() -> DebugCreateUnit {
        ::std::default::Default::default()
    }

    // optional uint32 unit_type = 1;

    pub fn unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }

    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    // optional int32 owner = 2;

    pub fn owner(&self) -> i32 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: i32) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 4;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type",
            |m: &DebugCreateUnit| { &m.unit_type },
            |m: &mut DebugCreateUnit| { &mut m.unit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &DebugCreateUnit| { &m.owner },
            |m: &mut DebugCreateUnit| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point2D>(
            "pos",
            |m: &DebugCreateUnit| { &m.pos },
            |m: &mut DebugCreateUnit| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &DebugCreateUnit| { &m.quantity },
            |m: &mut DebugCreateUnit| { &mut m.quantity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugCreateUnit>(
            "DebugCreateUnit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugCreateUnit {
    const NAME: &'static str = "DebugCreateUnit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.owner = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                32 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.owner {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugCreateUnit {
        DebugCreateUnit::new()
    }

    fn clear(&mut self) {
        self.unit_type = ::std::option::Option::None;
        self.owner = ::std::option::Option::None;
        self.pos.clear();
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugCreateUnit {
        static instance: DebugCreateUnit = DebugCreateUnit {
            unit_type: ::std::option::Option::None,
            owner: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            quantity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugCreateUnit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugCreateUnit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugCreateUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugCreateUnit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugKillUnit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugKillUnit {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugKillUnit.tag)
    pub tag: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugKillUnit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugKillUnit {
    fn default() -> &'a DebugKillUnit {
        <DebugKillUnit as ::protobuf::Message>::default_instance()
    }
}

impl DebugKillUnit {
    pub fn new() -> DebugKillUnit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tag",
            |m: &DebugKillUnit| { &m.tag },
            |m: &mut DebugKillUnit| { &mut m.tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugKillUnit>(
            "DebugKillUnit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugKillUnit {
    const NAME: &'static str = "DebugKillUnit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.tag)?;
                },
                8 => {
                    self.tag.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tag {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tag {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugKillUnit {
        DebugKillUnit::new()
    }

    fn clear(&mut self) {
        self.tag.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugKillUnit {
        static instance: DebugKillUnit = DebugKillUnit {
            tag: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugKillUnit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugKillUnit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugKillUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugKillUnit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugTestProcess)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugTestProcess {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugTestProcess.test)
    pub test: ::std::option::Option<::protobuf::EnumOrUnknown<debug_test_process::Test>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugTestProcess.delay_ms)
    pub delay_ms: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugTestProcess.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugTestProcess {
    fn default() -> &'a DebugTestProcess {
        <DebugTestProcess as ::protobuf::Message>::default_instance()
    }
}

impl DebugTestProcess {
    pub fn new() -> DebugTestProcess {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugTestProcess.Test test = 1;

    pub fn test(&self) -> debug_test_process::Test {
        match self.test {
            Some(e) => e.enum_value_or(debug_test_process::Test::hang),
            None => debug_test_process::Test::hang,
        }
    }

    pub fn clear_test(&mut self) {
        self.test = ::std::option::Option::None;
    }

    pub fn has_test(&self) -> bool {
        self.test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test(&mut self, v: debug_test_process::Test) {
        self.test = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 delay_ms = 2;

    pub fn delay_ms(&self) -> i32 {
        self.delay_ms.unwrap_or(0)
    }

    pub fn clear_delay_ms(&mut self) {
        self.delay_ms = ::std::option::Option::None;
    }

    pub fn has_delay_ms(&self) -> bool {
        self.delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_ms(&mut self, v: i32) {
        self.delay_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "test",
            |m: &DebugTestProcess| { &m.test },
            |m: &mut DebugTestProcess| { &mut m.test },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay_ms",
            |m: &DebugTestProcess| { &m.delay_ms },
            |m: &mut DebugTestProcess| { &mut m.delay_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugTestProcess>(
            "DebugTestProcess",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugTestProcess {
    const NAME: &'static str = "DebugTestProcess";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.test = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.delay_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.test {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.delay_ms {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.test {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.delay_ms {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugTestProcess {
        DebugTestProcess::new()
    }

    fn clear(&mut self) {
        self.test = ::std::option::Option::None;
        self.delay_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugTestProcess {
        static instance: DebugTestProcess = DebugTestProcess {
            test: ::std::option::Option::None,
            delay_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugTestProcess {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugTestProcess").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugTestProcess {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugTestProcess {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DebugTestProcess`
pub mod debug_test_process {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.DebugTestProcess.Test)
    pub enum Test {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugTestProcess.Test.hang)
        hang = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugTestProcess.Test.crash)
        crash = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugTestProcess.Test.exit)
        exit = 3,
    }

    impl ::protobuf::Enum for Test {
        const NAME: &'static str = "Test";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Test> {
            match value {
                1 => ::std::option::Option::Some(Test::hang),
                2 => ::std::option::Option::Some(Test::crash),
                3 => ::std::option::Option::Some(Test::exit),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Test> {
            match str {
                "hang" => ::std::option::Option::Some(Test::hang),
                "crash" => ::std::option::Option::Some(Test::crash),
                "exit" => ::std::option::Option::Some(Test::exit),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Test] = &[
            Test::hang,
            Test::crash,
            Test::exit,
        ];
    }

    impl ::protobuf::EnumFull for Test {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DebugTestProcess.Test").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Test::hang => 0,
                Test::crash => 1,
                Test::exit => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Test {
        fn default() -> Self {
            Test::hang
        }
    }

    impl Test {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Test>("DebugTestProcess.Test")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugSetScore)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugSetScore {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSetScore.score)
    pub score: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugSetScore.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugSetScore {
    fn default() -> &'a DebugSetScore {
        <DebugSetScore as ::protobuf::Message>::default_instance()
    }
}

impl DebugSetScore {
    pub fn new() -> DebugSetScore {
        ::std::default::Default::default()
    }

    // optional float score = 1;

    pub fn score(&self) -> f32 {
        self.score.unwrap_or(0.)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &DebugSetScore| { &m.score },
            |m: &mut DebugSetScore| { &mut m.score },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugSetScore>(
            "DebugSetScore",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugSetScore {
    const NAME: &'static str = "DebugSetScore";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.score = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.score {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugSetScore {
        DebugSetScore::new()
    }

    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugSetScore {
        static instance: DebugSetScore = DebugSetScore {
            score: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugSetScore {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugSetScore").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugSetScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSetScore {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugEndGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugEndGame {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugEndGame.end_result)
    pub end_result: ::std::option::Option<::protobuf::EnumOrUnknown<debug_end_game::EndResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugEndGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugEndGame {
    fn default() -> &'a DebugEndGame {
        <DebugEndGame as ::protobuf::Message>::default_instance()
    }
}

impl DebugEndGame {
    pub fn new() -> DebugEndGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugEndGame.EndResult end_result = 1;

    pub fn end_result(&self) -> debug_end_game::EndResult {
        match self.end_result {
            Some(e) => e.enum_value_or(debug_end_game::EndResult::Surrender),
            None => debug_end_game::EndResult::Surrender,
        }
    }

    pub fn clear_end_result(&mut self) {
        self.end_result = ::std::option::Option::None;
    }

    pub fn has_end_result(&self) -> bool {
        self.end_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_result(&mut self, v: debug_end_game::EndResult) {
        self.end_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_result",
            |m: &DebugEndGame| { &m.end_result },
            |m: &mut DebugEndGame| { &mut m.end_result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugEndGame>(
            "DebugEndGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugEndGame {
    const NAME: &'static str = "DebugEndGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.end_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.end_result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.end_result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugEndGame {
        DebugEndGame::new()
    }

    fn clear(&mut self) {
        self.end_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugEndGame {
        static instance: DebugEndGame = DebugEndGame {
            end_result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugEndGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugEndGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugEndGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugEndGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DebugEndGame`
pub mod debug_end_game {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.DebugEndGame.EndResult)
    pub enum EndResult {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugEndGame.EndResult.Surrender)
        Surrender = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugEndGame.EndResult.DeclareVictory)
        DeclareVictory = 2,
    }

    impl ::protobuf::Enum for EndResult {
        const NAME: &'static str = "EndResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EndResult> {
            match value {
                1 => ::std::option::Option::Some(EndResult::Surrender),
                2 => ::std::option::Option::Some(EndResult::DeclareVictory),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EndResult> {
            match str {
                "Surrender" => ::std::option::Option::Some(EndResult::Surrender),
                "DeclareVictory" => ::std::option::Option::Some(EndResult::DeclareVictory),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EndResult] = &[
            EndResult::Surrender,
            EndResult::DeclareVictory,
        ];
    }

    impl ::protobuf::EnumFull for EndResult {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DebugEndGame.EndResult").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                EndResult::Surrender => 0,
                EndResult::DeclareVictory => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EndResult {
        fn default() -> Self {
            EndResult::Surrender
        }
    }

    impl EndResult {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EndResult>("DebugEndGame.EndResult")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.DebugSetUnitValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DebugSetUnitValue {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSetUnitValue.unit_value)
    pub unit_value: ::std::option::Option<::protobuf::EnumOrUnknown<debug_set_unit_value::UnitValue>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSetUnitValue.value)
    pub value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.DebugSetUnitValue.unit_tag)
    pub unit_tag: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.DebugSetUnitValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DebugSetUnitValue {
    fn default() -> &'a DebugSetUnitValue {
        <DebugSetUnitValue as ::protobuf::Message>::default_instance()
    }
}

impl DebugSetUnitValue {
    pub fn new() -> DebugSetUnitValue {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DebugSetUnitValue.UnitValue unit_value = 1;

    pub fn unit_value(&self) -> debug_set_unit_value::UnitValue {
        match self.unit_value {
            Some(e) => e.enum_value_or(debug_set_unit_value::UnitValue::Energy),
            None => debug_set_unit_value::UnitValue::Energy,
        }
    }

    pub fn clear_unit_value(&mut self) {
        self.unit_value = ::std::option::Option::None;
    }

    pub fn has_unit_value(&self) -> bool {
        self.unit_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_value(&mut self, v: debug_set_unit_value::UnitValue) {
        self.unit_value = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float value = 2;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint64 unit_tag = 3;

    pub fn unit_tag(&self) -> u64 {
        self.unit_tag.unwrap_or(0)
    }

    pub fn clear_unit_tag(&mut self) {
        self.unit_tag = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        self.unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.unit_tag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_value",
            |m: &DebugSetUnitValue| { &m.unit_value },
            |m: &mut DebugSetUnitValue| { &mut m.unit_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &DebugSetUnitValue| { &m.value },
            |m: &mut DebugSetUnitValue| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_tag",
            |m: &DebugSetUnitValue| { &m.unit_tag },
            |m: &mut DebugSetUnitValue| { &mut m.unit_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebugSetUnitValue>(
            "DebugSetUnitValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DebugSetUnitValue {
    const NAME: &'static str = "DebugSetUnitValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_value = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.unit_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_value {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.unit_tag {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_value {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.unit_tag {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DebugSetUnitValue {
        DebugSetUnitValue::new()
    }

    fn clear(&mut self) {
        self.unit_value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unit_tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DebugSetUnitValue {
        static instance: DebugSetUnitValue = DebugSetUnitValue {
            unit_value: ::std::option::Option::None,
            value: ::std::option::Option::None,
            unit_tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DebugSetUnitValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DebugSetUnitValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DebugSetUnitValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugSetUnitValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DebugSetUnitValue`
pub mod debug_set_unit_value {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.DebugSetUnitValue.UnitValue)
    pub enum UnitValue {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugSetUnitValue.UnitValue.Energy)
        Energy = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugSetUnitValue.UnitValue.Life)
        Life = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugSetUnitValue.UnitValue.Shields)
        Shields = 3,
    }

    impl ::protobuf::Enum for UnitValue {
        const NAME: &'static str = "UnitValue";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<UnitValue> {
            match value {
                1 => ::std::option::Option::Some(UnitValue::Energy),
                2 => ::std::option::Option::Some(UnitValue::Life),
                3 => ::std::option::Option::Some(UnitValue::Shields),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<UnitValue> {
            match str {
                "Energy" => ::std::option::Option::Some(UnitValue::Energy),
                "Life" => ::std::option::Option::Some(UnitValue::Life),
                "Shields" => ::std::option::Option::Some(UnitValue::Shields),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [UnitValue] = &[
            UnitValue::Energy,
            UnitValue::Life,
            UnitValue::Shields,
        ];
    }

    impl ::protobuf::EnumFull for UnitValue {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DebugSetUnitValue.UnitValue").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                UnitValue::Energy => 0,
                UnitValue::Life => 1,
                UnitValue::Shields => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for UnitValue {
        fn default() -> Self {
            UnitValue::Energy
        }
    }

    impl UnitValue {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UnitValue>("DebugSetUnitValue.UnitValue")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.DebugGameState)
pub enum DebugGameState {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.show_map)
    show_map = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.control_enemy)
    control_enemy = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.food)
    food = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.free)
    free = 4,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.all_resources)
    all_resources = 5,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.god)
    god = 6,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.minerals)
    minerals = 7,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.gas)
    gas = 8,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.cooldown)
    cooldown = 9,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.tech_tree)
    tech_tree = 10,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.upgrade)
    upgrade = 11,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DebugGameState.fast_build)
    fast_build = 12,
}

impl ::protobuf::Enum for DebugGameState {
    const NAME: &'static str = "DebugGameState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DebugGameState> {
        match value {
            1 => ::std::option::Option::Some(DebugGameState::show_map),
            2 => ::std::option::Option::Some(DebugGameState::control_enemy),
            3 => ::std::option::Option::Some(DebugGameState::food),
            4 => ::std::option::Option::Some(DebugGameState::free),
            5 => ::std::option::Option::Some(DebugGameState::all_resources),
            6 => ::std::option::Option::Some(DebugGameState::god),
            7 => ::std::option::Option::Some(DebugGameState::minerals),
            8 => ::std::option::Option::Some(DebugGameState::gas),
            9 => ::std::option::Option::Some(DebugGameState::cooldown),
            10 => ::std::option::Option::Some(DebugGameState::tech_tree),
            11 => ::std::option::Option::Some(DebugGameState::upgrade),
            12 => ::std::option::Option::Some(DebugGameState::fast_build),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DebugGameState> {
        match str {
            "show_map" => ::std::option::Option::Some(DebugGameState::show_map),
            "control_enemy" => ::std::option::Option::Some(DebugGameState::control_enemy),
            "food" => ::std::option::Option::Some(DebugGameState::food),
            "free" => ::std::option::Option::Some(DebugGameState::free),
            "all_resources" => ::std::option::Option::Some(DebugGameState::all_resources),
            "god" => ::std::option::Option::Some(DebugGameState::god),
            "minerals" => ::std::option::Option::Some(DebugGameState::minerals),
            "gas" => ::std::option::Option::Some(DebugGameState::gas),
            "cooldown" => ::std::option::Option::Some(DebugGameState::cooldown),
            "tech_tree" => ::std::option::Option::Some(DebugGameState::tech_tree),
            "upgrade" => ::std::option::Option::Some(DebugGameState::upgrade),
            "fast_build" => ::std::option::Option::Some(DebugGameState::fast_build),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DebugGameState] = &[
        DebugGameState::show_map,
        DebugGameState::control_enemy,
        DebugGameState::food,
        DebugGameState::free,
        DebugGameState::all_resources,
        DebugGameState::god,
        DebugGameState::minerals,
        DebugGameState::gas,
        DebugGameState::cooldown,
        DebugGameState::tech_tree,
        DebugGameState::upgrade,
        DebugGameState::fast_build,
    ];
}

impl ::protobuf::EnumFull for DebugGameState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DebugGameState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DebugGameState::show_map => 0,
            DebugGameState::control_enemy => 1,
            DebugGameState::food => 2,
            DebugGameState::free => 3,
            DebugGameState::all_resources => 4,
            DebugGameState::god => 5,
            DebugGameState::minerals => 6,
            DebugGameState::gas => 7,
            DebugGameState::cooldown => 8,
            DebugGameState::tech_tree => 9,
            DebugGameState::upgrade => 10,
            DebugGameState::fast_build => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DebugGameState {
    fn default() -> Self {
        DebugGameState::show_map
    }
}

impl DebugGameState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DebugGameState>("DebugGameState")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cs2clientprotocol/debug.proto\x12\x0eSC2APIProtocol\x1a\x1ds2client\
    protocol/common.proto\"\x8a\x04\n\x0cDebugCommand\x12/\n\x04draw\x18\x01\
    \x20\x01(\x0b2\x19.SC2APIProtocol.DebugDrawH\0R\x04draw\x12?\n\ngame_sta\
    te\x18\x02\x20\x01(\x0e2\x1e.SC2APIProtocol.DebugGameStateH\0R\tgameStat\
    e\x12B\n\x0bcreate_unit\x18\x03\x20\x01(\x0b2\x1f.SC2APIProtocol.DebugCr\
    eateUnitH\0R\ncreateUnit\x12<\n\tkill_unit\x18\x04\x20\x01(\x0b2\x1d.SC2\
    APIProtocol.DebugKillUnitH\0R\x08killUnit\x12E\n\x0ctest_process\x18\x05\
    \x20\x01(\x0b2\x20.SC2APIProtocol.DebugTestProcessH\0R\x0btestProcess\
    \x125\n\x05score\x18\x06\x20\x01(\x0b2\x1d.SC2APIProtocol.DebugSetScoreH\
    \0R\x05score\x129\n\x08end_game\x18\x07\x20\x01(\x0b2\x1c.SC2APIProtocol\
    .DebugEndGameH\0R\x07endGame\x12B\n\nunit_value\x18\x08\x20\x01(\x0b2!.S\
    C2APIProtocol.DebugSetUnitValueH\0R\tunitValueB\t\n\x07command\"\xd2\x01\
    \n\tDebugDraw\x12-\n\x04text\x18\x01\x20\x03(\x0b2\x19.SC2APIProtocol.De\
    bugTextR\x04text\x12/\n\x05lines\x18\x02\x20\x03(\x0b2\x19.SC2APIProtoco\
    l.DebugLineR\x05lines\x12.\n\x05boxes\x18\x03\x20\x03(\x0b2\x18.SC2APIPr\
    otocol.DebugBoxR\x05boxes\x125\n\x07spheres\x18\x04\x20\x03(\x0b2\x1b.SC\
    2APIProtocol.DebugSphereR\x07spheres\"T\n\x04Line\x12%\n\x02p0\x18\x01\
    \x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x02p0\x12%\n\x02p1\x18\x02\x20\
    \x01(\x0b2\x15.SC2APIProtocol.PointR\x02p1\"1\n\x05Color\x12\x0c\n\x01r\
    \x18\x01\x20\x01(\rR\x01r\x12\x0c\n\x01g\x18\x02\x20\x01(\rR\x01g\x12\
    \x0c\n\x01b\x18\x03\x20\x01(\rR\x01b\"\xcc\x01\n\tDebugText\x12+\n\x05co\
    lor\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol.ColorR\x05color\x12\x12\n\
    \x04text\x18\x02\x20\x01(\tR\x04text\x126\n\x0bvirtual_pos\x18\x03\x20\
    \x01(\x0b2\x15.SC2APIProtocol.PointR\nvirtualPos\x122\n\tworld_pos\x18\
    \x04\x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x08worldPos\x12\x12\n\x04si\
    ze\x18\x05\x20\x01(\rR\x04size\"b\n\tDebugLine\x12+\n\x05color\x18\x01\
    \x20\x01(\x0b2\x15.SC2APIProtocol.ColorR\x05color\x12(\n\x04line\x18\x02\
    \x20\x01(\x0b2\x14.SC2APIProtocol.LineR\x04line\"\x89\x01\n\x08DebugBox\
    \x12+\n\x05color\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol.ColorR\x05colo\
    r\x12'\n\x03min\x18\x02\x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x03min\
    \x12'\n\x03max\x18\x03\x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x03max\"m\
    \n\x0bDebugSphere\x12+\n\x05color\x18\x01\x20\x01(\x0b2\x15.SC2APIProtoc\
    ol.ColorR\x05color\x12#\n\x01p\x18\x02\x20\x01(\x0b2\x15.SC2APIProtocol.\
    PointR\x01p\x12\x0c\n\x01r\x18\x03\x20\x01(\x02R\x01r\"\x8b\x01\n\x0fDeb\
    ugCreateUnit\x12\x1b\n\tunit_type\x18\x01\x20\x01(\rR\x08unitType\x12\
    \x14\n\x05owner\x18\x02\x20\x01(\x05R\x05owner\x12)\n\x03pos\x18\x03\x20\
    \x01(\x0b2\x17.SC2APIProtocol.Point2DR\x03pos\x12\x1a\n\x08quantity\x18\
    \x04\x20\x01(\rR\x08quantity\"!\n\rDebugKillUnit\x12\x10\n\x03tag\x18\
    \x01\x20\x03(\x04R\x03tag\"\x8f\x01\n\x10DebugTestProcess\x129\n\x04test\
    \x18\x01\x20\x01(\x0e2%.SC2APIProtocol.DebugTestProcess.TestR\x04test\
    \x12\x19\n\x08delay_ms\x18\x02\x20\x01(\x05R\x07delayMs\"%\n\x04Test\x12\
    \x08\n\x04hang\x10\x01\x12\t\n\x05crash\x10\x02\x12\x08\n\x04exit\x10\
    \x03\"%\n\rDebugSetScore\x12\x14\n\x05score\x18\x01\x20\x01(\x02R\x05sco\
    re\"\x85\x01\n\x0cDebugEndGame\x12E\n\nend_result\x18\x01\x20\x01(\x0e2&\
    .SC2APIProtocol.DebugEndGame.EndResultR\tendResult\".\n\tEndResult\x12\r\
    \n\tSurrender\x10\x01\x12\x12\n\x0eDeclareVictory\x10\x02\"\xc0\x01\n\
    \x11DebugSetUnitValue\x12J\n\nunit_value\x18\x01\x20\x01(\x0e2+.SC2APIPr\
    otocol.DebugSetUnitValue.UnitValueR\tunitValue\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x02R\x05value\x12\x19\n\x08unit_tag\x18\x03\x20\x01(\x04R\
    \x07unitTag\".\n\tUnitValue\x12\n\n\x06Energy\x10\x01\x12\x08\n\x04Life\
    \x10\x02\x12\x0b\n\x07Shields\x10\x03*\xb2\x01\n\x0eDebugGameState\x12\
    \x0c\n\x08show_map\x10\x01\x12\x11\n\rcontrol_enemy\x10\x02\x12\x08\n\
    \x04food\x10\x03\x12\x08\n\x04free\x10\x04\x12\x11\n\rall_resources\x10\
    \x05\x12\x07\n\x03god\x10\x06\x12\x0c\n\x08minerals\x10\x07\x12\x07\n\
    \x03gas\x10\x08\x12\x0c\n\x08cooldown\x10\t\x12\r\n\ttech_tree\x10\n\x12\
    \x0b\n\x07upgrade\x10\x0b\x12\x0e\n\nfast_build\x10\x0c\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(14);
            messages.push(DebugCommand::generated_message_descriptor_data());
            messages.push(DebugDraw::generated_message_descriptor_data());
            messages.push(Line::generated_message_descriptor_data());
            messages.push(Color::generated_message_descriptor_data());
            messages.push(DebugText::generated_message_descriptor_data());
            messages.push(DebugLine::generated_message_descriptor_data());
            messages.push(DebugBox::generated_message_descriptor_data());
            messages.push(DebugSphere::generated_message_descriptor_data());
            messages.push(DebugCreateUnit::generated_message_descriptor_data());
            messages.push(DebugKillUnit::generated_message_descriptor_data());
            messages.push(DebugTestProcess::generated_message_descriptor_data());
            messages.push(DebugSetScore::generated_message_descriptor_data());
            messages.push(DebugEndGame::generated_message_descriptor_data());
            messages.push(DebugSetUnitValue::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(DebugGameState::generated_enum_descriptor_data());
            enums.push(debug_test_process::Test::generated_enum_descriptor_data());
            enums.push(debug_end_game::EndResult::generated_enum_descriptor_data());
            enums.push(debug_set_unit_value::UnitValue::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

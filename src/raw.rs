// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/raw.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.StartRaw)
pub struct StartRaw {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.StartRaw.map_size)
    pub map_size: ::protobuf::MessageField<super::common::Size2DI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.StartRaw.pathing_grid)
    pub pathing_grid: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.StartRaw.terrain_height)
    pub terrain_height: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.StartRaw.placement_grid)
    pub placement_grid: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.StartRaw.playable_area)
    pub playable_area: ::protobuf::MessageField<super::common::RectangleI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.StartRaw.start_locations)
    pub start_locations: ::std::vec::Vec<super::common::Point2D>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.StartRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartRaw {
    fn default() -> &'a StartRaw {
        <StartRaw as ::protobuf::Message>::default_instance()
    }
}

impl StartRaw {
    pub fn new() -> StartRaw {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Size2DI>(
            "map_size",
            |m: &StartRaw| { &m.map_size },
            |m: &mut StartRaw| { &mut m.map_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "pathing_grid",
            |m: &StartRaw| { &m.pathing_grid },
            |m: &mut StartRaw| { &mut m.pathing_grid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "terrain_height",
            |m: &StartRaw| { &m.terrain_height },
            |m: &mut StartRaw| { &mut m.terrain_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "placement_grid",
            |m: &StartRaw| { &m.placement_grid },
            |m: &mut StartRaw| { &mut m.placement_grid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::RectangleI>(
            "playable_area",
            |m: &StartRaw| { &m.playable_area },
            |m: &mut StartRaw| { &mut m.playable_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "start_locations",
            |m: &StartRaw| { &m.start_locations },
            |m: &mut StartRaw| { &mut m.start_locations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartRaw>(
            "StartRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartRaw {
    const NAME: &'static str = "StartRaw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.map_size)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pathing_grid)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.terrain_height)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.placement_grid)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.playable_area)?;
                },
                50 => {
                    self.start_locations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pathing_grid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.terrain_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.placement_grid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playable_area.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.start_locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_size.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.pathing_grid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.terrain_height.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.placement_grid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.playable_area.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.start_locations {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartRaw {
        StartRaw::new()
    }

    fn clear(&mut self) {
        self.map_size.clear();
        self.pathing_grid.clear();
        self.terrain_height.clear();
        self.placement_grid.clear();
        self.playable_area.clear();
        self.start_locations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartRaw {
        static instance: StartRaw = StartRaw {
            map_size: ::protobuf::MessageField::none(),
            pathing_grid: ::protobuf::MessageField::none(),
            terrain_height: ::protobuf::MessageField::none(),
            placement_grid: ::protobuf::MessageField::none(),
            playable_area: ::protobuf::MessageField::none(),
            start_locations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ObservationRaw)
pub struct ObservationRaw {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRaw.player)
    pub player: ::protobuf::MessageField<PlayerRaw>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRaw.units)
    pub units: ::std::vec::Vec<Unit>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRaw.map_state)
    pub map_state: ::protobuf::MessageField<MapState>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRaw.event)
    pub event: ::protobuf::MessageField<Event>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRaw.effects)
    pub effects: ::std::vec::Vec<Effect>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationRaw.radar)
    pub radar: ::std::vec::Vec<RadarRing>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ObservationRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObservationRaw {
    fn default() -> &'a ObservationRaw {
        <ObservationRaw as ::protobuf::Message>::default_instance()
    }
}

impl ObservationRaw {
    pub fn new() -> ObservationRaw {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerRaw>(
            "player",
            |m: &ObservationRaw| { &m.player },
            |m: &mut ObservationRaw| { &mut m.player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "units",
            |m: &ObservationRaw| { &m.units },
            |m: &mut ObservationRaw| { &mut m.units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapState>(
            "map_state",
            |m: &ObservationRaw| { &m.map_state },
            |m: &mut ObservationRaw| { &mut m.map_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Event>(
            "event",
            |m: &ObservationRaw| { &m.event },
            |m: &mut ObservationRaw| { &mut m.event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &ObservationRaw| { &m.effects },
            |m: &mut ObservationRaw| { &mut m.effects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "radar",
            |m: &ObservationRaw| { &m.radar },
            |m: &mut ObservationRaw| { &mut m.radar },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObservationRaw>(
            "ObservationRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObservationRaw {
    const NAME: &'static str = "ObservationRaw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player)?;
                },
                18 => {
                    self.units.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.map_state)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event)?;
                },
                42 => {
                    self.effects.push(is.read_message()?);
                },
                50 => {
                    self.radar.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.units {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.map_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.radar {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.units {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.map_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.effects {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.radar {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObservationRaw {
        ObservationRaw::new()
    }

    fn clear(&mut self) {
        self.player.clear();
        self.units.clear();
        self.map_state.clear();
        self.event.clear();
        self.effects.clear();
        self.radar.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObservationRaw {
        static instance: ObservationRaw = ObservationRaw {
            player: ::protobuf::MessageField::none(),
            units: ::std::vec::Vec::new(),
            map_state: ::protobuf::MessageField::none(),
            event: ::protobuf::MessageField::none(),
            effects: ::std::vec::Vec::new(),
            radar: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObservationRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObservationRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObservationRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.RadarRing)
pub struct RadarRing {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RadarRing.pos)
    pub pos: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RadarRing.radius)
    pub radius: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RadarRing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RadarRing {
    fn default() -> &'a RadarRing {
        <RadarRing as ::protobuf::Message>::default_instance()
    }
}

impl RadarRing {
    pub fn new() -> RadarRing {
        ::std::default::Default::default()
    }

    // optional float radius = 2;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "pos",
            |m: &RadarRing| { &m.pos },
            |m: &mut RadarRing| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &RadarRing| { &m.radius },
            |m: &mut RadarRing| { &mut m.radius },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RadarRing>(
            "RadarRing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RadarRing {
    const NAME: &'static str = "RadarRing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                21 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.radius {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RadarRing {
        RadarRing::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.radius = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RadarRing {
        static instance: RadarRing = RadarRing {
            pos: ::protobuf::MessageField::none(),
            radius: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RadarRing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RadarRing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RadarRing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RadarRing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.PowerSource)
pub struct PowerSource {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PowerSource.pos)
    pub pos: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PowerSource.radius)
    pub radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PowerSource.tag)
    pub tag: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PowerSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PowerSource {
    fn default() -> &'a PowerSource {
        <PowerSource as ::protobuf::Message>::default_instance()
    }
}

impl PowerSource {
    pub fn new() -> PowerSource {
        ::std::default::Default::default()
    }

    // optional float radius = 2;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional uint64 tag = 3;

    pub fn tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "pos",
            |m: &PowerSource| { &m.pos },
            |m: &mut PowerSource| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &PowerSource| { &m.radius },
            |m: &mut PowerSource| { &mut m.radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &PowerSource| { &m.tag },
            |m: &mut PowerSource| { &mut m.tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PowerSource>(
            "PowerSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PowerSource {
    const NAME: &'static str = "PowerSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                21 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.radius {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.tag {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PowerSource {
        PowerSource::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.radius = ::std::option::Option::None;
        self.tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PowerSource {
        static instance: PowerSource = PowerSource {
            pos: ::protobuf::MessageField::none(),
            radius: ::std::option::Option::None,
            tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PowerSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PowerSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PowerSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PowerSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.PlayerRaw)
pub struct PlayerRaw {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerRaw.power_sources)
    pub power_sources: ::std::vec::Vec<PowerSource>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerRaw.camera)
    pub camera: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerRaw.upgrade_ids)
    pub upgrade_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PlayerRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerRaw {
    fn default() -> &'a PlayerRaw {
        <PlayerRaw as ::protobuf::Message>::default_instance()
    }
}

impl PlayerRaw {
    pub fn new() -> PlayerRaw {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "power_sources",
            |m: &PlayerRaw| { &m.power_sources },
            |m: &mut PlayerRaw| { &mut m.power_sources },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "camera",
            |m: &PlayerRaw| { &m.camera },
            |m: &mut PlayerRaw| { &mut m.camera },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "upgrade_ids",
            |m: &PlayerRaw| { &m.upgrade_ids },
            |m: &mut PlayerRaw| { &mut m.upgrade_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerRaw>(
            "PlayerRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerRaw {
    const NAME: &'static str = "PlayerRaw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.power_sources.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.camera)?;
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.upgrade_ids)?;
                },
                24 => {
                    self.upgrade_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.power_sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.camera.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.upgrade_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.power_sources {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.camera.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.upgrade_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerRaw {
        PlayerRaw::new()
    }

    fn clear(&mut self) {
        self.power_sources.clear();
        self.camera.clear();
        self.upgrade_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerRaw {
        static instance: PlayerRaw = PlayerRaw {
            power_sources: ::std::vec::Vec::new(),
            camera: ::protobuf::MessageField::none(),
            upgrade_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.UnitOrder)
pub struct UnitOrder {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitOrder.ability_id)
    pub ability_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitOrder.progress)
    pub progress: ::std::option::Option<f32>,
    // message oneof groups
    pub target: ::std::option::Option<unit_order::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.UnitOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitOrder {
    fn default() -> &'a UnitOrder {
        <UnitOrder as ::protobuf::Message>::default_instance()
    }
}

impl UnitOrder {
    pub fn new() -> UnitOrder {
        ::std::default::Default::default()
    }

    // optional uint32 ability_id = 1;

    pub fn ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Point target_world_space_pos = 2;

    pub fn target_world_space_pos(&self) -> &super::common::Point {
        match self.target {
            ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(ref v)) => v,
            _ => <super::common::Point as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_world_space_pos(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_world_space_pos(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_world_space_pos(&mut self, v: super::common::Point) {
        self.target = ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_world_space_pos(&mut self) -> &mut super::common::Point {
        if let ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(super::common::Point::new()));
        }
        match self.target {
            ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_world_space_pos(&mut self) -> super::common::Point {
        if self.has_target_world_space_pos() {
            match self.target.take() {
                ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::Point::new()
        }
    }

    // optional uint64 target_unit_tag = 3;

    pub fn target_unit_tag(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(unit_order::Target::TargetUnitTag(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_target_unit_tag(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_unit_tag(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(unit_order::Target::TargetUnitTag(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_unit_tag(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(unit_order::Target::TargetUnitTag(v))
    }

    // optional float progress = 4;

    pub fn progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &UnitOrder| { &m.ability_id },
            |m: &mut UnitOrder| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::common::Point>(
            "target_world_space_pos",
            UnitOrder::has_target_world_space_pos,
            UnitOrder::target_world_space_pos,
            UnitOrder::mut_target_world_space_pos,
            UnitOrder::set_target_world_space_pos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "target_unit_tag",
            UnitOrder::has_target_unit_tag,
            UnitOrder::target_unit_tag,
            UnitOrder::set_target_unit_tag,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &UnitOrder| { &m.progress },
            |m: &mut UnitOrder| { &mut m.progress },
        ));
        oneofs.push(unit_order::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitOrder>(
            "UnitOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitOrder {
    const NAME: &'static str = "UnitOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.target = ::std::option::Option::Some(unit_order::Target::TargetWorldSpacePos(is.read_message()?));
                },
                24 => {
                    self.target = ::std::option::Option::Some(unit_order::Target::TargetUnitTag(is.read_uint64()?));
                },
                37 => {
                    self.progress = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.progress {
            my_size += 1 + 4;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &unit_order::Target::TargetWorldSpacePos(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &unit_order::Target::TargetUnitTag(v) => {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_float(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &unit_order::Target::TargetWorldSpacePos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &unit_order::Target::TargetUnitTag(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitOrder {
        UnitOrder::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitOrder {
        static instance: UnitOrder = UnitOrder {
            ability_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UnitOrder`
pub mod unit_order {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.UnitOrder.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.UnitOrder.target_world_space_pos)
        TargetWorldSpacePos(super::super::common::Point),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.UnitOrder.target_unit_tag)
        TargetUnitTag(u64),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::UnitOrder as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.PassengerUnit)
pub struct PassengerUnit {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.tag)
    pub tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.health)
    pub health: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.health_max)
    pub health_max: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.shield)
    pub shield: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.shield_max)
    pub shield_max: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.energy)
    pub energy: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.energy_max)
    pub energy_max: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PassengerUnit.unit_type)
    pub unit_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PassengerUnit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PassengerUnit {
    fn default() -> &'a PassengerUnit {
        <PassengerUnit as ::protobuf::Message>::default_instance()
    }
}

impl PassengerUnit {
    pub fn new() -> PassengerUnit {
        ::std::default::Default::default()
    }

    // optional uint64 tag = 1;

    pub fn tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional float health = 2;

    pub fn health(&self) -> f32 {
        self.health.unwrap_or(0.)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: f32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional float health_max = 3;

    pub fn health_max(&self) -> f32 {
        self.health_max.unwrap_or(0.)
    }

    pub fn clear_health_max(&mut self) {
        self.health_max = ::std::option::Option::None;
    }

    pub fn has_health_max(&self) -> bool {
        self.health_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_max(&mut self, v: f32) {
        self.health_max = ::std::option::Option::Some(v);
    }

    // optional float shield = 4;

    pub fn shield(&self) -> f32 {
        self.shield.unwrap_or(0.)
    }

    pub fn clear_shield(&mut self) {
        self.shield = ::std::option::Option::None;
    }

    pub fn has_shield(&self) -> bool {
        self.shield.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield(&mut self, v: f32) {
        self.shield = ::std::option::Option::Some(v);
    }

    // optional float shield_max = 7;

    pub fn shield_max(&self) -> f32 {
        self.shield_max.unwrap_or(0.)
    }

    pub fn clear_shield_max(&mut self) {
        self.shield_max = ::std::option::Option::None;
    }

    pub fn has_shield_max(&self) -> bool {
        self.shield_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_max(&mut self, v: f32) {
        self.shield_max = ::std::option::Option::Some(v);
    }

    // optional float energy = 5;

    pub fn energy(&self) -> f32 {
        self.energy.unwrap_or(0.)
    }

    pub fn clear_energy(&mut self) {
        self.energy = ::std::option::Option::None;
    }

    pub fn has_energy(&self) -> bool {
        self.energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: f32) {
        self.energy = ::std::option::Option::Some(v);
    }

    // optional float energy_max = 8;

    pub fn energy_max(&self) -> f32 {
        self.energy_max.unwrap_or(0.)
    }

    pub fn clear_energy_max(&mut self) {
        self.energy_max = ::std::option::Option::None;
    }

    pub fn has_energy_max(&self) -> bool {
        self.energy_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy_max(&mut self, v: f32) {
        self.energy_max = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_type = 6;

    pub fn unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }

    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &PassengerUnit| { &m.tag },
            |m: &mut PassengerUnit| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health",
            |m: &PassengerUnit| { &m.health },
            |m: &mut PassengerUnit| { &mut m.health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health_max",
            |m: &PassengerUnit| { &m.health_max },
            |m: &mut PassengerUnit| { &mut m.health_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield",
            |m: &PassengerUnit| { &m.shield },
            |m: &mut PassengerUnit| { &mut m.shield },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield_max",
            |m: &PassengerUnit| { &m.shield_max },
            |m: &mut PassengerUnit| { &mut m.shield_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "energy",
            |m: &PassengerUnit| { &m.energy },
            |m: &mut PassengerUnit| { &mut m.energy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "energy_max",
            |m: &PassengerUnit| { &m.energy_max },
            |m: &mut PassengerUnit| { &mut m.energy_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type",
            |m: &PassengerUnit| { &m.unit_type },
            |m: &mut PassengerUnit| { &mut m.unit_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PassengerUnit>(
            "PassengerUnit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PassengerUnit {
    const NAME: &'static str = "PassengerUnit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.health = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.health_max = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.shield = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.shield_max = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.energy = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.energy_max = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.unit_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.health {
            my_size += 1 + 4;
        }
        if let Some(v) = self.health_max {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shield {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shield_max {
            my_size += 1 + 4;
        }
        if let Some(v) = self.energy {
            my_size += 1 + 4;
        }
        if let Some(v) = self.energy_max {
            my_size += 1 + 4;
        }
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tag {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.health {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.health_max {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.shield {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.shield_max {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.energy {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.energy_max {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.unit_type {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PassengerUnit {
        PassengerUnit::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.health_max = ::std::option::Option::None;
        self.shield = ::std::option::Option::None;
        self.shield_max = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.energy_max = ::std::option::Option::None;
        self.unit_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PassengerUnit {
        static instance: PassengerUnit = PassengerUnit {
            tag: ::std::option::Option::None,
            health: ::std::option::Option::None,
            health_max: ::std::option::Option::None,
            shield: ::std::option::Option::None,
            shield_max: ::std::option::Option::None,
            energy: ::std::option::Option::None,
            energy_max: ::std::option::Option::None,
            unit_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PassengerUnit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PassengerUnit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PassengerUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassengerUnit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.RallyTarget)
pub struct RallyTarget {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RallyTarget.point)
    pub point: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RallyTarget.tag)
    pub tag: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RallyTarget.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RallyTarget {
    fn default() -> &'a RallyTarget {
        <RallyTarget as ::protobuf::Message>::default_instance()
    }
}

impl RallyTarget {
    pub fn new() -> RallyTarget {
        ::std::default::Default::default()
    }

    // optional uint64 tag = 2;

    pub fn tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "point",
            |m: &RallyTarget| { &m.point },
            |m: &mut RallyTarget| { &mut m.point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &RallyTarget| { &m.tag },
            |m: &mut RallyTarget| { &mut m.tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RallyTarget>(
            "RallyTarget",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RallyTarget {
    const NAME: &'static str = "RallyTarget";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.point)?;
                },
                16 => {
                    self.tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tag {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RallyTarget {
        RallyTarget::new()
    }

    fn clear(&mut self) {
        self.point.clear();
        self.tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RallyTarget {
        static instance: RallyTarget = RallyTarget {
            point: ::protobuf::MessageField::none(),
            tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RallyTarget {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RallyTarget").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RallyTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RallyTarget {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.Unit)
pub struct Unit {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.display_type)
    pub display_type: ::std::option::Option<::protobuf::EnumOrUnknown<DisplayType>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.alliance)
    pub alliance: ::std::option::Option<::protobuf::EnumOrUnknown<Alliance>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.tag)
    pub tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.unit_type)
    pub unit_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.owner)
    pub owner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.pos)
    pub pos: ::protobuf::MessageField<super::common::Point>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.facing)
    pub facing: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.radius)
    pub radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.build_progress)
    pub build_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.cloak)
    pub cloak: ::std::option::Option<::protobuf::EnumOrUnknown<CloakState>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.buff_ids)
    pub buff_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.detect_range)
    pub detect_range: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.radar_range)
    pub radar_range: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_selected)
    pub is_selected: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_on_screen)
    pub is_on_screen: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_blip)
    pub is_blip: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_powered)
    pub is_powered: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_active)
    pub is_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.attack_upgrade_level)
    pub attack_upgrade_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.armor_upgrade_level)
    pub armor_upgrade_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.shield_upgrade_level)
    pub shield_upgrade_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.health)
    pub health: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.health_max)
    pub health_max: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.shield)
    pub shield: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.shield_max)
    pub shield_max: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.energy)
    pub energy: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.energy_max)
    pub energy_max: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.mineral_contents)
    pub mineral_contents: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.vespene_contents)
    pub vespene_contents: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_flying)
    pub is_flying: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_burrowed)
    pub is_burrowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.is_hallucination)
    pub is_hallucination: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.orders)
    pub orders: ::std::vec::Vec<UnitOrder>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.add_on_tag)
    pub add_on_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.passengers)
    pub passengers: ::std::vec::Vec<PassengerUnit>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.cargo_space_taken)
    pub cargo_space_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.cargo_space_max)
    pub cargo_space_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.assigned_harvesters)
    pub assigned_harvesters: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.ideal_harvesters)
    pub ideal_harvesters: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.weapon_cooldown)
    pub weapon_cooldown: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.engaged_target_tag)
    pub engaged_target_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.buff_duration_remain)
    pub buff_duration_remain: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.buff_duration_max)
    pub buff_duration_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Unit.rally_targets)
    pub rally_targets: ::std::vec::Vec<RallyTarget>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Unit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Unit {
    fn default() -> &'a Unit {
        <Unit as ::protobuf::Message>::default_instance()
    }
}

impl Unit {
    pub fn new() -> Unit {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.DisplayType display_type = 1;

    pub fn display_type(&self) -> DisplayType {
        match self.display_type {
            Some(e) => e.enum_value_or(DisplayType::Visible),
            None => DisplayType::Visible,
        }
    }

    pub fn clear_display_type(&mut self) {
        self.display_type = ::std::option::Option::None;
    }

    pub fn has_display_type(&self) -> bool {
        self.display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_type(&mut self, v: DisplayType) {
        self.display_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.Alliance alliance = 2;

    pub fn alliance(&self) -> Alliance {
        match self.alliance {
            Some(e) => e.enum_value_or(Alliance::Self_),
            None => Alliance::Self_,
        }
    }

    pub fn clear_alliance(&mut self) {
        self.alliance = ::std::option::Option::None;
    }

    pub fn has_alliance(&self) -> bool {
        self.alliance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alliance(&mut self, v: Alliance) {
        self.alliance = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 tag = 3;

    pub fn tag(&self) -> u64 {
        self.tag.unwrap_or(0)
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: u64) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional uint32 unit_type = 4;

    pub fn unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }

    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    // optional int32 owner = 5;

    pub fn owner(&self) -> i32 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: i32) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional float facing = 7;

    pub fn facing(&self) -> f32 {
        self.facing.unwrap_or(0.)
    }

    pub fn clear_facing(&mut self) {
        self.facing = ::std::option::Option::None;
    }

    pub fn has_facing(&self) -> bool {
        self.facing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facing(&mut self, v: f32) {
        self.facing = ::std::option::Option::Some(v);
    }

    // optional float radius = 8;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional float build_progress = 9;

    pub fn build_progress(&self) -> f32 {
        self.build_progress.unwrap_or(0.)
    }

    pub fn clear_build_progress(&mut self) {
        self.build_progress = ::std::option::Option::None;
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: f32) {
        self.build_progress = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.CloakState cloak = 10;

    pub fn cloak(&self) -> CloakState {
        match self.cloak {
            Some(e) => e.enum_value_or(CloakState::CloakedUnknown),
            None => CloakState::CloakedUnknown,
        }
    }

    pub fn clear_cloak(&mut self) {
        self.cloak = ::std::option::Option::None;
    }

    pub fn has_cloak(&self) -> bool {
        self.cloak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloak(&mut self, v: CloakState) {
        self.cloak = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float detect_range = 31;

    pub fn detect_range(&self) -> f32 {
        self.detect_range.unwrap_or(0.)
    }

    pub fn clear_detect_range(&mut self) {
        self.detect_range = ::std::option::Option::None;
    }

    pub fn has_detect_range(&self) -> bool {
        self.detect_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detect_range(&mut self, v: f32) {
        self.detect_range = ::std::option::Option::Some(v);
    }

    // optional float radar_range = 32;

    pub fn radar_range(&self) -> f32 {
        self.radar_range.unwrap_or(0.)
    }

    pub fn clear_radar_range(&mut self) {
        self.radar_range = ::std::option::Option::None;
    }

    pub fn has_radar_range(&self) -> bool {
        self.radar_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radar_range(&mut self, v: f32) {
        self.radar_range = ::std::option::Option::Some(v);
    }

    // optional bool is_selected = 11;

    pub fn is_selected(&self) -> bool {
        self.is_selected.unwrap_or(false)
    }

    pub fn clear_is_selected(&mut self) {
        self.is_selected = ::std::option::Option::None;
    }

    pub fn has_is_selected(&self) -> bool {
        self.is_selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_selected(&mut self, v: bool) {
        self.is_selected = ::std::option::Option::Some(v);
    }

    // optional bool is_on_screen = 12;

    pub fn is_on_screen(&self) -> bool {
        self.is_on_screen.unwrap_or(false)
    }

    pub fn clear_is_on_screen(&mut self) {
        self.is_on_screen = ::std::option::Option::None;
    }

    pub fn has_is_on_screen(&self) -> bool {
        self.is_on_screen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_on_screen(&mut self, v: bool) {
        self.is_on_screen = ::std::option::Option::Some(v);
    }

    // optional bool is_blip = 13;

    pub fn is_blip(&self) -> bool {
        self.is_blip.unwrap_or(false)
    }

    pub fn clear_is_blip(&mut self) {
        self.is_blip = ::std::option::Option::None;
    }

    pub fn has_is_blip(&self) -> bool {
        self.is_blip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_blip(&mut self, v: bool) {
        self.is_blip = ::std::option::Option::Some(v);
    }

    // optional bool is_powered = 35;

    pub fn is_powered(&self) -> bool {
        self.is_powered.unwrap_or(false)
    }

    pub fn clear_is_powered(&mut self) {
        self.is_powered = ::std::option::Option::None;
    }

    pub fn has_is_powered(&self) -> bool {
        self.is_powered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_powered(&mut self, v: bool) {
        self.is_powered = ::std::option::Option::Some(v);
    }

    // optional bool is_active = 39;

    pub fn is_active(&self) -> bool {
        self.is_active.unwrap_or(false)
    }

    pub fn clear_is_active(&mut self) {
        self.is_active = ::std::option::Option::None;
    }

    pub fn has_is_active(&self) -> bool {
        self.is_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = ::std::option::Option::Some(v);
    }

    // optional int32 attack_upgrade_level = 40;

    pub fn attack_upgrade_level(&self) -> i32 {
        self.attack_upgrade_level.unwrap_or(0)
    }

    pub fn clear_attack_upgrade_level(&mut self) {
        self.attack_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_attack_upgrade_level(&self) -> bool {
        self.attack_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_upgrade_level(&mut self, v: i32) {
        self.attack_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 armor_upgrade_level = 41;

    pub fn armor_upgrade_level(&self) -> i32 {
        self.armor_upgrade_level.unwrap_or(0)
    }

    pub fn clear_armor_upgrade_level(&mut self) {
        self.armor_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_armor_upgrade_level(&self) -> bool {
        self.armor_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_upgrade_level(&mut self, v: i32) {
        self.armor_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 shield_upgrade_level = 42;

    pub fn shield_upgrade_level(&self) -> i32 {
        self.shield_upgrade_level.unwrap_or(0)
    }

    pub fn clear_shield_upgrade_level(&mut self) {
        self.shield_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_shield_upgrade_level(&self) -> bool {
        self.shield_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_upgrade_level(&mut self, v: i32) {
        self.shield_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional float health = 14;

    pub fn health(&self) -> f32 {
        self.health.unwrap_or(0.)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: f32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional float health_max = 15;

    pub fn health_max(&self) -> f32 {
        self.health_max.unwrap_or(0.)
    }

    pub fn clear_health_max(&mut self) {
        self.health_max = ::std::option::Option::None;
    }

    pub fn has_health_max(&self) -> bool {
        self.health_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_max(&mut self, v: f32) {
        self.health_max = ::std::option::Option::Some(v);
    }

    // optional float shield = 16;

    pub fn shield(&self) -> f32 {
        self.shield.unwrap_or(0.)
    }

    pub fn clear_shield(&mut self) {
        self.shield = ::std::option::Option::None;
    }

    pub fn has_shield(&self) -> bool {
        self.shield.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield(&mut self, v: f32) {
        self.shield = ::std::option::Option::Some(v);
    }

    // optional float shield_max = 36;

    pub fn shield_max(&self) -> f32 {
        self.shield_max.unwrap_or(0.)
    }

    pub fn clear_shield_max(&mut self) {
        self.shield_max = ::std::option::Option::None;
    }

    pub fn has_shield_max(&self) -> bool {
        self.shield_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_max(&mut self, v: f32) {
        self.shield_max = ::std::option::Option::Some(v);
    }

    // optional float energy = 17;

    pub fn energy(&self) -> f32 {
        self.energy.unwrap_or(0.)
    }

    pub fn clear_energy(&mut self) {
        self.energy = ::std::option::Option::None;
    }

    pub fn has_energy(&self) -> bool {
        self.energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: f32) {
        self.energy = ::std::option::Option::Some(v);
    }

    // optional float energy_max = 37;

    pub fn energy_max(&self) -> f32 {
        self.energy_max.unwrap_or(0.)
    }

    pub fn clear_energy_max(&mut self) {
        self.energy_max = ::std::option::Option::None;
    }

    pub fn has_energy_max(&self) -> bool {
        self.energy_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy_max(&mut self, v: f32) {
        self.energy_max = ::std::option::Option::Some(v);
    }

    // optional int32 mineral_contents = 18;

    pub fn mineral_contents(&self) -> i32 {
        self.mineral_contents.unwrap_or(0)
    }

    pub fn clear_mineral_contents(&mut self) {
        self.mineral_contents = ::std::option::Option::None;
    }

    pub fn has_mineral_contents(&self) -> bool {
        self.mineral_contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mineral_contents(&mut self, v: i32) {
        self.mineral_contents = ::std::option::Option::Some(v);
    }

    // optional int32 vespene_contents = 19;

    pub fn vespene_contents(&self) -> i32 {
        self.vespene_contents.unwrap_or(0)
    }

    pub fn clear_vespene_contents(&mut self) {
        self.vespene_contents = ::std::option::Option::None;
    }

    pub fn has_vespene_contents(&self) -> bool {
        self.vespene_contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vespene_contents(&mut self, v: i32) {
        self.vespene_contents = ::std::option::Option::Some(v);
    }

    // optional bool is_flying = 20;

    pub fn is_flying(&self) -> bool {
        self.is_flying.unwrap_or(false)
    }

    pub fn clear_is_flying(&mut self) {
        self.is_flying = ::std::option::Option::None;
    }

    pub fn has_is_flying(&self) -> bool {
        self.is_flying.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_flying(&mut self, v: bool) {
        self.is_flying = ::std::option::Option::Some(v);
    }

    // optional bool is_burrowed = 21;

    pub fn is_burrowed(&self) -> bool {
        self.is_burrowed.unwrap_or(false)
    }

    pub fn clear_is_burrowed(&mut self) {
        self.is_burrowed = ::std::option::Option::None;
    }

    pub fn has_is_burrowed(&self) -> bool {
        self.is_burrowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_burrowed(&mut self, v: bool) {
        self.is_burrowed = ::std::option::Option::Some(v);
    }

    // optional bool is_hallucination = 38;

    pub fn is_hallucination(&self) -> bool {
        self.is_hallucination.unwrap_or(false)
    }

    pub fn clear_is_hallucination(&mut self) {
        self.is_hallucination = ::std::option::Option::None;
    }

    pub fn has_is_hallucination(&self) -> bool {
        self.is_hallucination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hallucination(&mut self, v: bool) {
        self.is_hallucination = ::std::option::Option::Some(v);
    }

    // optional uint64 add_on_tag = 23;

    pub fn add_on_tag(&self) -> u64 {
        self.add_on_tag.unwrap_or(0)
    }

    pub fn clear_add_on_tag(&mut self) {
        self.add_on_tag = ::std::option::Option::None;
    }

    pub fn has_add_on_tag(&self) -> bool {
        self.add_on_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_add_on_tag(&mut self, v: u64) {
        self.add_on_tag = ::std::option::Option::Some(v);
    }

    // optional int32 cargo_space_taken = 25;

    pub fn cargo_space_taken(&self) -> i32 {
        self.cargo_space_taken.unwrap_or(0)
    }

    pub fn clear_cargo_space_taken(&mut self) {
        self.cargo_space_taken = ::std::option::Option::None;
    }

    pub fn has_cargo_space_taken(&self) -> bool {
        self.cargo_space_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cargo_space_taken(&mut self, v: i32) {
        self.cargo_space_taken = ::std::option::Option::Some(v);
    }

    // optional int32 cargo_space_max = 26;

    pub fn cargo_space_max(&self) -> i32 {
        self.cargo_space_max.unwrap_or(0)
    }

    pub fn clear_cargo_space_max(&mut self) {
        self.cargo_space_max = ::std::option::Option::None;
    }

    pub fn has_cargo_space_max(&self) -> bool {
        self.cargo_space_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cargo_space_max(&mut self, v: i32) {
        self.cargo_space_max = ::std::option::Option::Some(v);
    }

    // optional int32 assigned_harvesters = 28;

    pub fn assigned_harvesters(&self) -> i32 {
        self.assigned_harvesters.unwrap_or(0)
    }

    pub fn clear_assigned_harvesters(&mut self) {
        self.assigned_harvesters = ::std::option::Option::None;
    }

    pub fn has_assigned_harvesters(&self) -> bool {
        self.assigned_harvesters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_harvesters(&mut self, v: i32) {
        self.assigned_harvesters = ::std::option::Option::Some(v);
    }

    // optional int32 ideal_harvesters = 29;

    pub fn ideal_harvesters(&self) -> i32 {
        self.ideal_harvesters.unwrap_or(0)
    }

    pub fn clear_ideal_harvesters(&mut self) {
        self.ideal_harvesters = ::std::option::Option::None;
    }

    pub fn has_ideal_harvesters(&self) -> bool {
        self.ideal_harvesters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ideal_harvesters(&mut self, v: i32) {
        self.ideal_harvesters = ::std::option::Option::Some(v);
    }

    // optional float weapon_cooldown = 30;

    pub fn weapon_cooldown(&self) -> f32 {
        self.weapon_cooldown.unwrap_or(0.)
    }

    pub fn clear_weapon_cooldown(&mut self) {
        self.weapon_cooldown = ::std::option::Option::None;
    }

    pub fn has_weapon_cooldown(&self) -> bool {
        self.weapon_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weapon_cooldown(&mut self, v: f32) {
        self.weapon_cooldown = ::std::option::Option::Some(v);
    }

    // optional uint64 engaged_target_tag = 34;

    pub fn engaged_target_tag(&self) -> u64 {
        self.engaged_target_tag.unwrap_or(0)
    }

    pub fn clear_engaged_target_tag(&mut self) {
        self.engaged_target_tag = ::std::option::Option::None;
    }

    pub fn has_engaged_target_tag(&self) -> bool {
        self.engaged_target_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engaged_target_tag(&mut self, v: u64) {
        self.engaged_target_tag = ::std::option::Option::Some(v);
    }

    // optional int32 buff_duration_remain = 43;

    pub fn buff_duration_remain(&self) -> i32 {
        self.buff_duration_remain.unwrap_or(0)
    }

    pub fn clear_buff_duration_remain(&mut self) {
        self.buff_duration_remain = ::std::option::Option::None;
    }

    pub fn has_buff_duration_remain(&self) -> bool {
        self.buff_duration_remain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_duration_remain(&mut self, v: i32) {
        self.buff_duration_remain = ::std::option::Option::Some(v);
    }

    // optional int32 buff_duration_max = 44;

    pub fn buff_duration_max(&self) -> i32 {
        self.buff_duration_max.unwrap_or(0)
    }

    pub fn clear_buff_duration_max(&mut self) {
        self.buff_duration_max = ::std::option::Option::None;
    }

    pub fn has_buff_duration_max(&self) -> bool {
        self.buff_duration_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_duration_max(&mut self, v: i32) {
        self.buff_duration_max = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(44);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_type",
            |m: &Unit| { &m.display_type },
            |m: &mut Unit| { &mut m.display_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alliance",
            |m: &Unit| { &m.alliance },
            |m: &mut Unit| { &mut m.alliance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &Unit| { &m.tag },
            |m: &mut Unit| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type",
            |m: &Unit| { &m.unit_type },
            |m: &mut Unit| { &mut m.unit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &Unit| { &m.owner },
            |m: &mut Unit| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "pos",
            |m: &Unit| { &m.pos },
            |m: &mut Unit| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "facing",
            |m: &Unit| { &m.facing },
            |m: &mut Unit| { &mut m.facing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &Unit| { &m.radius },
            |m: &mut Unit| { &mut m.radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_progress",
            |m: &Unit| { &m.build_progress },
            |m: &mut Unit| { &mut m.build_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cloak",
            |m: &Unit| { &m.cloak },
            |m: &mut Unit| { &mut m.cloak },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buff_ids",
            |m: &Unit| { &m.buff_ids },
            |m: &mut Unit| { &mut m.buff_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "detect_range",
            |m: &Unit| { &m.detect_range },
            |m: &mut Unit| { &mut m.detect_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radar_range",
            |m: &Unit| { &m.radar_range },
            |m: &mut Unit| { &mut m.radar_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_selected",
            |m: &Unit| { &m.is_selected },
            |m: &mut Unit| { &mut m.is_selected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_on_screen",
            |m: &Unit| { &m.is_on_screen },
            |m: &mut Unit| { &mut m.is_on_screen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_blip",
            |m: &Unit| { &m.is_blip },
            |m: &mut Unit| { &mut m.is_blip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_powered",
            |m: &Unit| { &m.is_powered },
            |m: &mut Unit| { &mut m.is_powered },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_active",
            |m: &Unit| { &m.is_active },
            |m: &mut Unit| { &mut m.is_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attack_upgrade_level",
            |m: &Unit| { &m.attack_upgrade_level },
            |m: &mut Unit| { &mut m.attack_upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "armor_upgrade_level",
            |m: &Unit| { &m.armor_upgrade_level },
            |m: &mut Unit| { &mut m.armor_upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield_upgrade_level",
            |m: &Unit| { &m.shield_upgrade_level },
            |m: &mut Unit| { &mut m.shield_upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health",
            |m: &Unit| { &m.health },
            |m: &mut Unit| { &mut m.health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health_max",
            |m: &Unit| { &m.health_max },
            |m: &mut Unit| { &mut m.health_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield",
            |m: &Unit| { &m.shield },
            |m: &mut Unit| { &mut m.shield },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield_max",
            |m: &Unit| { &m.shield_max },
            |m: &mut Unit| { &mut m.shield_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "energy",
            |m: &Unit| { &m.energy },
            |m: &mut Unit| { &mut m.energy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "energy_max",
            |m: &Unit| { &m.energy_max },
            |m: &mut Unit| { &mut m.energy_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mineral_contents",
            |m: &Unit| { &m.mineral_contents },
            |m: &mut Unit| { &mut m.mineral_contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vespene_contents",
            |m: &Unit| { &m.vespene_contents },
            |m: &mut Unit| { &mut m.vespene_contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_flying",
            |m: &Unit| { &m.is_flying },
            |m: &mut Unit| { &mut m.is_flying },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_burrowed",
            |m: &Unit| { &m.is_burrowed },
            |m: &mut Unit| { &mut m.is_burrowed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hallucination",
            |m: &Unit| { &m.is_hallucination },
            |m: &mut Unit| { &mut m.is_hallucination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "orders",
            |m: &Unit| { &m.orders },
            |m: &mut Unit| { &mut m.orders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "add_on_tag",
            |m: &Unit| { &m.add_on_tag },
            |m: &mut Unit| { &mut m.add_on_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passengers",
            |m: &Unit| { &m.passengers },
            |m: &mut Unit| { &mut m.passengers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cargo_space_taken",
            |m: &Unit| { &m.cargo_space_taken },
            |m: &mut Unit| { &mut m.cargo_space_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cargo_space_max",
            |m: &Unit| { &m.cargo_space_max },
            |m: &mut Unit| { &mut m.cargo_space_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assigned_harvesters",
            |m: &Unit| { &m.assigned_harvesters },
            |m: &mut Unit| { &mut m.assigned_harvesters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ideal_harvesters",
            |m: &Unit| { &m.ideal_harvesters },
            |m: &mut Unit| { &mut m.ideal_harvesters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weapon_cooldown",
            |m: &Unit| { &m.weapon_cooldown },
            |m: &mut Unit| { &mut m.weapon_cooldown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engaged_target_tag",
            |m: &Unit| { &m.engaged_target_tag },
            |m: &mut Unit| { &mut m.engaged_target_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buff_duration_remain",
            |m: &Unit| { &m.buff_duration_remain },
            |m: &mut Unit| { &mut m.buff_duration_remain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buff_duration_max",
            |m: &Unit| { &m.buff_duration_max },
            |m: &mut Unit| { &mut m.buff_duration_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rally_targets",
            |m: &Unit| { &m.rally_targets },
            |m: &mut Unit| { &mut m.rally_targets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Unit>(
            "Unit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Unit {
    const NAME: &'static str = "Unit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.alliance = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.unit_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.owner = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                61 => {
                    self.facing = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.build_progress = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.cloak = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                218 => {
                    is.read_repeated_packed_uint32_into(&mut self.buff_ids)?;
                },
                216 => {
                    self.buff_ids.push(is.read_uint32()?);
                },
                253 => {
                    self.detect_range = ::std::option::Option::Some(is.read_float()?);
                },
                261 => {
                    self.radar_range = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.is_selected = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.is_on_screen = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_blip = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.is_powered = ::std::option::Option::Some(is.read_bool()?);
                },
                312 => {
                    self.is_active = ::std::option::Option::Some(is.read_bool()?);
                },
                320 => {
                    self.attack_upgrade_level = ::std::option::Option::Some(is.read_int32()?);
                },
                328 => {
                    self.armor_upgrade_level = ::std::option::Option::Some(is.read_int32()?);
                },
                336 => {
                    self.shield_upgrade_level = ::std::option::Option::Some(is.read_int32()?);
                },
                117 => {
                    self.health = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.health_max = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.shield = ::std::option::Option::Some(is.read_float()?);
                },
                293 => {
                    self.shield_max = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.energy = ::std::option::Option::Some(is.read_float()?);
                },
                301 => {
                    self.energy_max = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.mineral_contents = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.vespene_contents = ::std::option::Option::Some(is.read_int32()?);
                },
                160 => {
                    self.is_flying = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.is_burrowed = ::std::option::Option::Some(is.read_bool()?);
                },
                304 => {
                    self.is_hallucination = ::std::option::Option::Some(is.read_bool()?);
                },
                178 => {
                    self.orders.push(is.read_message()?);
                },
                184 => {
                    self.add_on_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                194 => {
                    self.passengers.push(is.read_message()?);
                },
                200 => {
                    self.cargo_space_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                208 => {
                    self.cargo_space_max = ::std::option::Option::Some(is.read_int32()?);
                },
                224 => {
                    self.assigned_harvesters = ::std::option::Option::Some(is.read_int32()?);
                },
                232 => {
                    self.ideal_harvesters = ::std::option::Option::Some(is.read_int32()?);
                },
                245 => {
                    self.weapon_cooldown = ::std::option::Option::Some(is.read_float()?);
                },
                272 => {
                    self.engaged_target_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                344 => {
                    self.buff_duration_remain = ::std::option::Option::Some(is.read_int32()?);
                },
                352 => {
                    self.buff_duration_max = ::std::option::Option::Some(is.read_int32()?);
                },
                362 => {
                    self.rally_targets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.display_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.alliance {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.facing {
            my_size += 1 + 4;
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.build_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cloak {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        for value in &self.buff_ids {
            my_size += ::protobuf::rt::uint32_size(27, *value);
        };
        if let Some(v) = self.detect_range {
            my_size += 2 + 4;
        }
        if let Some(v) = self.radar_range {
            my_size += 2 + 4;
        }
        if let Some(v) = self.is_selected {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_on_screen {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_blip {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_powered {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.attack_upgrade_level {
            my_size += ::protobuf::rt::int32_size(40, v);
        }
        if let Some(v) = self.armor_upgrade_level {
            my_size += ::protobuf::rt::int32_size(41, v);
        }
        if let Some(v) = self.shield_upgrade_level {
            my_size += ::protobuf::rt::int32_size(42, v);
        }
        if let Some(v) = self.health {
            my_size += 1 + 4;
        }
        if let Some(v) = self.health_max {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shield {
            my_size += 2 + 4;
        }
        if let Some(v) = self.shield_max {
            my_size += 2 + 4;
        }
        if let Some(v) = self.energy {
            my_size += 2 + 4;
        }
        if let Some(v) = self.energy_max {
            my_size += 2 + 4;
        }
        if let Some(v) = self.mineral_contents {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.vespene_contents {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        if let Some(v) = self.is_flying {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_burrowed {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_hallucination {
            my_size += 2 + 1;
        }
        for value in &self.orders {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.add_on_tag {
            my_size += ::protobuf::rt::uint64_size(23, v);
        }
        for value in &self.passengers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cargo_space_taken {
            my_size += ::protobuf::rt::int32_size(25, v);
        }
        if let Some(v) = self.cargo_space_max {
            my_size += ::protobuf::rt::int32_size(26, v);
        }
        if let Some(v) = self.assigned_harvesters {
            my_size += ::protobuf::rt::int32_size(28, v);
        }
        if let Some(v) = self.ideal_harvesters {
            my_size += ::protobuf::rt::int32_size(29, v);
        }
        if let Some(v) = self.weapon_cooldown {
            my_size += 2 + 4;
        }
        if let Some(v) = self.engaged_target_tag {
            my_size += ::protobuf::rt::uint64_size(34, v);
        }
        if let Some(v) = self.buff_duration_remain {
            my_size += ::protobuf::rt::int32_size(43, v);
        }
        if let Some(v) = self.buff_duration_max {
            my_size += ::protobuf::rt::int32_size(44, v);
        }
        for value in &self.rally_targets {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.display_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.alliance {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tag {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.unit_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.owner {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.facing {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.build_progress {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.cloak {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.buff_ids {
            os.write_uint32(27, *v)?;
        };
        if let Some(v) = self.detect_range {
            os.write_float(31, v)?;
        }
        if let Some(v) = self.radar_range {
            os.write_float(32, v)?;
        }
        if let Some(v) = self.is_selected {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.is_on_screen {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_blip {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_powered {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.is_active {
            os.write_bool(39, v)?;
        }
        if let Some(v) = self.attack_upgrade_level {
            os.write_int32(40, v)?;
        }
        if let Some(v) = self.armor_upgrade_level {
            os.write_int32(41, v)?;
        }
        if let Some(v) = self.shield_upgrade_level {
            os.write_int32(42, v)?;
        }
        if let Some(v) = self.health {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.health_max {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.shield {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.shield_max {
            os.write_float(36, v)?;
        }
        if let Some(v) = self.energy {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.energy_max {
            os.write_float(37, v)?;
        }
        if let Some(v) = self.mineral_contents {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.vespene_contents {
            os.write_int32(19, v)?;
        }
        if let Some(v) = self.is_flying {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.is_burrowed {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.is_hallucination {
            os.write_bool(38, v)?;
        }
        for v in &self.orders {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.add_on_tag {
            os.write_uint64(23, v)?;
        }
        for v in &self.passengers {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        if let Some(v) = self.cargo_space_taken {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.cargo_space_max {
            os.write_int32(26, v)?;
        }
        if let Some(v) = self.assigned_harvesters {
            os.write_int32(28, v)?;
        }
        if let Some(v) = self.ideal_harvesters {
            os.write_int32(29, v)?;
        }
        if let Some(v) = self.weapon_cooldown {
            os.write_float(30, v)?;
        }
        if let Some(v) = self.engaged_target_tag {
            os.write_uint64(34, v)?;
        }
        if let Some(v) = self.buff_duration_remain {
            os.write_int32(43, v)?;
        }
        if let Some(v) = self.buff_duration_max {
            os.write_int32(44, v)?;
        }
        for v in &self.rally_targets {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Unit {
        Unit::new()
    }

    fn clear(&mut self) {
        self.display_type = ::std::option::Option::None;
        self.alliance = ::std::option::Option::None;
        self.tag = ::std::option::Option::None;
        self.unit_type = ::std::option::Option::None;
        self.owner = ::std::option::Option::None;
        self.pos.clear();
        self.facing = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.build_progress = ::std::option::Option::None;
        self.cloak = ::std::option::Option::None;
        self.buff_ids.clear();
        self.detect_range = ::std::option::Option::None;
        self.radar_range = ::std::option::Option::None;
        self.is_selected = ::std::option::Option::None;
        self.is_on_screen = ::std::option::Option::None;
        self.is_blip = ::std::option::Option::None;
        self.is_powered = ::std::option::Option::None;
        self.is_active = ::std::option::Option::None;
        self.attack_upgrade_level = ::std::option::Option::None;
        self.armor_upgrade_level = ::std::option::Option::None;
        self.shield_upgrade_level = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.health_max = ::std::option::Option::None;
        self.shield = ::std::option::Option::None;
        self.shield_max = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.energy_max = ::std::option::Option::None;
        self.mineral_contents = ::std::option::Option::None;
        self.vespene_contents = ::std::option::Option::None;
        self.is_flying = ::std::option::Option::None;
        self.is_burrowed = ::std::option::Option::None;
        self.is_hallucination = ::std::option::Option::None;
        self.orders.clear();
        self.add_on_tag = ::std::option::Option::None;
        self.passengers.clear();
        self.cargo_space_taken = ::std::option::Option::None;
        self.cargo_space_max = ::std::option::Option::None;
        self.assigned_harvesters = ::std::option::Option::None;
        self.ideal_harvesters = ::std::option::Option::None;
        self.weapon_cooldown = ::std::option::Option::None;
        self.engaged_target_tag = ::std::option::Option::None;
        self.buff_duration_remain = ::std::option::Option::None;
        self.buff_duration_max = ::std::option::Option::None;
        self.rally_targets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Unit {
        static instance: Unit = Unit {
            display_type: ::std::option::Option::None,
            alliance: ::std::option::Option::None,
            tag: ::std::option::Option::None,
            unit_type: ::std::option::Option::None,
            owner: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            facing: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            build_progress: ::std::option::Option::None,
            cloak: ::std::option::Option::None,
            buff_ids: ::std::vec::Vec::new(),
            detect_range: ::std::option::Option::None,
            radar_range: ::std::option::Option::None,
            is_selected: ::std::option::Option::None,
            is_on_screen: ::std::option::Option::None,
            is_blip: ::std::option::Option::None,
            is_powered: ::std::option::Option::None,
            is_active: ::std::option::Option::None,
            attack_upgrade_level: ::std::option::Option::None,
            armor_upgrade_level: ::std::option::Option::None,
            shield_upgrade_level: ::std::option::Option::None,
            health: ::std::option::Option::None,
            health_max: ::std::option::Option::None,
            shield: ::std::option::Option::None,
            shield_max: ::std::option::Option::None,
            energy: ::std::option::Option::None,
            energy_max: ::std::option::Option::None,
            mineral_contents: ::std::option::Option::None,
            vespene_contents: ::std::option::Option::None,
            is_flying: ::std::option::Option::None,
            is_burrowed: ::std::option::Option::None,
            is_hallucination: ::std::option::Option::None,
            orders: ::std::vec::Vec::new(),
            add_on_tag: ::std::option::Option::None,
            passengers: ::std::vec::Vec::new(),
            cargo_space_taken: ::std::option::Option::None,
            cargo_space_max: ::std::option::Option::None,
            assigned_harvesters: ::std::option::Option::None,
            ideal_harvesters: ::std::option::Option::None,
            weapon_cooldown: ::std::option::Option::None,
            engaged_target_tag: ::std::option::Option::None,
            buff_duration_remain: ::std::option::Option::None,
            buff_duration_max: ::std::option::Option::None,
            rally_targets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Unit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Unit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Unit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Unit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.MapState)
pub struct MapState {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.MapState.visibility)
    pub visibility: ::protobuf::MessageField<super::common::ImageData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.MapState.creep)
    pub creep: ::protobuf::MessageField<super::common::ImageData>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.MapState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapState {
    fn default() -> &'a MapState {
        <MapState as ::protobuf::Message>::default_instance()
    }
}

impl MapState {
    pub fn new() -> MapState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "visibility",
            |m: &MapState| { &m.visibility },
            |m: &mut MapState| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::ImageData>(
            "creep",
            |m: &MapState| { &m.creep },
            |m: &mut MapState| { &mut m.creep },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapState>(
            "MapState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapState {
    const NAME: &'static str = "MapState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.visibility)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.creep)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.creep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.visibility.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.creep.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapState {
        MapState::new()
    }

    fn clear(&mut self) {
        self.visibility.clear();
        self.creep.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapState {
        static instance: MapState = MapState {
            visibility: ::protobuf::MessageField::none(),
            creep: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Event.dead_units)
    pub dead_units: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dead_units",
            |m: &Event| { &m.dead_units },
            |m: &mut Event| { &mut m.dead_units },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.dead_units)?;
                },
                8 => {
                    self.dead_units.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dead_units {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.dead_units {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.dead_units.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            dead_units: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.Effect)
pub struct Effect {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Effect.effect_id)
    pub effect_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Effect.pos)
    pub pos: ::std::vec::Vec<super::common::Point2D>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Effect.alliance)
    pub alliance: ::std::option::Option<::protobuf::EnumOrUnknown<Alliance>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Effect.owner)
    pub owner: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Effect.radius)
    pub radius: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Effect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Effect {
    fn default() -> &'a Effect {
        <Effect as ::protobuf::Message>::default_instance()
    }
}

impl Effect {
    pub fn new() -> Effect {
        ::std::default::Default::default()
    }

    // optional uint32 effect_id = 1;

    pub fn effect_id(&self) -> u32 {
        self.effect_id.unwrap_or(0)
    }

    pub fn clear_effect_id(&mut self) {
        self.effect_id = ::std::option::Option::None;
    }

    pub fn has_effect_id(&self) -> bool {
        self.effect_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_id(&mut self, v: u32) {
        self.effect_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Alliance alliance = 3;

    pub fn alliance(&self) -> Alliance {
        match self.alliance {
            Some(e) => e.enum_value_or(Alliance::Self_),
            None => Alliance::Self_,
        }
    }

    pub fn clear_alliance(&mut self) {
        self.alliance = ::std::option::Option::None;
    }

    pub fn has_alliance(&self) -> bool {
        self.alliance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alliance(&mut self, v: Alliance) {
        self.alliance = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 owner = 4;

    pub fn owner(&self) -> i32 {
        self.owner.unwrap_or(0)
    }

    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: i32) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional float radius = 5;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_id",
            |m: &Effect| { &m.effect_id },
            |m: &mut Effect| { &mut m.effect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pos",
            |m: &Effect| { &m.pos },
            |m: &mut Effect| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "alliance",
            |m: &Effect| { &m.alliance },
            |m: &mut Effect| { &mut m.alliance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner",
            |m: &Effect| { &m.owner },
            |m: &mut Effect| { &mut m.owner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &Effect| { &m.radius },
            |m: &mut Effect| { &mut m.radius },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Effect>(
            "Effect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Effect {
    const NAME: &'static str = "Effect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.effect_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.pos.push(is.read_message()?);
                },
                24 => {
                    self.alliance = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.owner = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.effect_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.pos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.alliance {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.effect_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.pos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.alliance {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.owner {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Effect {
        Effect::new()
    }

    fn clear(&mut self) {
        self.effect_id = ::std::option::Option::None;
        self.pos.clear();
        self.alliance = ::std::option::Option::None;
        self.owner = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Effect {
        static instance: Effect = Effect {
            effect_id: ::std::option::Option::None,
            pos: ::std::vec::Vec::new(),
            alliance: ::std::option::Option::None,
            owner: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Effect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Effect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Effect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionRaw)
pub struct ActionRaw {
    // message oneof groups
    pub action: ::std::option::Option<action_raw::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionRaw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionRaw {
    fn default() -> &'a ActionRaw {
        <ActionRaw as ::protobuf::Message>::default_instance()
    }
}

impl ActionRaw {
    pub fn new() -> ActionRaw {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionRawUnitCommand unit_command = 1;

    pub fn unit_command(&self) -> &ActionRawUnitCommand {
        match self.action {
            ::std::option::Option::Some(action_raw::Action::UnitCommand(ref v)) => v,
            _ => <ActionRawUnitCommand as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_unit_command(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_unit_command(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_raw::Action::UnitCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unit_command(&mut self, v: ActionRawUnitCommand) {
        self.action = ::std::option::Option::Some(action_raw::Action::UnitCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unit_command(&mut self) -> &mut ActionRawUnitCommand {
        if let ::std::option::Option::Some(action_raw::Action::UnitCommand(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_raw::Action::UnitCommand(ActionRawUnitCommand::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_raw::Action::UnitCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unit_command(&mut self) -> ActionRawUnitCommand {
        if self.has_unit_command() {
            match self.action.take() {
                ::std::option::Option::Some(action_raw::Action::UnitCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionRawUnitCommand::new()
        }
    }

    // optional .SC2APIProtocol.ActionRawCameraMove camera_move = 2;

    pub fn camera_move(&self) -> &ActionRawCameraMove {
        match self.action {
            ::std::option::Option::Some(action_raw::Action::CameraMove(ref v)) => v,
            _ => <ActionRawCameraMove as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_camera_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_raw::Action::CameraMove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_move(&mut self, v: ActionRawCameraMove) {
        self.action = ::std::option::Option::Some(action_raw::Action::CameraMove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_move(&mut self) -> &mut ActionRawCameraMove {
        if let ::std::option::Option::Some(action_raw::Action::CameraMove(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_raw::Action::CameraMove(ActionRawCameraMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_raw::Action::CameraMove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_move(&mut self) -> ActionRawCameraMove {
        if self.has_camera_move() {
            match self.action.take() {
                ::std::option::Option::Some(action_raw::Action::CameraMove(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionRawCameraMove::new()
        }
    }

    // optional .SC2APIProtocol.ActionRawToggleAutocast toggle_autocast = 3;

    pub fn toggle_autocast(&self) -> &ActionRawToggleAutocast {
        match self.action {
            ::std::option::Option::Some(action_raw::Action::ToggleAutocast(ref v)) => v,
            _ => <ActionRawToggleAutocast as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_toggle_autocast(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_toggle_autocast(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_raw::Action::ToggleAutocast(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_toggle_autocast(&mut self, v: ActionRawToggleAutocast) {
        self.action = ::std::option::Option::Some(action_raw::Action::ToggleAutocast(v))
    }

    // Mutable pointer to the field.
    pub fn mut_toggle_autocast(&mut self) -> &mut ActionRawToggleAutocast {
        if let ::std::option::Option::Some(action_raw::Action::ToggleAutocast(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_raw::Action::ToggleAutocast(ActionRawToggleAutocast::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_raw::Action::ToggleAutocast(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_toggle_autocast(&mut self) -> ActionRawToggleAutocast {
        if self.has_toggle_autocast() {
            match self.action.take() {
                ::std::option::Option::Some(action_raw::Action::ToggleAutocast(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionRawToggleAutocast::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionRawUnitCommand>(
            "unit_command",
            ActionRaw::has_unit_command,
            ActionRaw::unit_command,
            ActionRaw::mut_unit_command,
            ActionRaw::set_unit_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionRawCameraMove>(
            "camera_move",
            ActionRaw::has_camera_move,
            ActionRaw::camera_move,
            ActionRaw::mut_camera_move,
            ActionRaw::set_camera_move,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionRawToggleAutocast>(
            "toggle_autocast",
            ActionRaw::has_toggle_autocast,
            ActionRaw::toggle_autocast,
            ActionRaw::mut_toggle_autocast,
            ActionRaw::set_toggle_autocast,
        ));
        oneofs.push(action_raw::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionRaw>(
            "ActionRaw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionRaw {
    const NAME: &'static str = "ActionRaw";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.action = ::std::option::Option::Some(action_raw::Action::UnitCommand(is.read_message()?));
                },
                18 => {
                    self.action = ::std::option::Option::Some(action_raw::Action::CameraMove(is.read_message()?));
                },
                26 => {
                    self.action = ::std::option::Option::Some(action_raw::Action::ToggleAutocast(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &action_raw::Action::UnitCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_raw::Action::CameraMove(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_raw::Action::ToggleAutocast(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &action_raw::Action::UnitCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &action_raw::Action::CameraMove(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &action_raw::Action::ToggleAutocast(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionRaw {
        ActionRaw::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionRaw {
        static instance: ActionRaw = ActionRaw {
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionRaw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionRaw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionRaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRaw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionRaw`
pub mod action_raw {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ActionRaw.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionRaw.unit_command)
        UnitCommand(super::ActionRawUnitCommand),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionRaw.camera_move)
        CameraMove(super::ActionRawCameraMove),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionRaw.toggle_autocast)
        ToggleAutocast(super::ActionRawToggleAutocast),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ActionRaw as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionRawUnitCommand)
pub struct ActionRawUnitCommand {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionRawUnitCommand.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionRawUnitCommand.unit_tags)
    pub unit_tags: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionRawUnitCommand.queue_command)
    pub queue_command: ::std::option::Option<bool>,
    // message oneof groups
    pub target: ::std::option::Option<action_raw_unit_command::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionRawUnitCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionRawUnitCommand {
    fn default() -> &'a ActionRawUnitCommand {
        <ActionRawUnitCommand as ::protobuf::Message>::default_instance()
    }
}

impl ActionRawUnitCommand {
    pub fn new() -> ActionRawUnitCommand {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Point2D target_world_space_pos = 2;

    pub fn target_world_space_pos(&self) -> &super::common::Point2D {
        match self.target {
            ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(ref v)) => v,
            _ => <super::common::Point2D as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_world_space_pos(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_world_space_pos(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_world_space_pos(&mut self, v: super::common::Point2D) {
        self.target = ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_world_space_pos(&mut self) -> &mut super::common::Point2D {
        if let ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(super::common::Point2D::new()));
        }
        match self.target {
            ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_world_space_pos(&mut self) -> super::common::Point2D {
        if self.has_target_world_space_pos() {
            match self.target.take() {
                ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::Point2D::new()
        }
    }

    // optional uint64 target_unit_tag = 3;

    pub fn target_unit_tag(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(action_raw_unit_command::Target::TargetUnitTag(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_target_unit_tag(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_unit_tag(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(action_raw_unit_command::Target::TargetUnitTag(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_unit_tag(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(action_raw_unit_command::Target::TargetUnitTag(v))
    }

    // optional bool queue_command = 5;

    pub fn queue_command(&self) -> bool {
        self.queue_command.unwrap_or(false)
    }

    pub fn clear_queue_command(&mut self) {
        self.queue_command = ::std::option::Option::None;
    }

    pub fn has_queue_command(&self) -> bool {
        self.queue_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_command(&mut self, v: bool) {
        self.queue_command = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &ActionRawUnitCommand| { &m.ability_id },
            |m: &mut ActionRawUnitCommand| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::common::Point2D>(
            "target_world_space_pos",
            ActionRawUnitCommand::has_target_world_space_pos,
            ActionRawUnitCommand::target_world_space_pos,
            ActionRawUnitCommand::mut_target_world_space_pos,
            ActionRawUnitCommand::set_target_world_space_pos,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "target_unit_tag",
            ActionRawUnitCommand::has_target_unit_tag,
            ActionRawUnitCommand::target_unit_tag,
            ActionRawUnitCommand::set_target_unit_tag,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unit_tags",
            |m: &ActionRawUnitCommand| { &m.unit_tags },
            |m: &mut ActionRawUnitCommand| { &mut m.unit_tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_command",
            |m: &ActionRawUnitCommand| { &m.queue_command },
            |m: &mut ActionRawUnitCommand| { &mut m.queue_command },
        ));
        oneofs.push(action_raw_unit_command::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionRawUnitCommand>(
            "ActionRawUnitCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionRawUnitCommand {
    const NAME: &'static str = "ActionRawUnitCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.target = ::std::option::Option::Some(action_raw_unit_command::Target::TargetWorldSpacePos(is.read_message()?));
                },
                24 => {
                    self.target = ::std::option::Option::Some(action_raw_unit_command::Target::TargetUnitTag(is.read_uint64()?));
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.unit_tags)?;
                },
                32 => {
                    self.unit_tags.push(is.read_uint64()?);
                },
                40 => {
                    self.queue_command = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.unit_tags {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        if let Some(v) = self.queue_command {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &action_raw_unit_command::Target::TargetWorldSpacePos(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_raw_unit_command::Target::TargetUnitTag(v) => {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        for v in &self.unit_tags {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.queue_command {
            os.write_bool(5, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &action_raw_unit_command::Target::TargetWorldSpacePos(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &action_raw_unit_command::Target::TargetUnitTag(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionRawUnitCommand {
        ActionRawUnitCommand::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unit_tags.clear();
        self.queue_command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionRawUnitCommand {
        static instance: ActionRawUnitCommand = ActionRawUnitCommand {
            ability_id: ::std::option::Option::None,
            unit_tags: ::std::vec::Vec::new(),
            queue_command: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionRawUnitCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionRawUnitCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionRawUnitCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRawUnitCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionRawUnitCommand`
pub mod action_raw_unit_command {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ActionRawUnitCommand.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionRawUnitCommand.target_world_space_pos)
        TargetWorldSpacePos(super::super::common::Point2D),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionRawUnitCommand.target_unit_tag)
        TargetUnitTag(u64),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ActionRawUnitCommand as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionRawCameraMove)
pub struct ActionRawCameraMove {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionRawCameraMove.center_world_space)
    pub center_world_space: ::protobuf::MessageField<super::common::Point>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionRawCameraMove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionRawCameraMove {
    fn default() -> &'a ActionRawCameraMove {
        <ActionRawCameraMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionRawCameraMove {
    pub fn new() -> ActionRawCameraMove {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point>(
            "center_world_space",
            |m: &ActionRawCameraMove| { &m.center_world_space },
            |m: &mut ActionRawCameraMove| { &mut m.center_world_space },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionRawCameraMove>(
            "ActionRawCameraMove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionRawCameraMove {
    const NAME: &'static str = "ActionRawCameraMove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.center_world_space)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.center_world_space.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.center_world_space.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionRawCameraMove {
        ActionRawCameraMove::new()
    }

    fn clear(&mut self) {
        self.center_world_space.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionRawCameraMove {
        static instance: ActionRawCameraMove = ActionRawCameraMove {
            center_world_space: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionRawCameraMove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionRawCameraMove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionRawCameraMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRawCameraMove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionRawToggleAutocast)
pub struct ActionRawToggleAutocast {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionRawToggleAutocast.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionRawToggleAutocast.unit_tags)
    pub unit_tags: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionRawToggleAutocast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionRawToggleAutocast {
    fn default() -> &'a ActionRawToggleAutocast {
        <ActionRawToggleAutocast as ::protobuf::Message>::default_instance()
    }
}

impl ActionRawToggleAutocast {
    pub fn new() -> ActionRawToggleAutocast {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &ActionRawToggleAutocast| { &m.ability_id },
            |m: &mut ActionRawToggleAutocast| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unit_tags",
            |m: &ActionRawToggleAutocast| { &m.unit_tags },
            |m: &mut ActionRawToggleAutocast| { &mut m.unit_tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionRawToggleAutocast>(
            "ActionRawToggleAutocast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionRawToggleAutocast {
    const NAME: &'static str = "ActionRawToggleAutocast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.unit_tags)?;
                },
                16 => {
                    self.unit_tags.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.unit_tags {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        for v in &self.unit_tags {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionRawToggleAutocast {
        ActionRawToggleAutocast::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.unit_tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionRawToggleAutocast {
        static instance: ActionRawToggleAutocast = ActionRawToggleAutocast {
            ability_id: ::std::option::Option::None,
            unit_tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionRawToggleAutocast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionRawToggleAutocast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionRawToggleAutocast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRawToggleAutocast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.DisplayType)
pub enum DisplayType {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DisplayType.Visible)
    Visible = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DisplayType.Snapshot)
    Snapshot = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DisplayType.Hidden)
    Hidden = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.DisplayType.Placeholder)
    Placeholder = 4,
}

impl ::protobuf::Enum for DisplayType {
    const NAME: &'static str = "DisplayType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DisplayType> {
        match value {
            1 => ::std::option::Option::Some(DisplayType::Visible),
            2 => ::std::option::Option::Some(DisplayType::Snapshot),
            3 => ::std::option::Option::Some(DisplayType::Hidden),
            4 => ::std::option::Option::Some(DisplayType::Placeholder),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DisplayType] = &[
        DisplayType::Visible,
        DisplayType::Snapshot,
        DisplayType::Hidden,
        DisplayType::Placeholder,
    ];
}

impl ::protobuf::EnumFull for DisplayType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DisplayType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            DisplayType::Visible => 0,
            DisplayType::Snapshot => 1,
            DisplayType::Hidden => 2,
            DisplayType::Placeholder => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DisplayType {
    fn default() -> Self {
        DisplayType::Visible
    }
}

impl DisplayType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DisplayType>("DisplayType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.Alliance)
pub enum Alliance {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alliance.Self)
    Self_ = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alliance.Ally)
    Ally = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alliance.Neutral)
    Neutral = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alliance.Enemy)
    Enemy = 4,
}

impl ::protobuf::Enum for Alliance {
    const NAME: &'static str = "Alliance";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Alliance> {
        match value {
            1 => ::std::option::Option::Some(Alliance::Self_),
            2 => ::std::option::Option::Some(Alliance::Ally),
            3 => ::std::option::Option::Some(Alliance::Neutral),
            4 => ::std::option::Option::Some(Alliance::Enemy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Alliance] = &[
        Alliance::Self_,
        Alliance::Ally,
        Alliance::Neutral,
        Alliance::Enemy,
    ];
}

impl ::protobuf::EnumFull for Alliance {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Alliance").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Alliance::Self_ => 0,
            Alliance::Ally => 1,
            Alliance::Neutral => 2,
            Alliance::Enemy => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Alliance {
    fn default() -> Self {
        Alliance::Self_
    }
}

impl Alliance {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Alliance>("Alliance")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.CloakState)
pub enum CloakState {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.CloakState.CloakedUnknown)
    CloakedUnknown = 0,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.CloakState.Cloaked)
    Cloaked = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.CloakState.CloakedDetected)
    CloakedDetected = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.CloakState.NotCloaked)
    NotCloaked = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.CloakState.CloakedAllied)
    CloakedAllied = 4,
}

impl ::protobuf::Enum for CloakState {
    const NAME: &'static str = "CloakState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CloakState> {
        match value {
            0 => ::std::option::Option::Some(CloakState::CloakedUnknown),
            1 => ::std::option::Option::Some(CloakState::Cloaked),
            2 => ::std::option::Option::Some(CloakState::CloakedDetected),
            3 => ::std::option::Option::Some(CloakState::NotCloaked),
            4 => ::std::option::Option::Some(CloakState::CloakedAllied),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CloakState] = &[
        CloakState::CloakedUnknown,
        CloakState::Cloaked,
        CloakState::CloakedDetected,
        CloakState::NotCloaked,
        CloakState::CloakedAllied,
    ];
}

impl ::protobuf::EnumFull for CloakState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CloakState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CloakState {
    fn default() -> Self {
        CloakState::CloakedUnknown
    }
}

impl CloakState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CloakState>("CloakState")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1as2clientprotocol/raw.proto\x12\x0eSC2APIProtocol\x1a\x1ds2clientpr\
    otocol/common.proto\"\x83\x03\n\x08StartRaw\x122\n\x08map_size\x18\x01\
    \x20\x01(\x0b2\x17.SC2APIProtocol.Size2DIR\x07mapSize\x12<\n\x0cpathing_\
    grid\x18\x02\x20\x01(\x0b2\x19.SC2APIProtocol.ImageDataR\x0bpathingGrid\
    \x12@\n\x0eterrain_height\x18\x03\x20\x01(\x0b2\x19.SC2APIProtocol.Image\
    DataR\rterrainHeight\x12@\n\x0eplacement_grid\x18\x04\x20\x01(\x0b2\x19.\
    SC2APIProtocol.ImageDataR\rplacementGrid\x12?\n\rplayable_area\x18\x05\
    \x20\x01(\x0b2\x1a.SC2APIProtocol.RectangleIR\x0cplayableArea\x12@\n\x0f\
    start_locations\x18\x06\x20\x03(\x0b2\x17.SC2APIProtocol.Point2DR\x0esta\
    rtLocations\"\xb6\x02\n\x0eObservationRaw\x121\n\x06player\x18\x01\x20\
    \x01(\x0b2\x19.SC2APIProtocol.PlayerRawR\x06player\x12*\n\x05units\x18\
    \x02\x20\x03(\x0b2\x14.SC2APIProtocol.UnitR\x05units\x125\n\tmap_state\
    \x18\x03\x20\x01(\x0b2\x18.SC2APIProtocol.MapStateR\x08mapState\x12+\n\
    \x05event\x18\x04\x20\x01(\x0b2\x15.SC2APIProtocol.EventR\x05event\x120\
    \n\x07effects\x18\x05\x20\x03(\x0b2\x16.SC2APIProtocol.EffectR\x07effect\
    s\x12/\n\x05radar\x18\x06\x20\x03(\x0b2\x19.SC2APIProtocol.RadarRingR\
    \x05radar\"L\n\tRadarRing\x12'\n\x03pos\x18\x01\x20\x01(\x0b2\x15.SC2API\
    Protocol.PointR\x03pos\x12\x16\n\x06radius\x18\x02\x20\x01(\x02R\x06radi\
    us\"`\n\x0bPowerSource\x12'\n\x03pos\x18\x01\x20\x01(\x0b2\x15.SC2APIPro\
    tocol.PointR\x03pos\x12\x16\n\x06radius\x18\x02\x20\x01(\x02R\x06radius\
    \x12\x10\n\x03tag\x18\x03\x20\x01(\x04R\x03tag\"\x9d\x01\n\tPlayerRaw\
    \x12@\n\rpower_sources\x18\x01\x20\x03(\x0b2\x1b.SC2APIProtocol.PowerSou\
    rceR\x0cpowerSources\x12-\n\x06camera\x18\x02\x20\x01(\x0b2\x15.SC2APIPr\
    otocol.PointR\x06camera\x12\x1f\n\x0bupgrade_ids\x18\x03\x20\x03(\rR\nup\
    gradeIds\"\xc8\x01\n\tUnitOrder\x12\x1d\n\nability_id\x18\x01\x20\x01(\r\
    R\tabilityId\x12L\n\x16target_world_space_pos\x18\x02\x20\x01(\x0b2\x15.\
    SC2APIProtocol.PointH\0R\x13targetWorldSpacePos\x12(\n\x0ftarget_unit_ta\
    g\x18\x03\x20\x01(\x04H\0R\rtargetUnitTag\x12\x1a\n\x08progress\x18\x04\
    \x20\x01(\x02R\x08progressB\x08\n\x06target\"\xe3\x01\n\rPassengerUnit\
    \x12\x10\n\x03tag\x18\x01\x20\x01(\x04R\x03tag\x12\x16\n\x06health\x18\
    \x02\x20\x01(\x02R\x06health\x12\x1d\n\nhealth_max\x18\x03\x20\x01(\x02R\
    \thealthMax\x12\x16\n\x06shield\x18\x04\x20\x01(\x02R\x06shield\x12\x1d\
    \n\nshield_max\x18\x07\x20\x01(\x02R\tshieldMax\x12\x16\n\x06energy\x18\
    \x05\x20\x01(\x02R\x06energy\x12\x1d\n\nenergy_max\x18\x08\x20\x01(\x02R\
    \tenergyMax\x12\x1b\n\tunit_type\x18\x06\x20\x01(\rR\x08unitType\"L\n\
    \x0bRallyTarget\x12+\n\x05point\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol\
    .PointR\x05point\x12\x10\n\x03tag\x18\x02\x20\x01(\x04R\x03tag\"\x99\r\n\
    \x04Unit\x12>\n\x0cdisplay_type\x18\x01\x20\x01(\x0e2\x1b.SC2APIProtocol\
    .DisplayTypeR\x0bdisplayType\x124\n\x08alliance\x18\x02\x20\x01(\x0e2\
    \x18.SC2APIProtocol.AllianceR\x08alliance\x12\x10\n\x03tag\x18\x03\x20\
    \x01(\x04R\x03tag\x12\x1b\n\tunit_type\x18\x04\x20\x01(\rR\x08unitType\
    \x12\x14\n\x05owner\x18\x05\x20\x01(\x05R\x05owner\x12'\n\x03pos\x18\x06\
    \x20\x01(\x0b2\x15.SC2APIProtocol.PointR\x03pos\x12\x16\n\x06facing\x18\
    \x07\x20\x01(\x02R\x06facing\x12\x16\n\x06radius\x18\x08\x20\x01(\x02R\
    \x06radius\x12%\n\x0ebuild_progress\x18\t\x20\x01(\x02R\rbuildProgress\
    \x120\n\x05cloak\x18\n\x20\x01(\x0e2\x1a.SC2APIProtocol.CloakStateR\x05c\
    loak\x12\x19\n\x08buff_ids\x18\x1b\x20\x03(\rR\x07buffIds\x12!\n\x0cdete\
    ct_range\x18\x1f\x20\x01(\x02R\x0bdetectRange\x12\x1f\n\x0bradar_range\
    \x18\x20\x20\x01(\x02R\nradarRange\x12\x1f\n\x0bis_selected\x18\x0b\x20\
    \x01(\x08R\nisSelected\x12\x20\n\x0cis_on_screen\x18\x0c\x20\x01(\x08R\n\
    isOnScreen\x12\x17\n\x07is_blip\x18\r\x20\x01(\x08R\x06isBlip\x12\x1d\n\
    \nis_powered\x18#\x20\x01(\x08R\tisPowered\x12\x1b\n\tis_active\x18'\x20\
    \x01(\x08R\x08isActive\x120\n\x14attack_upgrade_level\x18(\x20\x01(\x05R\
    \x12attackUpgradeLevel\x12.\n\x13armor_upgrade_level\x18)\x20\x01(\x05R\
    \x11armorUpgradeLevel\x120\n\x14shield_upgrade_level\x18*\x20\x01(\x05R\
    \x12shieldUpgradeLevel\x12\x16\n\x06health\x18\x0e\x20\x01(\x02R\x06heal\
    th\x12\x1d\n\nhealth_max\x18\x0f\x20\x01(\x02R\thealthMax\x12\x16\n\x06s\
    hield\x18\x10\x20\x01(\x02R\x06shield\x12\x1d\n\nshield_max\x18$\x20\x01\
    (\x02R\tshieldMax\x12\x16\n\x06energy\x18\x11\x20\x01(\x02R\x06energy\
    \x12\x1d\n\nenergy_max\x18%\x20\x01(\x02R\tenergyMax\x12)\n\x10mineral_c\
    ontents\x18\x12\x20\x01(\x05R\x0fmineralContents\x12)\n\x10vespene_conte\
    nts\x18\x13\x20\x01(\x05R\x0fvespeneContents\x12\x1b\n\tis_flying\x18\
    \x14\x20\x01(\x08R\x08isFlying\x12\x1f\n\x0bis_burrowed\x18\x15\x20\x01(\
    \x08R\nisBurrowed\x12)\n\x10is_hallucination\x18&\x20\x01(\x08R\x0fisHal\
    lucination\x121\n\x06orders\x18\x16\x20\x03(\x0b2\x19.SC2APIProtocol.Uni\
    tOrderR\x06orders\x12\x1c\n\nadd_on_tag\x18\x17\x20\x01(\x04R\x08addOnTa\
    g\x12=\n\npassengers\x18\x18\x20\x03(\x0b2\x1d.SC2APIProtocol.PassengerU\
    nitR\npassengers\x12*\n\x11cargo_space_taken\x18\x19\x20\x01(\x05R\x0fca\
    rgoSpaceTaken\x12&\n\x0fcargo_space_max\x18\x1a\x20\x01(\x05R\rcargoSpac\
    eMax\x12/\n\x13assigned_harvesters\x18\x1c\x20\x01(\x05R\x12assignedHarv\
    esters\x12)\n\x10ideal_harvesters\x18\x1d\x20\x01(\x05R\x0fidealHarveste\
    rs\x12'\n\x0fweapon_cooldown\x18\x1e\x20\x01(\x02R\x0eweaponCooldown\x12\
    ,\n\x12engaged_target_tag\x18\"\x20\x01(\x04R\x10engagedTargetTag\x120\n\
    \x14buff_duration_remain\x18+\x20\x01(\x05R\x12buffDurationRemain\x12*\n\
    \x11buff_duration_max\x18,\x20\x01(\x05R\x0fbuffDurationMax\x12@\n\rrall\
    y_targets\x18-\x20\x03(\x0b2\x1b.SC2APIProtocol.RallyTargetR\x0crallyTar\
    gets\"v\n\x08MapState\x129\n\nvisibility\x18\x01\x20\x01(\x0b2\x19.SC2AP\
    IProtocol.ImageDataR\nvisibility\x12/\n\x05creep\x18\x02\x20\x01(\x0b2\
    \x19.SC2APIProtocol.ImageDataR\x05creep\"&\n\x05Event\x12\x1d\n\ndead_un\
    its\x18\x01\x20\x03(\x04R\tdeadUnits\"\xb4\x01\n\x06Effect\x12\x1b\n\tef\
    fect_id\x18\x01\x20\x01(\rR\x08effectId\x12)\n\x03pos\x18\x02\x20\x03(\
    \x0b2\x17.SC2APIProtocol.Point2DR\x03pos\x124\n\x08alliance\x18\x03\x20\
    \x01(\x0e2\x18.SC2APIProtocol.AllianceR\x08alliance\x12\x14\n\x05owner\
    \x18\x04\x20\x01(\x05R\x05owner\x12\x16\n\x06radius\x18\x05\x20\x01(\x02\
    R\x06radius\"\xfc\x01\n\tActionRaw\x12I\n\x0cunit_command\x18\x01\x20\
    \x01(\x0b2$.SC2APIProtocol.ActionRawUnitCommandH\0R\x0bunitCommand\x12F\
    \n\x0bcamera_move\x18\x02\x20\x01(\x0b2#.SC2APIProtocol.ActionRawCameraM\
    oveH\0R\ncameraMove\x12R\n\x0ftoggle_autocast\x18\x03\x20\x01(\x0b2'.SC2\
    APIProtocol.ActionRawToggleAutocastH\0R\x0etoggleAutocastB\x08\n\x06acti\
    on\"\xfb\x01\n\x14ActionRawUnitCommand\x12\x1d\n\nability_id\x18\x01\x20\
    \x01(\x05R\tabilityId\x12N\n\x16target_world_space_pos\x18\x02\x20\x01(\
    \x0b2\x17.SC2APIProtocol.Point2DH\0R\x13targetWorldSpacePos\x12(\n\x0fta\
    rget_unit_tag\x18\x03\x20\x01(\x04H\0R\rtargetUnitTag\x12\x1b\n\tunit_ta\
    gs\x18\x04\x20\x03(\x04R\x08unitTags\x12#\n\rqueue_command\x18\x05\x20\
    \x01(\x08R\x0cqueueCommandB\x08\n\x06target\"Z\n\x13ActionRawCameraMove\
    \x12C\n\x12center_world_space\x18\x01\x20\x01(\x0b2\x15.SC2APIProtocol.P\
    ointR\x10centerWorldSpace\"U\n\x17ActionRawToggleAutocast\x12\x1d\n\nabi\
    lity_id\x18\x01\x20\x01(\x05R\tabilityId\x12\x1b\n\tunit_tags\x18\x02\
    \x20\x03(\x04R\x08unitTags*E\n\x0bDisplayType\x12\x0b\n\x07Visible\x10\
    \x01\x12\x0c\n\x08Snapshot\x10\x02\x12\n\n\x06Hidden\x10\x03\x12\x0f\n\
    \x0bPlaceholder\x10\x04*6\n\x08Alliance\x12\x08\n\x04Self\x10\x01\x12\
    \x08\n\x04Ally\x10\x02\x12\x0b\n\x07Neutral\x10\x03\x12\t\n\x05Enemy\x10\
    \x04*e\n\nCloakState\x12\x12\n\x0eCloakedUnknown\x10\0\x12\x0b\n\x07Cloa\
    ked\x10\x01\x12\x13\n\x0fCloakedDetected\x10\x02\x12\x0e\n\nNotCloaked\
    \x10\x03\x12\x11\n\rCloakedAllied\x10\x04\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::common::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(StartRaw::generated_message_descriptor_data());
            messages.push(ObservationRaw::generated_message_descriptor_data());
            messages.push(RadarRing::generated_message_descriptor_data());
            messages.push(PowerSource::generated_message_descriptor_data());
            messages.push(PlayerRaw::generated_message_descriptor_data());
            messages.push(UnitOrder::generated_message_descriptor_data());
            messages.push(PassengerUnit::generated_message_descriptor_data());
            messages.push(RallyTarget::generated_message_descriptor_data());
            messages.push(Unit::generated_message_descriptor_data());
            messages.push(MapState::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(Effect::generated_message_descriptor_data());
            messages.push(ActionRaw::generated_message_descriptor_data());
            messages.push(ActionRawUnitCommand::generated_message_descriptor_data());
            messages.push(ActionRawCameraMove::generated_message_descriptor_data());
            messages.push(ActionRawToggleAutocast::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(DisplayType::generated_enum_descriptor_data());
            enums.push(Alliance::generated_enum_descriptor_data());
            enums.push(CloakState::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

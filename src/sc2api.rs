// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc 28.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/sc2api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:SC2APIProtocol.Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Request.id)
    pub id: ::std::option::Option<u32>,
    // message oneof groups
    pub request: ::std::option::Option<request::Request>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.RequestCreateGame create_game = 1;

    pub fn create_game(&self) -> &RequestCreateGame {
        match self.request {
            ::std::option::Option::Some(request::Request::CreateGame(ref v)) => v,
            _ => <RequestCreateGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_create_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::CreateGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_game(&mut self, v: RequestCreateGame) {
        self.request = ::std::option::Option::Some(request::Request::CreateGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_game(&mut self) -> &mut RequestCreateGame {
        if let ::std::option::Option::Some(request::Request::CreateGame(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::CreateGame(RequestCreateGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::CreateGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_game(&mut self) -> RequestCreateGame {
        if self.has_create_game() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::CreateGame(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestCreateGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestJoinGame join_game = 2;

    pub fn join_game(&self) -> &RequestJoinGame {
        match self.request {
            ::std::option::Option::Some(request::Request::JoinGame(ref v)) => v,
            _ => <RequestJoinGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_join_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::JoinGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: RequestJoinGame) {
        self.request = ::std::option::Option::Some(request::Request::JoinGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_join_game(&mut self) -> &mut RequestJoinGame {
        if let ::std::option::Option::Some(request::Request::JoinGame(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::JoinGame(RequestJoinGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::JoinGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_join_game(&mut self) -> RequestJoinGame {
        if self.has_join_game() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::JoinGame(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestJoinGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestRestartGame restart_game = 3;

    pub fn restart_game(&self) -> &RequestRestartGame {
        match self.request {
            ::std::option::Option::Some(request::Request::RestartGame(ref v)) => v,
            _ => <RequestRestartGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_restart_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_restart_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::RestartGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_game(&mut self, v: RequestRestartGame) {
        self.request = ::std::option::Option::Some(request::Request::RestartGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_restart_game(&mut self) -> &mut RequestRestartGame {
        if let ::std::option::Option::Some(request::Request::RestartGame(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::RestartGame(RequestRestartGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::RestartGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_restart_game(&mut self) -> RequestRestartGame {
        if self.has_restart_game() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::RestartGame(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestRestartGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestStartReplay start_replay = 4;

    pub fn start_replay(&self) -> &RequestStartReplay {
        match self.request {
            ::std::option::Option::Some(request::Request::StartReplay(ref v)) => v,
            _ => <RequestStartReplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_start_replay(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_start_replay(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::StartReplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_replay(&mut self, v: RequestStartReplay) {
        self.request = ::std::option::Option::Some(request::Request::StartReplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_replay(&mut self) -> &mut RequestStartReplay {
        if let ::std::option::Option::Some(request::Request::StartReplay(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::StartReplay(RequestStartReplay::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::StartReplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_replay(&mut self) -> RequestStartReplay {
        if self.has_start_replay() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::StartReplay(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestStartReplay::new()
        }
    }

    // optional .SC2APIProtocol.RequestLeaveGame leave_game = 5;

    pub fn leave_game(&self) -> &RequestLeaveGame {
        match self.request {
            ::std::option::Option::Some(request::Request::LeaveGame(ref v)) => v,
            _ => <RequestLeaveGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_leave_game(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_leave_game(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::LeaveGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_leave_game(&mut self, v: RequestLeaveGame) {
        self.request = ::std::option::Option::Some(request::Request::LeaveGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_leave_game(&mut self) -> &mut RequestLeaveGame {
        if let ::std::option::Option::Some(request::Request::LeaveGame(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::LeaveGame(RequestLeaveGame::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::LeaveGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_leave_game(&mut self) -> RequestLeaveGame {
        if self.has_leave_game() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::LeaveGame(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestLeaveGame::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuickSave quick_save = 6;

    pub fn quick_save(&self) -> &RequestQuickSave {
        match self.request {
            ::std::option::Option::Some(request::Request::QuickSave(ref v)) => v,
            _ => <RequestQuickSave as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quick_save(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_quick_save(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::QuickSave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_save(&mut self, v: RequestQuickSave) {
        self.request = ::std::option::Option::Some(request::Request::QuickSave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_save(&mut self) -> &mut RequestQuickSave {
        if let ::std::option::Option::Some(request::Request::QuickSave(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::QuickSave(RequestQuickSave::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::QuickSave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_save(&mut self) -> RequestQuickSave {
        if self.has_quick_save() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::QuickSave(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuickSave::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuickLoad quick_load = 7;

    pub fn quick_load(&self) -> &RequestQuickLoad {
        match self.request {
            ::std::option::Option::Some(request::Request::QuickLoad(ref v)) => v,
            _ => <RequestQuickLoad as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quick_load(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_quick_load(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::QuickLoad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_load(&mut self, v: RequestQuickLoad) {
        self.request = ::std::option::Option::Some(request::Request::QuickLoad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_load(&mut self) -> &mut RequestQuickLoad {
        if let ::std::option::Option::Some(request::Request::QuickLoad(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::QuickLoad(RequestQuickLoad::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::QuickLoad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_load(&mut self) -> RequestQuickLoad {
        if self.has_quick_load() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::QuickLoad(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuickLoad::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuit quit = 8;

    pub fn quit(&self) -> &RequestQuit {
        match self.request {
            ::std::option::Option::Some(request::Request::Quit(ref v)) => v,
            _ => <RequestQuit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quit(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_quit(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Quit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quit(&mut self, v: RequestQuit) {
        self.request = ::std::option::Option::Some(request::Request::Quit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quit(&mut self) -> &mut RequestQuit {
        if let ::std::option::Option::Some(request::Request::Quit(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Quit(RequestQuit::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Quit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quit(&mut self) -> RequestQuit {
        if self.has_quit() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Quit(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestQuit::new()
        }
    }

    // optional .SC2APIProtocol.RequestGameInfo game_info = 9;

    pub fn game_info(&self) -> &RequestGameInfo {
        match self.request {
            ::std::option::Option::Some(request::Request::GameInfo(ref v)) => v,
            _ => <RequestGameInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_game_info(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_game_info(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::GameInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_game_info(&mut self, v: RequestGameInfo) {
        self.request = ::std::option::Option::Some(request::Request::GameInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_game_info(&mut self) -> &mut RequestGameInfo {
        if let ::std::option::Option::Some(request::Request::GameInfo(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::GameInfo(RequestGameInfo::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::GameInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_game_info(&mut self) -> RequestGameInfo {
        if self.has_game_info() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::GameInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestGameInfo::new()
        }
    }

    // optional .SC2APIProtocol.RequestObservation observation = 10;

    pub fn observation(&self) -> &RequestObservation {
        match self.request {
            ::std::option::Option::Some(request::Request::Observation(ref v)) => v,
            _ => <RequestObservation as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_observation(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_observation(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Observation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observation(&mut self, v: RequestObservation) {
        self.request = ::std::option::Option::Some(request::Request::Observation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_observation(&mut self) -> &mut RequestObservation {
        if let ::std::option::Option::Some(request::Request::Observation(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Observation(RequestObservation::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Observation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_observation(&mut self) -> RequestObservation {
        if self.has_observation() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Observation(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestObservation::new()
        }
    }

    // optional .SC2APIProtocol.RequestAction action = 11;

    pub fn action(&self) -> &RequestAction {
        match self.request {
            ::std::option::Option::Some(request::Request::Action(ref v)) => v,
            _ => <RequestAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_action(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RequestAction) {
        self.request = ::std::option::Option::Some(request::Request::Action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action(&mut self) -> &mut RequestAction {
        if let ::std::option::Option::Some(request::Request::Action(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Action(RequestAction::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action(&mut self) -> RequestAction {
        if self.has_action() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Action(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestAction::new()
        }
    }

    // optional .SC2APIProtocol.RequestObserverAction obs_action = 21;

    pub fn obs_action(&self) -> &RequestObserverAction {
        match self.request {
            ::std::option::Option::Some(request::Request::ObsAction(ref v)) => v,
            _ => <RequestObserverAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_obs_action(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_obs_action(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::ObsAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_obs_action(&mut self, v: RequestObserverAction) {
        self.request = ::std::option::Option::Some(request::Request::ObsAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_obs_action(&mut self) -> &mut RequestObserverAction {
        if let ::std::option::Option::Some(request::Request::ObsAction(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::ObsAction(RequestObserverAction::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::ObsAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_obs_action(&mut self) -> RequestObserverAction {
        if self.has_obs_action() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::ObsAction(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestObserverAction::new()
        }
    }

    // optional .SC2APIProtocol.RequestStep step = 12;

    pub fn step(&self) -> &RequestStep {
        match self.request {
            ::std::option::Option::Some(request::Request::Step(ref v)) => v,
            _ => <RequestStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_step(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_step(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Step(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: RequestStep) {
        self.request = ::std::option::Option::Some(request::Request::Step(v))
    }

    // Mutable pointer to the field.
    pub fn mut_step(&mut self) -> &mut RequestStep {
        if let ::std::option::Option::Some(request::Request::Step(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Step(RequestStep::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Step(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_step(&mut self) -> RequestStep {
        if self.has_step() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Step(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestStep::new()
        }
    }

    // optional .SC2APIProtocol.RequestData data = 13;

    pub fn data(&self) -> &RequestData {
        match self.request {
            ::std::option::Option::Some(request::Request::Data(ref v)) => v,
            _ => <RequestData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_data(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: RequestData) {
        self.request = ::std::option::Option::Some(request::Request::Data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut RequestData {
        if let ::std::option::Option::Some(request::Request::Data(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Data(RequestData::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> RequestData {
        if self.has_data() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Data(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestData::new()
        }
    }

    // optional .SC2APIProtocol.RequestQuery query = 14;

    pub fn query(&self) -> &super::query::RequestQuery {
        match self.request {
            ::std::option::Option::Some(request::Request::Query(ref v)) => v,
            _ => <super::query::RequestQuery as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_query(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::query::RequestQuery) {
        self.request = ::std::option::Option::Some(request::Request::Query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut super::query::RequestQuery {
        if let ::std::option::Option::Some(request::Request::Query(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Query(super::query::RequestQuery::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> super::query::RequestQuery {
        if self.has_query() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Query(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::RequestQuery::new()
        }
    }

    // optional .SC2APIProtocol.RequestSaveReplay save_replay = 15;

    pub fn save_replay(&self) -> &RequestSaveReplay {
        match self.request {
            ::std::option::Option::Some(request::Request::SaveReplay(ref v)) => v,
            _ => <RequestSaveReplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_save_replay(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_save_replay(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::SaveReplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_replay(&mut self, v: RequestSaveReplay) {
        self.request = ::std::option::Option::Some(request::Request::SaveReplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_replay(&mut self) -> &mut RequestSaveReplay {
        if let ::std::option::Option::Some(request::Request::SaveReplay(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::SaveReplay(RequestSaveReplay::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::SaveReplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_replay(&mut self) -> RequestSaveReplay {
        if self.has_save_replay() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::SaveReplay(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestSaveReplay::new()
        }
    }

    // optional .SC2APIProtocol.RequestMapCommand map_command = 22;

    pub fn map_command(&self) -> &RequestMapCommand {
        match self.request {
            ::std::option::Option::Some(request::Request::MapCommand(ref v)) => v,
            _ => <RequestMapCommand as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_map_command(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_map_command(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::MapCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_command(&mut self, v: RequestMapCommand) {
        self.request = ::std::option::Option::Some(request::Request::MapCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_command(&mut self) -> &mut RequestMapCommand {
        if let ::std::option::Option::Some(request::Request::MapCommand(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::MapCommand(RequestMapCommand::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::MapCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_command(&mut self) -> RequestMapCommand {
        if self.has_map_command() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::MapCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestMapCommand::new()
        }
    }

    // optional .SC2APIProtocol.RequestReplayInfo replay_info = 16;

    pub fn replay_info(&self) -> &RequestReplayInfo {
        match self.request {
            ::std::option::Option::Some(request::Request::ReplayInfo(ref v)) => v,
            _ => <RequestReplayInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_replay_info(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_replay_info(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::ReplayInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_info(&mut self, v: RequestReplayInfo) {
        self.request = ::std::option::Option::Some(request::Request::ReplayInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_info(&mut self) -> &mut RequestReplayInfo {
        if let ::std::option::Option::Some(request::Request::ReplayInfo(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::ReplayInfo(RequestReplayInfo::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::ReplayInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_info(&mut self) -> RequestReplayInfo {
        if self.has_replay_info() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::ReplayInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestReplayInfo::new()
        }
    }

    // optional .SC2APIProtocol.RequestAvailableMaps available_maps = 17;

    pub fn available_maps(&self) -> &RequestAvailableMaps {
        match self.request {
            ::std::option::Option::Some(request::Request::AvailableMaps(ref v)) => v,
            _ => <RequestAvailableMaps as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_available_maps(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_available_maps(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::AvailableMaps(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_available_maps(&mut self, v: RequestAvailableMaps) {
        self.request = ::std::option::Option::Some(request::Request::AvailableMaps(v))
    }

    // Mutable pointer to the field.
    pub fn mut_available_maps(&mut self) -> &mut RequestAvailableMaps {
        if let ::std::option::Option::Some(request::Request::AvailableMaps(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::AvailableMaps(RequestAvailableMaps::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::AvailableMaps(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_available_maps(&mut self) -> RequestAvailableMaps {
        if self.has_available_maps() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::AvailableMaps(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestAvailableMaps::new()
        }
    }

    // optional .SC2APIProtocol.RequestSaveMap save_map = 18;

    pub fn save_map(&self) -> &RequestSaveMap {
        match self.request {
            ::std::option::Option::Some(request::Request::SaveMap(ref v)) => v,
            _ => <RequestSaveMap as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_save_map(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_save_map(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::SaveMap(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_map(&mut self, v: RequestSaveMap) {
        self.request = ::std::option::Option::Some(request::Request::SaveMap(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_map(&mut self) -> &mut RequestSaveMap {
        if let ::std::option::Option::Some(request::Request::SaveMap(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::SaveMap(RequestSaveMap::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::SaveMap(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_map(&mut self) -> RequestSaveMap {
        if self.has_save_map() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::SaveMap(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestSaveMap::new()
        }
    }

    // optional .SC2APIProtocol.RequestPing ping = 19;

    pub fn ping(&self) -> &RequestPing {
        match self.request {
            ::std::option::Option::Some(request::Request::Ping(ref v)) => v,
            _ => <RequestPing as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: RequestPing) {
        self.request = ::std::option::Option::Some(request::Request::Ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut RequestPing {
        if let ::std::option::Option::Some(request::Request::Ping(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Ping(RequestPing::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> RequestPing {
        if self.has_ping() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Ping(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestPing::new()
        }
    }

    // optional .SC2APIProtocol.RequestDebug debug = 20;

    pub fn debug(&self) -> &RequestDebug {
        match self.request {
            ::std::option::Option::Some(request::Request::Debug(ref v)) => v,
            _ => <RequestDebug as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_debug(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(request::Request::Debug(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: RequestDebug) {
        self.request = ::std::option::Option::Some(request::Request::Debug(v))
    }

    // Mutable pointer to the field.
    pub fn mut_debug(&mut self) -> &mut RequestDebug {
        if let ::std::option::Option::Some(request::Request::Debug(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(request::Request::Debug(RequestDebug::new()));
        }
        match self.request {
            ::std::option::Option::Some(request::Request::Debug(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_debug(&mut self) -> RequestDebug {
        if self.has_debug() {
            match self.request.take() {
                ::std::option::Option::Some(request::Request::Debug(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestDebug::new()
        }
    }

    // optional uint32 id = 97;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestCreateGame>(
            "create_game",
            Request::has_create_game,
            Request::create_game,
            Request::mut_create_game,
            Request::set_create_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestJoinGame>(
            "join_game",
            Request::has_join_game,
            Request::join_game,
            Request::mut_join_game,
            Request::set_join_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestRestartGame>(
            "restart_game",
            Request::has_restart_game,
            Request::restart_game,
            Request::mut_restart_game,
            Request::set_restart_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestStartReplay>(
            "start_replay",
            Request::has_start_replay,
            Request::start_replay,
            Request::mut_start_replay,
            Request::set_start_replay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestLeaveGame>(
            "leave_game",
            Request::has_leave_game,
            Request::leave_game,
            Request::mut_leave_game,
            Request::set_leave_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestQuickSave>(
            "quick_save",
            Request::has_quick_save,
            Request::quick_save,
            Request::mut_quick_save,
            Request::set_quick_save,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestQuickLoad>(
            "quick_load",
            Request::has_quick_load,
            Request::quick_load,
            Request::mut_quick_load,
            Request::set_quick_load,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestQuit>(
            "quit",
            Request::has_quit,
            Request::quit,
            Request::mut_quit,
            Request::set_quit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestGameInfo>(
            "game_info",
            Request::has_game_info,
            Request::game_info,
            Request::mut_game_info,
            Request::set_game_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestObservation>(
            "observation",
            Request::has_observation,
            Request::observation,
            Request::mut_observation,
            Request::set_observation,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestAction>(
            "action",
            Request::has_action,
            Request::action,
            Request::mut_action,
            Request::set_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestObserverAction>(
            "obs_action",
            Request::has_obs_action,
            Request::obs_action,
            Request::mut_obs_action,
            Request::set_obs_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestStep>(
            "step",
            Request::has_step,
            Request::step,
            Request::mut_step,
            Request::set_step,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestData>(
            "data",
            Request::has_data,
            Request::data,
            Request::mut_data,
            Request::set_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::query::RequestQuery>(
            "query",
            Request::has_query,
            Request::query,
            Request::mut_query,
            Request::set_query,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestSaveReplay>(
            "save_replay",
            Request::has_save_replay,
            Request::save_replay,
            Request::mut_save_replay,
            Request::set_save_replay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestMapCommand>(
            "map_command",
            Request::has_map_command,
            Request::map_command,
            Request::mut_map_command,
            Request::set_map_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestReplayInfo>(
            "replay_info",
            Request::has_replay_info,
            Request::replay_info,
            Request::mut_replay_info,
            Request::set_replay_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestAvailableMaps>(
            "available_maps",
            Request::has_available_maps,
            Request::available_maps,
            Request::mut_available_maps,
            Request::set_available_maps,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestSaveMap>(
            "save_map",
            Request::has_save_map,
            Request::save_map,
            Request::mut_save_map,
            Request::set_save_map,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestPing>(
            "ping",
            Request::has_ping,
            Request::ping,
            Request::mut_ping,
            Request::set_ping,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RequestDebug>(
            "debug",
            Request::has_debug,
            Request::debug,
            Request::mut_debug,
            Request::set_debug,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Request| { &m.id },
            |m: &mut Request| { &mut m.id },
        ));
        oneofs.push(request::Request::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Request>(
            "Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Request {
    const NAME: &'static str = "Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request = ::std::option::Option::Some(request::Request::CreateGame(is.read_message()?));
                },
                18 => {
                    self.request = ::std::option::Option::Some(request::Request::JoinGame(is.read_message()?));
                },
                26 => {
                    self.request = ::std::option::Option::Some(request::Request::RestartGame(is.read_message()?));
                },
                34 => {
                    self.request = ::std::option::Option::Some(request::Request::StartReplay(is.read_message()?));
                },
                42 => {
                    self.request = ::std::option::Option::Some(request::Request::LeaveGame(is.read_message()?));
                },
                50 => {
                    self.request = ::std::option::Option::Some(request::Request::QuickSave(is.read_message()?));
                },
                58 => {
                    self.request = ::std::option::Option::Some(request::Request::QuickLoad(is.read_message()?));
                },
                66 => {
                    self.request = ::std::option::Option::Some(request::Request::Quit(is.read_message()?));
                },
                74 => {
                    self.request = ::std::option::Option::Some(request::Request::GameInfo(is.read_message()?));
                },
                82 => {
                    self.request = ::std::option::Option::Some(request::Request::Observation(is.read_message()?));
                },
                90 => {
                    self.request = ::std::option::Option::Some(request::Request::Action(is.read_message()?));
                },
                170 => {
                    self.request = ::std::option::Option::Some(request::Request::ObsAction(is.read_message()?));
                },
                98 => {
                    self.request = ::std::option::Option::Some(request::Request::Step(is.read_message()?));
                },
                106 => {
                    self.request = ::std::option::Option::Some(request::Request::Data(is.read_message()?));
                },
                114 => {
                    self.request = ::std::option::Option::Some(request::Request::Query(is.read_message()?));
                },
                122 => {
                    self.request = ::std::option::Option::Some(request::Request::SaveReplay(is.read_message()?));
                },
                178 => {
                    self.request = ::std::option::Option::Some(request::Request::MapCommand(is.read_message()?));
                },
                130 => {
                    self.request = ::std::option::Option::Some(request::Request::ReplayInfo(is.read_message()?));
                },
                138 => {
                    self.request = ::std::option::Option::Some(request::Request::AvailableMaps(is.read_message()?));
                },
                146 => {
                    self.request = ::std::option::Option::Some(request::Request::SaveMap(is.read_message()?));
                },
                154 => {
                    self.request = ::std::option::Option::Some(request::Request::Ping(is.read_message()?));
                },
                162 => {
                    self.request = ::std::option::Option::Some(request::Request::Debug(is.read_message()?));
                },
                776 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(97, v);
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &request::Request::CreateGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::JoinGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::RestartGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::StartReplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::LeaveGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::QuickSave(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::QuickLoad(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Quit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::GameInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Observation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Action(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::ObsAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Step(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::SaveReplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::MapCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::ReplayInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::AvailableMaps(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::SaveMap(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request::Request::Debug(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(97, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &request::Request::CreateGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &request::Request::JoinGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &request::Request::RestartGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &request::Request::StartReplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &request::Request::LeaveGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &request::Request::QuickSave(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &request::Request::QuickLoad(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &request::Request::Quit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &request::Request::GameInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &request::Request::Observation(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &request::Request::Action(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &request::Request::ObsAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &request::Request::Step(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &request::Request::Data(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &request::Request::Query(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &request::Request::SaveReplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &request::Request::MapCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &request::Request::ReplayInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &request::Request::AvailableMaps(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &request::Request::SaveMap(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &request::Request::Ping(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &request::Request::Debug(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Request {
        Request::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Request {
        static instance: Request = Request {
            id: ::std::option::Option::None,
            request: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Request`
pub mod request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.Request.request)
    pub enum Request {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.create_game)
        CreateGame(super::RequestCreateGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.join_game)
        JoinGame(super::RequestJoinGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.restart_game)
        RestartGame(super::RequestRestartGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.start_replay)
        StartReplay(super::RequestStartReplay),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.leave_game)
        LeaveGame(super::RequestLeaveGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.quick_save)
        QuickSave(super::RequestQuickSave),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.quick_load)
        QuickLoad(super::RequestQuickLoad),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.quit)
        Quit(super::RequestQuit),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.game_info)
        GameInfo(super::RequestGameInfo),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.observation)
        Observation(super::RequestObservation),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.action)
        Action(super::RequestAction),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.obs_action)
        ObsAction(super::RequestObserverAction),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.step)
        Step(super::RequestStep),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.data)
        Data(super::RequestData),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.query)
        Query(super::super::query::RequestQuery),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.save_replay)
        SaveReplay(super::RequestSaveReplay),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.map_command)
        MapCommand(super::RequestMapCommand),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.replay_info)
        ReplayInfo(super::RequestReplayInfo),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.available_maps)
        AvailableMaps(super::RequestAvailableMaps),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.save_map)
        SaveMap(super::RequestSaveMap),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.ping)
        Ping(super::RequestPing),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Request.debug)
        Debug(super::RequestDebug),
    }

    impl ::protobuf::Oneof for Request {
    }

    impl ::protobuf::OneofFull for Request {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Request as ::protobuf::MessageFull>::descriptor().oneof_by_name("request").unwrap()).clone()
        }
    }

    impl Request {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request>("request")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Response.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Response.error)
    pub error: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Response.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<Status>>,
    // message oneof groups
    pub response: ::std::option::Option<response::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseCreateGame create_game = 1;

    pub fn create_game(&self) -> &ResponseCreateGame {
        match self.response {
            ::std::option::Option::Some(response::Response::CreateGame(ref v)) => v,
            _ => <ResponseCreateGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_create_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_create_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::CreateGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_game(&mut self, v: ResponseCreateGame) {
        self.response = ::std::option::Option::Some(response::Response::CreateGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_game(&mut self) -> &mut ResponseCreateGame {
        if let ::std::option::Option::Some(response::Response::CreateGame(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::CreateGame(ResponseCreateGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::CreateGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_game(&mut self) -> ResponseCreateGame {
        if self.has_create_game() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::CreateGame(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseCreateGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseJoinGame join_game = 2;

    pub fn join_game(&self) -> &ResponseJoinGame {
        match self.response {
            ::std::option::Option::Some(response::Response::JoinGame(ref v)) => v,
            _ => <ResponseJoinGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_join_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::JoinGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: ResponseJoinGame) {
        self.response = ::std::option::Option::Some(response::Response::JoinGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_join_game(&mut self) -> &mut ResponseJoinGame {
        if let ::std::option::Option::Some(response::Response::JoinGame(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::JoinGame(ResponseJoinGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::JoinGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_join_game(&mut self) -> ResponseJoinGame {
        if self.has_join_game() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::JoinGame(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseJoinGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseRestartGame restart_game = 3;

    pub fn restart_game(&self) -> &ResponseRestartGame {
        match self.response {
            ::std::option::Option::Some(response::Response::RestartGame(ref v)) => v,
            _ => <ResponseRestartGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_restart_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_restart_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::RestartGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_restart_game(&mut self, v: ResponseRestartGame) {
        self.response = ::std::option::Option::Some(response::Response::RestartGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_restart_game(&mut self) -> &mut ResponseRestartGame {
        if let ::std::option::Option::Some(response::Response::RestartGame(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::RestartGame(ResponseRestartGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::RestartGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_restart_game(&mut self) -> ResponseRestartGame {
        if self.has_restart_game() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::RestartGame(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseRestartGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseStartReplay start_replay = 4;

    pub fn start_replay(&self) -> &ResponseStartReplay {
        match self.response {
            ::std::option::Option::Some(response::Response::StartReplay(ref v)) => v,
            _ => <ResponseStartReplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_start_replay(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_start_replay(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::StartReplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start_replay(&mut self, v: ResponseStartReplay) {
        self.response = ::std::option::Option::Some(response::Response::StartReplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start_replay(&mut self) -> &mut ResponseStartReplay {
        if let ::std::option::Option::Some(response::Response::StartReplay(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::StartReplay(ResponseStartReplay::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::StartReplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start_replay(&mut self) -> ResponseStartReplay {
        if self.has_start_replay() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::StartReplay(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseStartReplay::new()
        }
    }

    // optional .SC2APIProtocol.ResponseLeaveGame leave_game = 5;

    pub fn leave_game(&self) -> &ResponseLeaveGame {
        match self.response {
            ::std::option::Option::Some(response::Response::LeaveGame(ref v)) => v,
            _ => <ResponseLeaveGame as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_leave_game(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_leave_game(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::LeaveGame(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_leave_game(&mut self, v: ResponseLeaveGame) {
        self.response = ::std::option::Option::Some(response::Response::LeaveGame(v))
    }

    // Mutable pointer to the field.
    pub fn mut_leave_game(&mut self) -> &mut ResponseLeaveGame {
        if let ::std::option::Option::Some(response::Response::LeaveGame(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::LeaveGame(ResponseLeaveGame::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::LeaveGame(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_leave_game(&mut self) -> ResponseLeaveGame {
        if self.has_leave_game() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::LeaveGame(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseLeaveGame::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuickSave quick_save = 6;

    pub fn quick_save(&self) -> &ResponseQuickSave {
        match self.response {
            ::std::option::Option::Some(response::Response::QuickSave(ref v)) => v,
            _ => <ResponseQuickSave as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quick_save(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_quick_save(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::QuickSave(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_save(&mut self, v: ResponseQuickSave) {
        self.response = ::std::option::Option::Some(response::Response::QuickSave(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_save(&mut self) -> &mut ResponseQuickSave {
        if let ::std::option::Option::Some(response::Response::QuickSave(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::QuickSave(ResponseQuickSave::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::QuickSave(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_save(&mut self) -> ResponseQuickSave {
        if self.has_quick_save() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::QuickSave(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuickSave::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuickLoad quick_load = 7;

    pub fn quick_load(&self) -> &ResponseQuickLoad {
        match self.response {
            ::std::option::Option::Some(response::Response::QuickLoad(ref v)) => v,
            _ => <ResponseQuickLoad as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quick_load(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_quick_load(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::QuickLoad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quick_load(&mut self, v: ResponseQuickLoad) {
        self.response = ::std::option::Option::Some(response::Response::QuickLoad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quick_load(&mut self) -> &mut ResponseQuickLoad {
        if let ::std::option::Option::Some(response::Response::QuickLoad(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::QuickLoad(ResponseQuickLoad::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::QuickLoad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quick_load(&mut self) -> ResponseQuickLoad {
        if self.has_quick_load() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::QuickLoad(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuickLoad::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuit quit = 8;

    pub fn quit(&self) -> &ResponseQuit {
        match self.response {
            ::std::option::Option::Some(response::Response::Quit(ref v)) => v,
            _ => <ResponseQuit as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quit(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_quit(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Quit(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quit(&mut self, v: ResponseQuit) {
        self.response = ::std::option::Option::Some(response::Response::Quit(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quit(&mut self) -> &mut ResponseQuit {
        if let ::std::option::Option::Some(response::Response::Quit(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Quit(ResponseQuit::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Quit(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quit(&mut self) -> ResponseQuit {
        if self.has_quit() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Quit(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseQuit::new()
        }
    }

    // optional .SC2APIProtocol.ResponseGameInfo game_info = 9;

    pub fn game_info(&self) -> &ResponseGameInfo {
        match self.response {
            ::std::option::Option::Some(response::Response::GameInfo(ref v)) => v,
            _ => <ResponseGameInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_game_info(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_game_info(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::GameInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_game_info(&mut self, v: ResponseGameInfo) {
        self.response = ::std::option::Option::Some(response::Response::GameInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_game_info(&mut self) -> &mut ResponseGameInfo {
        if let ::std::option::Option::Some(response::Response::GameInfo(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::GameInfo(ResponseGameInfo::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::GameInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_game_info(&mut self) -> ResponseGameInfo {
        if self.has_game_info() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::GameInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseGameInfo::new()
        }
    }

    // optional .SC2APIProtocol.ResponseObservation observation = 10;

    pub fn observation(&self) -> &ResponseObservation {
        match self.response {
            ::std::option::Option::Some(response::Response::Observation(ref v)) => v,
            _ => <ResponseObservation as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_observation(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_observation(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Observation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observation(&mut self, v: ResponseObservation) {
        self.response = ::std::option::Option::Some(response::Response::Observation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_observation(&mut self) -> &mut ResponseObservation {
        if let ::std::option::Option::Some(response::Response::Observation(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Observation(ResponseObservation::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Observation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_observation(&mut self) -> ResponseObservation {
        if self.has_observation() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Observation(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseObservation::new()
        }
    }

    // optional .SC2APIProtocol.ResponseAction action = 11;

    pub fn action(&self) -> &ResponseAction {
        match self.response {
            ::std::option::Option::Some(response::Response::Action(ref v)) => v,
            _ => <ResponseAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_action(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ResponseAction) {
        self.response = ::std::option::Option::Some(response::Response::Action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_action(&mut self) -> &mut ResponseAction {
        if let ::std::option::Option::Some(response::Response::Action(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Action(ResponseAction::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_action(&mut self) -> ResponseAction {
        if self.has_action() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Action(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseAction::new()
        }
    }

    // optional .SC2APIProtocol.ResponseObserverAction obs_action = 21;

    pub fn obs_action(&self) -> &ResponseObserverAction {
        match self.response {
            ::std::option::Option::Some(response::Response::ObsAction(ref v)) => v,
            _ => <ResponseObserverAction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_obs_action(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_obs_action(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::ObsAction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_obs_action(&mut self, v: ResponseObserverAction) {
        self.response = ::std::option::Option::Some(response::Response::ObsAction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_obs_action(&mut self) -> &mut ResponseObserverAction {
        if let ::std::option::Option::Some(response::Response::ObsAction(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::ObsAction(ResponseObserverAction::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::ObsAction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_obs_action(&mut self) -> ResponseObserverAction {
        if self.has_obs_action() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::ObsAction(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseObserverAction::new()
        }
    }

    // optional .SC2APIProtocol.ResponseStep step = 12;

    pub fn step(&self) -> &ResponseStep {
        match self.response {
            ::std::option::Option::Some(response::Response::Step(ref v)) => v,
            _ => <ResponseStep as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_step(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_step(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Step(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: ResponseStep) {
        self.response = ::std::option::Option::Some(response::Response::Step(v))
    }

    // Mutable pointer to the field.
    pub fn mut_step(&mut self) -> &mut ResponseStep {
        if let ::std::option::Option::Some(response::Response::Step(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Step(ResponseStep::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Step(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_step(&mut self) -> ResponseStep {
        if self.has_step() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Step(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseStep::new()
        }
    }

    // optional .SC2APIProtocol.ResponseData data = 13;

    pub fn data(&self) -> &ResponseData {
        match self.response {
            ::std::option::Option::Some(response::Response::Data(ref v)) => v,
            _ => <ResponseData as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_data(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ResponseData) {
        self.response = ::std::option::Option::Some(response::Response::Data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ResponseData {
        if let ::std::option::Option::Some(response::Response::Data(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Data(ResponseData::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> ResponseData {
        if self.has_data() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Data(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseData::new()
        }
    }

    // optional .SC2APIProtocol.ResponseQuery query = 14;

    pub fn query(&self) -> &super::query::ResponseQuery {
        match self.response {
            ::std::option::Option::Some(response::Response::Query(ref v)) => v,
            _ => <super::query::ResponseQuery as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_query(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: super::query::ResponseQuery) {
        self.response = ::std::option::Option::Some(response::Response::Query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut super::query::ResponseQuery {
        if let ::std::option::Option::Some(response::Response::Query(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Query(super::query::ResponseQuery::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> super::query::ResponseQuery {
        if self.has_query() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Query(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::ResponseQuery::new()
        }
    }

    // optional .SC2APIProtocol.ResponseSaveReplay save_replay = 15;

    pub fn save_replay(&self) -> &ResponseSaveReplay {
        match self.response {
            ::std::option::Option::Some(response::Response::SaveReplay(ref v)) => v,
            _ => <ResponseSaveReplay as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_save_replay(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_save_replay(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::SaveReplay(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_replay(&mut self, v: ResponseSaveReplay) {
        self.response = ::std::option::Option::Some(response::Response::SaveReplay(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_replay(&mut self) -> &mut ResponseSaveReplay {
        if let ::std::option::Option::Some(response::Response::SaveReplay(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::SaveReplay(ResponseSaveReplay::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::SaveReplay(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_replay(&mut self) -> ResponseSaveReplay {
        if self.has_save_replay() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::SaveReplay(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseSaveReplay::new()
        }
    }

    // optional .SC2APIProtocol.ResponseReplayInfo replay_info = 16;

    pub fn replay_info(&self) -> &ResponseReplayInfo {
        match self.response {
            ::std::option::Option::Some(response::Response::ReplayInfo(ref v)) => v,
            _ => <ResponseReplayInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_replay_info(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_replay_info(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::ReplayInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_info(&mut self, v: ResponseReplayInfo) {
        self.response = ::std::option::Option::Some(response::Response::ReplayInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_info(&mut self) -> &mut ResponseReplayInfo {
        if let ::std::option::Option::Some(response::Response::ReplayInfo(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::ReplayInfo(ResponseReplayInfo::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::ReplayInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_info(&mut self) -> ResponseReplayInfo {
        if self.has_replay_info() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::ReplayInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseReplayInfo::new()
        }
    }

    // optional .SC2APIProtocol.ResponseAvailableMaps available_maps = 17;

    pub fn available_maps(&self) -> &ResponseAvailableMaps {
        match self.response {
            ::std::option::Option::Some(response::Response::AvailableMaps(ref v)) => v,
            _ => <ResponseAvailableMaps as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_available_maps(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_available_maps(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::AvailableMaps(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_available_maps(&mut self, v: ResponseAvailableMaps) {
        self.response = ::std::option::Option::Some(response::Response::AvailableMaps(v))
    }

    // Mutable pointer to the field.
    pub fn mut_available_maps(&mut self) -> &mut ResponseAvailableMaps {
        if let ::std::option::Option::Some(response::Response::AvailableMaps(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::AvailableMaps(ResponseAvailableMaps::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::AvailableMaps(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_available_maps(&mut self) -> ResponseAvailableMaps {
        if self.has_available_maps() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::AvailableMaps(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseAvailableMaps::new()
        }
    }

    // optional .SC2APIProtocol.ResponseSaveMap save_map = 18;

    pub fn save_map(&self) -> &ResponseSaveMap {
        match self.response {
            ::std::option::Option::Some(response::Response::SaveMap(ref v)) => v,
            _ => <ResponseSaveMap as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_save_map(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_save_map(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::SaveMap(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_save_map(&mut self, v: ResponseSaveMap) {
        self.response = ::std::option::Option::Some(response::Response::SaveMap(v))
    }

    // Mutable pointer to the field.
    pub fn mut_save_map(&mut self) -> &mut ResponseSaveMap {
        if let ::std::option::Option::Some(response::Response::SaveMap(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::SaveMap(ResponseSaveMap::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::SaveMap(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_save_map(&mut self) -> ResponseSaveMap {
        if self.has_save_map() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::SaveMap(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseSaveMap::new()
        }
    }

    // optional .SC2APIProtocol.ResponseMapCommand map_command = 22;

    pub fn map_command(&self) -> &ResponseMapCommand {
        match self.response {
            ::std::option::Option::Some(response::Response::MapCommand(ref v)) => v,
            _ => <ResponseMapCommand as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_map_command(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_map_command(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::MapCommand(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_command(&mut self, v: ResponseMapCommand) {
        self.response = ::std::option::Option::Some(response::Response::MapCommand(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_command(&mut self) -> &mut ResponseMapCommand {
        if let ::std::option::Option::Some(response::Response::MapCommand(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::MapCommand(ResponseMapCommand::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::MapCommand(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_command(&mut self) -> ResponseMapCommand {
        if self.has_map_command() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::MapCommand(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseMapCommand::new()
        }
    }

    // optional .SC2APIProtocol.ResponsePing ping = 19;

    pub fn ping(&self) -> &ResponsePing {
        match self.response {
            ::std::option::Option::Some(response::Response::Ping(ref v)) => v,
            _ => <ResponsePing as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: ResponsePing) {
        self.response = ::std::option::Option::Some(response::Response::Ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut ResponsePing {
        if let ::std::option::Option::Some(response::Response::Ping(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Ping(ResponsePing::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> ResponsePing {
        if self.has_ping() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Ping(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponsePing::new()
        }
    }

    // optional .SC2APIProtocol.ResponseDebug debug = 20;

    pub fn debug(&self) -> &ResponseDebug {
        match self.response {
            ::std::option::Option::Some(response::Response::Debug(ref v)) => v,
            _ => <ResponseDebug as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_debug(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(response::Response::Debug(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: ResponseDebug) {
        self.response = ::std::option::Option::Some(response::Response::Debug(v))
    }

    // Mutable pointer to the field.
    pub fn mut_debug(&mut self) -> &mut ResponseDebug {
        if let ::std::option::Option::Some(response::Response::Debug(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(response::Response::Debug(ResponseDebug::new()));
        }
        match self.response {
            ::std::option::Option::Some(response::Response::Debug(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_debug(&mut self) -> ResponseDebug {
        if self.has_debug() {
            match self.response.take() {
                ::std::option::Option::Some(response::Response::Debug(v)) => v,
                _ => panic!(),
            }
        } else {
            ResponseDebug::new()
        }
    }

    // optional uint32 id = 97;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Status status = 99;

    pub fn status(&self) -> Status {
        match self.status {
            Some(e) => e.enum_value_or(Status::launched),
            None => Status::launched,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseCreateGame>(
            "create_game",
            Response::has_create_game,
            Response::create_game,
            Response::mut_create_game,
            Response::set_create_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseJoinGame>(
            "join_game",
            Response::has_join_game,
            Response::join_game,
            Response::mut_join_game,
            Response::set_join_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseRestartGame>(
            "restart_game",
            Response::has_restart_game,
            Response::restart_game,
            Response::mut_restart_game,
            Response::set_restart_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseStartReplay>(
            "start_replay",
            Response::has_start_replay,
            Response::start_replay,
            Response::mut_start_replay,
            Response::set_start_replay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseLeaveGame>(
            "leave_game",
            Response::has_leave_game,
            Response::leave_game,
            Response::mut_leave_game,
            Response::set_leave_game,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseQuickSave>(
            "quick_save",
            Response::has_quick_save,
            Response::quick_save,
            Response::mut_quick_save,
            Response::set_quick_save,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseQuickLoad>(
            "quick_load",
            Response::has_quick_load,
            Response::quick_load,
            Response::mut_quick_load,
            Response::set_quick_load,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseQuit>(
            "quit",
            Response::has_quit,
            Response::quit,
            Response::mut_quit,
            Response::set_quit,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseGameInfo>(
            "game_info",
            Response::has_game_info,
            Response::game_info,
            Response::mut_game_info,
            Response::set_game_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseObservation>(
            "observation",
            Response::has_observation,
            Response::observation,
            Response::mut_observation,
            Response::set_observation,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseAction>(
            "action",
            Response::has_action,
            Response::action,
            Response::mut_action,
            Response::set_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseObserverAction>(
            "obs_action",
            Response::has_obs_action,
            Response::obs_action,
            Response::mut_obs_action,
            Response::set_obs_action,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseStep>(
            "step",
            Response::has_step,
            Response::step,
            Response::mut_step,
            Response::set_step,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseData>(
            "data",
            Response::has_data,
            Response::data,
            Response::mut_data,
            Response::set_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::query::ResponseQuery>(
            "query",
            Response::has_query,
            Response::query,
            Response::mut_query,
            Response::set_query,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseSaveReplay>(
            "save_replay",
            Response::has_save_replay,
            Response::save_replay,
            Response::mut_save_replay,
            Response::set_save_replay,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseReplayInfo>(
            "replay_info",
            Response::has_replay_info,
            Response::replay_info,
            Response::mut_replay_info,
            Response::set_replay_info,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseAvailableMaps>(
            "available_maps",
            Response::has_available_maps,
            Response::available_maps,
            Response::mut_available_maps,
            Response::set_available_maps,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseSaveMap>(
            "save_map",
            Response::has_save_map,
            Response::save_map,
            Response::mut_save_map,
            Response::set_save_map,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseMapCommand>(
            "map_command",
            Response::has_map_command,
            Response::map_command,
            Response::mut_map_command,
            Response::set_map_command,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponsePing>(
            "ping",
            Response::has_ping,
            Response::ping,
            Response::mut_ping,
            Response::set_ping,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ResponseDebug>(
            "debug",
            Response::has_debug,
            Response::debug,
            Response::mut_debug,
            Response::set_debug,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Response| { &m.id },
            |m: &mut Response| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "error",
            |m: &Response| { &m.error },
            |m: &mut Response| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &Response| { &m.status },
            |m: &mut Response| { &mut m.status },
        ));
        oneofs.push(response::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Response>(
            "Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Response {
    const NAME: &'static str = "Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(response::Response::CreateGame(is.read_message()?));
                },
                18 => {
                    self.response = ::std::option::Option::Some(response::Response::JoinGame(is.read_message()?));
                },
                26 => {
                    self.response = ::std::option::Option::Some(response::Response::RestartGame(is.read_message()?));
                },
                34 => {
                    self.response = ::std::option::Option::Some(response::Response::StartReplay(is.read_message()?));
                },
                42 => {
                    self.response = ::std::option::Option::Some(response::Response::LeaveGame(is.read_message()?));
                },
                50 => {
                    self.response = ::std::option::Option::Some(response::Response::QuickSave(is.read_message()?));
                },
                58 => {
                    self.response = ::std::option::Option::Some(response::Response::QuickLoad(is.read_message()?));
                },
                66 => {
                    self.response = ::std::option::Option::Some(response::Response::Quit(is.read_message()?));
                },
                74 => {
                    self.response = ::std::option::Option::Some(response::Response::GameInfo(is.read_message()?));
                },
                82 => {
                    self.response = ::std::option::Option::Some(response::Response::Observation(is.read_message()?));
                },
                90 => {
                    self.response = ::std::option::Option::Some(response::Response::Action(is.read_message()?));
                },
                170 => {
                    self.response = ::std::option::Option::Some(response::Response::ObsAction(is.read_message()?));
                },
                98 => {
                    self.response = ::std::option::Option::Some(response::Response::Step(is.read_message()?));
                },
                106 => {
                    self.response = ::std::option::Option::Some(response::Response::Data(is.read_message()?));
                },
                114 => {
                    self.response = ::std::option::Option::Some(response::Response::Query(is.read_message()?));
                },
                122 => {
                    self.response = ::std::option::Option::Some(response::Response::SaveReplay(is.read_message()?));
                },
                130 => {
                    self.response = ::std::option::Option::Some(response::Response::ReplayInfo(is.read_message()?));
                },
                138 => {
                    self.response = ::std::option::Option::Some(response::Response::AvailableMaps(is.read_message()?));
                },
                146 => {
                    self.response = ::std::option::Option::Some(response::Response::SaveMap(is.read_message()?));
                },
                178 => {
                    self.response = ::std::option::Option::Some(response::Response::MapCommand(is.read_message()?));
                },
                154 => {
                    self.response = ::std::option::Option::Some(response::Response::Ping(is.read_message()?));
                },
                162 => {
                    self.response = ::std::option::Option::Some(response::Response::Debug(is.read_message()?));
                },
                776 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                786 => {
                    self.error.push(is.read_string()?);
                },
                792 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(97, v);
        }
        for value in &self.error {
            my_size += ::protobuf::rt::string_size(98, &value);
        };
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(99, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &response::Response::CreateGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::JoinGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::RestartGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::StartReplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::LeaveGame(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::QuickSave(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::QuickLoad(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Quit(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::GameInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Observation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Action(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::ObsAction(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Step(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::SaveReplay(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::ReplayInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::AvailableMaps(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::SaveMap(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::MapCommand(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &response::Response::Debug(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(97, v)?;
        }
        for v in &self.error {
            os.write_string(98, &v)?;
        };
        if let Some(v) = self.status {
            os.write_enum(99, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &response::Response::CreateGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &response::Response::JoinGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &response::Response::RestartGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &response::Response::StartReplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &response::Response::LeaveGame(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &response::Response::QuickSave(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &response::Response::QuickLoad(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &response::Response::Quit(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &response::Response::GameInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &response::Response::Observation(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &response::Response::Action(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &response::Response::ObsAction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
                },
                &response::Response::Step(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &response::Response::Data(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &response::Response::Query(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &response::Response::SaveReplay(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &response::Response::ReplayInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
                &response::Response::AvailableMaps(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
                },
                &response::Response::SaveMap(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
                },
                &response::Response::MapCommand(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
                },
                &response::Response::Ping(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
                },
                &response::Response::Debug(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Response {
        Response::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.error.clear();
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Response {
        static instance: Response = Response {
            id: ::std::option::Option::None,
            error: ::std::vec::Vec::new(),
            status: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Response`
pub mod response {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.Response.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.create_game)
        CreateGame(super::ResponseCreateGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.join_game)
        JoinGame(super::ResponseJoinGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.restart_game)
        RestartGame(super::ResponseRestartGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.start_replay)
        StartReplay(super::ResponseStartReplay),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.leave_game)
        LeaveGame(super::ResponseLeaveGame),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.quick_save)
        QuickSave(super::ResponseQuickSave),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.quick_load)
        QuickLoad(super::ResponseQuickLoad),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.quit)
        Quit(super::ResponseQuit),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.game_info)
        GameInfo(super::ResponseGameInfo),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.observation)
        Observation(super::ResponseObservation),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.action)
        Action(super::ResponseAction),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.obs_action)
        ObsAction(super::ResponseObserverAction),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.step)
        Step(super::ResponseStep),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.data)
        Data(super::ResponseData),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.query)
        Query(super::super::query::ResponseQuery),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.save_replay)
        SaveReplay(super::ResponseSaveReplay),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.replay_info)
        ReplayInfo(super::ResponseReplayInfo),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.available_maps)
        AvailableMaps(super::ResponseAvailableMaps),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.save_map)
        SaveMap(super::ResponseSaveMap),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.map_command)
        MapCommand(super::ResponseMapCommand),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.ping)
        Ping(super::ResponsePing),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.Response.debug)
        Debug(super::ResponseDebug),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Response as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestCreateGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestCreateGame {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestCreateGame.player_setup)
    pub player_setup: ::std::vec::Vec<PlayerSetup>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestCreateGame.disable_fog)
    pub disable_fog: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestCreateGame.random_seed)
    pub random_seed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestCreateGame.realtime)
    pub realtime: ::std::option::Option<bool>,
    // message oneof groups
    pub Map: ::std::option::Option<request_create_game::Map>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestCreateGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestCreateGame {
    fn default() -> &'a RequestCreateGame {
        <RequestCreateGame as ::protobuf::Message>::default_instance()
    }
}

impl RequestCreateGame {
    pub fn new() -> RequestCreateGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.LocalMap local_map = 1;

    pub fn local_map(&self) -> &LocalMap {
        match self.Map {
            ::std::option::Option::Some(request_create_game::Map::LocalMap(ref v)) => v,
            _ => <LocalMap as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_local_map(&mut self) {
        self.Map = ::std::option::Option::None;
    }

    pub fn has_local_map(&self) -> bool {
        match self.Map {
            ::std::option::Option::Some(request_create_game::Map::LocalMap(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_map(&mut self, v: LocalMap) {
        self.Map = ::std::option::Option::Some(request_create_game::Map::LocalMap(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local_map(&mut self) -> &mut LocalMap {
        if let ::std::option::Option::Some(request_create_game::Map::LocalMap(_)) = self.Map {
        } else {
            self.Map = ::std::option::Option::Some(request_create_game::Map::LocalMap(LocalMap::new()));
        }
        match self.Map {
            ::std::option::Option::Some(request_create_game::Map::LocalMap(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local_map(&mut self) -> LocalMap {
        if self.has_local_map() {
            match self.Map.take() {
                ::std::option::Option::Some(request_create_game::Map::LocalMap(v)) => v,
                _ => panic!(),
            }
        } else {
            LocalMap::new()
        }
    }

    // optional string battlenet_map_name = 2;

    pub fn battlenet_map_name(&self) -> &str {
        match self.Map {
            ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_battlenet_map_name(&mut self) {
        self.Map = ::std::option::Option::None;
    }

    pub fn has_battlenet_map_name(&self) -> bool {
        match self.Map {
            ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_battlenet_map_name(&mut self, v: ::std::string::String) {
        self.Map = ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(v))
    }

    // Mutable pointer to the field.
    pub fn mut_battlenet_map_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(_)) = self.Map {
        } else {
            self.Map = ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(::std::string::String::new()));
        }
        match self.Map {
            ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_battlenet_map_name(&mut self) -> ::std::string::String {
        if self.has_battlenet_map_name() {
            match self.Map.take() {
                ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bool disable_fog = 4;

    pub fn disable_fog(&self) -> bool {
        self.disable_fog.unwrap_or(false)
    }

    pub fn clear_disable_fog(&mut self) {
        self.disable_fog = ::std::option::Option::None;
    }

    pub fn has_disable_fog(&self) -> bool {
        self.disable_fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_fog(&mut self, v: bool) {
        self.disable_fog = ::std::option::Option::Some(v);
    }

    // optional uint32 random_seed = 5;

    pub fn random_seed(&self) -> u32 {
        self.random_seed.unwrap_or(0)
    }

    pub fn clear_random_seed(&mut self) {
        self.random_seed = ::std::option::Option::None;
    }

    pub fn has_random_seed(&self) -> bool {
        self.random_seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_seed(&mut self, v: u32) {
        self.random_seed = ::std::option::Option::Some(v);
    }

    // optional bool realtime = 6;

    pub fn realtime(&self) -> bool {
        self.realtime.unwrap_or(false)
    }

    pub fn clear_realtime(&mut self) {
        self.realtime = ::std::option::Option::None;
    }

    pub fn has_realtime(&self) -> bool {
        self.realtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realtime(&mut self, v: bool) {
        self.realtime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LocalMap>(
            "local_map",
            RequestCreateGame::has_local_map,
            RequestCreateGame::local_map,
            RequestCreateGame::mut_local_map,
            RequestCreateGame::set_local_map,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "battlenet_map_name",
            RequestCreateGame::has_battlenet_map_name,
            RequestCreateGame::battlenet_map_name,
            RequestCreateGame::set_battlenet_map_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_setup",
            |m: &RequestCreateGame| { &m.player_setup },
            |m: &mut RequestCreateGame| { &mut m.player_setup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_fog",
            |m: &RequestCreateGame| { &m.disable_fog },
            |m: &mut RequestCreateGame| { &mut m.disable_fog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "random_seed",
            |m: &RequestCreateGame| { &m.random_seed },
            |m: &mut RequestCreateGame| { &mut m.random_seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "realtime",
            |m: &RequestCreateGame| { &m.realtime },
            |m: &mut RequestCreateGame| { &mut m.realtime },
        ));
        oneofs.push(request_create_game::Map::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestCreateGame>(
            "RequestCreateGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestCreateGame {
    const NAME: &'static str = "RequestCreateGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Map = ::std::option::Option::Some(request_create_game::Map::LocalMap(is.read_message()?));
                },
                18 => {
                    self.Map = ::std::option::Option::Some(request_create_game::Map::BattlenetMapName(is.read_string()?));
                },
                26 => {
                    self.player_setup.push(is.read_message()?);
                },
                32 => {
                    self.disable_fog = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.random_seed = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.realtime = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_setup {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.disable_fog {
            my_size += 1 + 1;
        }
        if let Some(v) = self.random_seed {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.realtime {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.Map {
            match v {
                &request_create_game::Map::LocalMap(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request_create_game::Map::BattlenetMapName(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_setup {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.disable_fog {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.random_seed {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.realtime {
            os.write_bool(6, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Map {
            match v {
                &request_create_game::Map::LocalMap(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &request_create_game::Map::BattlenetMapName(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestCreateGame {
        RequestCreateGame::new()
    }

    fn clear(&mut self) {
        self.Map = ::std::option::Option::None;
        self.Map = ::std::option::Option::None;
        self.player_setup.clear();
        self.disable_fog = ::std::option::Option::None;
        self.random_seed = ::std::option::Option::None;
        self.realtime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestCreateGame {
        static instance: RequestCreateGame = RequestCreateGame {
            player_setup: ::std::vec::Vec::new(),
            disable_fog: ::std::option::Option::None,
            random_seed: ::std::option::Option::None,
            realtime: ::std::option::Option::None,
            Map: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestCreateGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestCreateGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestCreateGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestCreateGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RequestCreateGame`
pub mod request_create_game {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.RequestCreateGame.Map)
    pub enum Map {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestCreateGame.local_map)
        LocalMap(super::LocalMap),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestCreateGame.battlenet_map_name)
        BattlenetMapName(::std::string::String),
    }

    impl ::protobuf::Oneof for Map {
    }

    impl ::protobuf::OneofFull for Map {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RequestCreateGame as ::protobuf::MessageFull>::descriptor().oneof_by_name("Map").unwrap()).clone()
        }
    }

    impl Map {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Map>("Map")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.LocalMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LocalMap {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.LocalMap.map_path)
    pub map_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.LocalMap.map_data)
    pub map_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.LocalMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocalMap {
    fn default() -> &'a LocalMap {
        <LocalMap as ::protobuf::Message>::default_instance()
    }
}

impl LocalMap {
    pub fn new() -> LocalMap {
        ::std::default::Default::default()
    }

    // optional string map_path = 1;

    pub fn map_path(&self) -> &str {
        match self.map_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_path(&mut self) {
        self.map_path = ::std::option::Option::None;
    }

    pub fn has_map_path(&self) -> bool {
        self.map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_path(&mut self, v: ::std::string::String) {
        self.map_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_path(&mut self) -> &mut ::std::string::String {
        if self.map_path.is_none() {
            self.map_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_path(&mut self) -> ::std::string::String {
        self.map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes map_data = 7;

    pub fn map_data(&self) -> &[u8] {
        match self.map_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_map_data(&mut self) {
        self.map_data = ::std::option::Option::None;
    }

    pub fn has_map_data(&self) -> bool {
        self.map_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.map_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.map_data.is_none() {
            self.map_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.map_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_data(&mut self) -> ::std::vec::Vec<u8> {
        self.map_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_path",
            |m: &LocalMap| { &m.map_path },
            |m: &mut LocalMap| { &mut m.map_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_data",
            |m: &LocalMap| { &m.map_data },
            |m: &mut LocalMap| { &mut m.map_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalMap>(
            "LocalMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocalMap {
    const NAME: &'static str = "LocalMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_path = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.map_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.map_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.map_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocalMap {
        LocalMap::new()
    }

    fn clear(&mut self) {
        self.map_path = ::std::option::Option::None;
        self.map_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocalMap {
        static instance: LocalMap = LocalMap {
            map_path: ::std::option::Option::None,
            map_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocalMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocalMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocalMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseCreateGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseCreateGame {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseCreateGame.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_create_game::Error>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseCreateGame.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseCreateGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseCreateGame {
    fn default() -> &'a ResponseCreateGame {
        <ResponseCreateGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseCreateGame {
    pub fn new() -> ResponseCreateGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseCreateGame.Error error = 1;

    pub fn error(&self) -> response_create_game::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_create_game::Error::MissingMap),
            None => response_create_game::Error::MissingMap,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_create_game::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_details = 2;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseCreateGame| { &m.error },
            |m: &mut ResponseCreateGame| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &ResponseCreateGame| { &m.error_details },
            |m: &mut ResponseCreateGame| { &mut m.error_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseCreateGame>(
            "ResponseCreateGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseCreateGame {
    const NAME: &'static str = "ResponseCreateGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseCreateGame {
        ResponseCreateGame::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseCreateGame {
        static instance: ResponseCreateGame = ResponseCreateGame {
            error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseCreateGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseCreateGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseCreateGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCreateGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseCreateGame`
pub mod response_create_game {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseCreateGame.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.MissingMap)
        MissingMap = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.InvalidMapPath)
        InvalidMapPath = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.InvalidMapData)
        InvalidMapData = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.InvalidMapName)
        InvalidMapName = 4,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.InvalidMapHandle)
        InvalidMapHandle = 5,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.MissingPlayerSetup)
        MissingPlayerSetup = 6,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.InvalidPlayerSetup)
        InvalidPlayerSetup = 7,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseCreateGame.Error.MultiplayerUnsupported)
        MultiplayerUnsupported = 8,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::MissingMap),
                2 => ::std::option::Option::Some(Error::InvalidMapPath),
                3 => ::std::option::Option::Some(Error::InvalidMapData),
                4 => ::std::option::Option::Some(Error::InvalidMapName),
                5 => ::std::option::Option::Some(Error::InvalidMapHandle),
                6 => ::std::option::Option::Some(Error::MissingPlayerSetup),
                7 => ::std::option::Option::Some(Error::InvalidPlayerSetup),
                8 => ::std::option::Option::Some(Error::MultiplayerUnsupported),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "MissingMap" => ::std::option::Option::Some(Error::MissingMap),
                "InvalidMapPath" => ::std::option::Option::Some(Error::InvalidMapPath),
                "InvalidMapData" => ::std::option::Option::Some(Error::InvalidMapData),
                "InvalidMapName" => ::std::option::Option::Some(Error::InvalidMapName),
                "InvalidMapHandle" => ::std::option::Option::Some(Error::InvalidMapHandle),
                "MissingPlayerSetup" => ::std::option::Option::Some(Error::MissingPlayerSetup),
                "InvalidPlayerSetup" => ::std::option::Option::Some(Error::InvalidPlayerSetup),
                "MultiplayerUnsupported" => ::std::option::Option::Some(Error::MultiplayerUnsupported),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::MissingMap,
            Error::InvalidMapPath,
            Error::InvalidMapData,
            Error::InvalidMapName,
            Error::InvalidMapHandle,
            Error::MissingPlayerSetup,
            Error::InvalidPlayerSetup,
            Error::MultiplayerUnsupported,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseCreateGame.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::MissingMap => 0,
                Error::InvalidMapPath => 1,
                Error::InvalidMapData => 2,
                Error::InvalidMapName => 3,
                Error::InvalidMapHandle => 4,
                Error::MissingPlayerSetup => 5,
                Error::InvalidPlayerSetup => 6,
                Error::MultiplayerUnsupported => 7,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::MissingMap
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseCreateGame.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestJoinGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestJoinGame {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestJoinGame.options)
    pub options: ::protobuf::MessageField<InterfaceOptions>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestJoinGame.server_ports)
    pub server_ports: ::protobuf::MessageField<PortSet>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestJoinGame.client_ports)
    pub client_ports: ::std::vec::Vec<PortSet>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestJoinGame.shared_port)
    pub shared_port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestJoinGame.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestJoinGame.host_ip)
    pub host_ip: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub participation: ::std::option::Option<request_join_game::Participation>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestJoinGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestJoinGame {
    fn default() -> &'a RequestJoinGame {
        <RequestJoinGame as ::protobuf::Message>::default_instance()
    }
}

impl RequestJoinGame {
    pub fn new() -> RequestJoinGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.Race race = 1;

    pub fn race(&self) -> super::common::Race {
        match self.participation {
            ::std::option::Option::Some(request_join_game::Participation::Race(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => super::common::Race::NoRace,
        }
    }

    pub fn clear_race(&mut self) {
        self.participation = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        match self.participation {
            ::std::option::Option::Some(request_join_game::Participation::Race(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: super::common::Race) {
        self.participation = ::std::option::Option::Some(request_join_game::Participation::Race(::protobuf::EnumOrUnknown::new(v)))
    }

    // optional uint32 observed_player_id = 2;

    pub fn observed_player_id(&self) -> u32 {
        match self.participation {
            ::std::option::Option::Some(request_join_game::Participation::ObservedPlayerId(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_observed_player_id(&mut self) {
        self.participation = ::std::option::Option::None;
    }

    pub fn has_observed_player_id(&self) -> bool {
        match self.participation {
            ::std::option::Option::Some(request_join_game::Participation::ObservedPlayerId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observed_player_id(&mut self, v: u32) {
        self.participation = ::std::option::Option::Some(request_join_game::Participation::ObservedPlayerId(v))
    }

    // optional int32 shared_port = 6;

    pub fn shared_port(&self) -> i32 {
        self.shared_port.unwrap_or(0)
    }

    pub fn clear_shared_port(&mut self) {
        self.shared_port = ::std::option::Option::None;
    }

    pub fn has_shared_port(&self) -> bool {
        self.shared_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared_port(&mut self, v: i32) {
        self.shared_port = ::std::option::Option::Some(v);
    }

    // optional string player_name = 7;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host_ip = 8;

    pub fn host_ip(&self) -> &str {
        match self.host_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_ip(&mut self) {
        self.host_ip = ::std::option::Option::None;
    }

    pub fn has_host_ip(&self) -> bool {
        self.host_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_ip(&mut self, v: ::std::string::String) {
        self.host_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_ip(&mut self) -> &mut ::std::string::String {
        if self.host_ip.is_none() {
            self.host_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_ip(&mut self) -> ::std::string::String {
        self.host_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "race",
            |message: &RequestJoinGame| match &message.participation {
                ::std::option::Option::Some(request_join_game::Participation::Race(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut RequestJoinGame, e: ::protobuf::EnumOrUnknown<super::common::Race>| {
                message.participation = ::std::option::Option::Some(request_join_game::Participation::Race(e));
            },
            super::common::Race::NoRace,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "observed_player_id",
            RequestJoinGame::has_observed_player_id,
            RequestJoinGame::observed_player_id,
            RequestJoinGame::set_observed_player_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InterfaceOptions>(
            "options",
            |m: &RequestJoinGame| { &m.options },
            |m: &mut RequestJoinGame| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PortSet>(
            "server_ports",
            |m: &RequestJoinGame| { &m.server_ports },
            |m: &mut RequestJoinGame| { &mut m.server_ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_ports",
            |m: &RequestJoinGame| { &m.client_ports },
            |m: &mut RequestJoinGame| { &mut m.client_ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shared_port",
            |m: &RequestJoinGame| { &m.shared_port },
            |m: &mut RequestJoinGame| { &mut m.shared_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &RequestJoinGame| { &m.player_name },
            |m: &mut RequestJoinGame| { &mut m.player_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_ip",
            |m: &RequestJoinGame| { &m.host_ip },
            |m: &mut RequestJoinGame| { &mut m.host_ip },
        ));
        oneofs.push(request_join_game::Participation::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestJoinGame>(
            "RequestJoinGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestJoinGame {
    const NAME: &'static str = "RequestJoinGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.participation = ::std::option::Option::Some(request_join_game::Participation::Race(is.read_enum_or_unknown()?));
                },
                16 => {
                    self.participation = ::std::option::Option::Some(request_join_game::Participation::ObservedPlayerId(is.read_uint32()?));
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_ports)?;
                },
                42 => {
                    self.client_ports.push(is.read_message()?);
                },
                48 => {
                    self.shared_port = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.host_ip = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_ports.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.client_ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.shared_port {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.host_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.participation {
            match v {
                &request_join_game::Participation::Race(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
                &request_join_game::Participation::ObservedPlayerId(v) => {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.server_ports.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.client_ports {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.shared_port {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.host_ip.as_ref() {
            os.write_string(8, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.participation {
            match v {
                &request_join_game::Participation::Race(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &request_join_game::Participation::ObservedPlayerId(v) => {
                    os.write_uint32(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestJoinGame {
        RequestJoinGame::new()
    }

    fn clear(&mut self) {
        self.participation = ::std::option::Option::None;
        self.participation = ::std::option::Option::None;
        self.options.clear();
        self.server_ports.clear();
        self.client_ports.clear();
        self.shared_port = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.host_ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestJoinGame {
        static instance: RequestJoinGame = RequestJoinGame {
            options: ::protobuf::MessageField::none(),
            server_ports: ::protobuf::MessageField::none(),
            client_ports: ::std::vec::Vec::new(),
            shared_port: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            host_ip: ::std::option::Option::None,
            participation: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestJoinGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestJoinGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestJoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestJoinGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RequestJoinGame`
pub mod request_join_game {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.RequestJoinGame.participation)
    pub enum Participation {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestJoinGame.race)
        Race(::protobuf::EnumOrUnknown<super::super::common::Race>),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestJoinGame.observed_player_id)
        ObservedPlayerId(u32),
    }

    impl ::protobuf::Oneof for Participation {
    }

    impl ::protobuf::OneofFull for Participation {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RequestJoinGame as ::protobuf::MessageFull>::descriptor().oneof_by_name("participation").unwrap()).clone()
        }
    }

    impl Participation {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Participation>("participation")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.PortSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PortSet {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PortSet.game_port)
    pub game_port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PortSet.base_port)
    pub base_port: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PortSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PortSet {
    fn default() -> &'a PortSet {
        <PortSet as ::protobuf::Message>::default_instance()
    }
}

impl PortSet {
    pub fn new() -> PortSet {
        ::std::default::Default::default()
    }

    // optional int32 game_port = 1;

    pub fn game_port(&self) -> i32 {
        self.game_port.unwrap_or(0)
    }

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: i32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    // optional int32 base_port = 2;

    pub fn base_port(&self) -> i32 {
        self.base_port.unwrap_or(0)
    }

    pub fn clear_base_port(&mut self) {
        self.base_port = ::std::option::Option::None;
    }

    pub fn has_base_port(&self) -> bool {
        self.base_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_port(&mut self, v: i32) {
        self.base_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_port",
            |m: &PortSet| { &m.game_port },
            |m: &mut PortSet| { &mut m.game_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_port",
            |m: &PortSet| { &m.base_port },
            |m: &mut PortSet| { &mut m.base_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PortSet>(
            "PortSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PortSet {
    const NAME: &'static str = "PortSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_port = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.base_port = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_port {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.base_port {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_port {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.base_port {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PortSet {
        PortSet::new()
    }

    fn clear(&mut self) {
        self.game_port = ::std::option::Option::None;
        self.base_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PortSet {
        static instance: PortSet = PortSet {
            game_port: ::std::option::Option::None,
            base_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PortSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PortSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PortSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseJoinGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseJoinGame {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseJoinGame.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseJoinGame.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_join_game::Error>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseJoinGame.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseJoinGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseJoinGame {
    fn default() -> &'a ResponseJoinGame {
        <ResponseJoinGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseJoinGame {
    pub fn new() -> ResponseJoinGame {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.ResponseJoinGame.Error error = 2;

    pub fn error(&self) -> response_join_game::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_join_game::Error::MissingParticipation),
            None => response_join_game::Error::MissingParticipation,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_join_game::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_details = 3;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &ResponseJoinGame| { &m.player_id },
            |m: &mut ResponseJoinGame| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseJoinGame| { &m.error },
            |m: &mut ResponseJoinGame| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &ResponseJoinGame| { &m.error_details },
            |m: &mut ResponseJoinGame| { &mut m.error_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseJoinGame>(
            "ResponseJoinGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseJoinGame {
    const NAME: &'static str = "ResponseJoinGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseJoinGame {
        ResponseJoinGame::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseJoinGame {
        static instance: ResponseJoinGame = ResponseJoinGame {
            player_id: ::std::option::Option::None,
            error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseJoinGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseJoinGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseJoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseJoinGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseJoinGame`
pub mod response_join_game {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseJoinGame.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.MissingParticipation)
        MissingParticipation = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.InvalidObservedPlayerId)
        InvalidObservedPlayerId = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.MissingOptions)
        MissingOptions = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.MissingPorts)
        MissingPorts = 4,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.GameFull)
        GameFull = 5,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.LaunchError)
        LaunchError = 6,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.FeatureUnsupported)
        FeatureUnsupported = 7,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.NoSpaceForUser)
        NoSpaceForUser = 8,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.MapDoesNotExist)
        MapDoesNotExist = 9,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.CannotOpenMap)
        CannotOpenMap = 10,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.ChecksumError)
        ChecksumError = 11,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.NetworkError)
        NetworkError = 12,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseJoinGame.Error.OtherError)
        OtherError = 13,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::MissingParticipation),
                2 => ::std::option::Option::Some(Error::InvalidObservedPlayerId),
                3 => ::std::option::Option::Some(Error::MissingOptions),
                4 => ::std::option::Option::Some(Error::MissingPorts),
                5 => ::std::option::Option::Some(Error::GameFull),
                6 => ::std::option::Option::Some(Error::LaunchError),
                7 => ::std::option::Option::Some(Error::FeatureUnsupported),
                8 => ::std::option::Option::Some(Error::NoSpaceForUser),
                9 => ::std::option::Option::Some(Error::MapDoesNotExist),
                10 => ::std::option::Option::Some(Error::CannotOpenMap),
                11 => ::std::option::Option::Some(Error::ChecksumError),
                12 => ::std::option::Option::Some(Error::NetworkError),
                13 => ::std::option::Option::Some(Error::OtherError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "MissingParticipation" => ::std::option::Option::Some(Error::MissingParticipation),
                "InvalidObservedPlayerId" => ::std::option::Option::Some(Error::InvalidObservedPlayerId),
                "MissingOptions" => ::std::option::Option::Some(Error::MissingOptions),
                "MissingPorts" => ::std::option::Option::Some(Error::MissingPorts),
                "GameFull" => ::std::option::Option::Some(Error::GameFull),
                "LaunchError" => ::std::option::Option::Some(Error::LaunchError),
                "FeatureUnsupported" => ::std::option::Option::Some(Error::FeatureUnsupported),
                "NoSpaceForUser" => ::std::option::Option::Some(Error::NoSpaceForUser),
                "MapDoesNotExist" => ::std::option::Option::Some(Error::MapDoesNotExist),
                "CannotOpenMap" => ::std::option::Option::Some(Error::CannotOpenMap),
                "ChecksumError" => ::std::option::Option::Some(Error::ChecksumError),
                "NetworkError" => ::std::option::Option::Some(Error::NetworkError),
                "OtherError" => ::std::option::Option::Some(Error::OtherError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::MissingParticipation,
            Error::InvalidObservedPlayerId,
            Error::MissingOptions,
            Error::MissingPorts,
            Error::GameFull,
            Error::LaunchError,
            Error::FeatureUnsupported,
            Error::NoSpaceForUser,
            Error::MapDoesNotExist,
            Error::CannotOpenMap,
            Error::ChecksumError,
            Error::NetworkError,
            Error::OtherError,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseJoinGame.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::MissingParticipation => 0,
                Error::InvalidObservedPlayerId => 1,
                Error::MissingOptions => 2,
                Error::MissingPorts => 3,
                Error::GameFull => 4,
                Error::LaunchError => 5,
                Error::FeatureUnsupported => 6,
                Error::NoSpaceForUser => 7,
                Error::MapDoesNotExist => 8,
                Error::CannotOpenMap => 9,
                Error::ChecksumError => 10,
                Error::NetworkError => 11,
                Error::OtherError => 12,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::MissingParticipation
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseJoinGame.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestRestartGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestRestartGame {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestRestartGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestRestartGame {
    fn default() -> &'a RequestRestartGame {
        <RequestRestartGame as ::protobuf::Message>::default_instance()
    }
}

impl RequestRestartGame {
    pub fn new() -> RequestRestartGame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestRestartGame>(
            "RequestRestartGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestRestartGame {
    const NAME: &'static str = "RequestRestartGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestRestartGame {
        RequestRestartGame::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestRestartGame {
        static instance: RequestRestartGame = RequestRestartGame {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestRestartGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestRestartGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestRestartGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestRestartGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseRestartGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseRestartGame {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseRestartGame.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_restart_game::Error>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseRestartGame.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseRestartGame.need_hard_reset)
    pub need_hard_reset: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseRestartGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseRestartGame {
    fn default() -> &'a ResponseRestartGame {
        <ResponseRestartGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseRestartGame {
    pub fn new() -> ResponseRestartGame {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseRestartGame.Error error = 1;

    pub fn error(&self) -> response_restart_game::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_restart_game::Error::LaunchError),
            None => response_restart_game::Error::LaunchError,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_restart_game::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_details = 2;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool need_hard_reset = 3;

    pub fn need_hard_reset(&self) -> bool {
        self.need_hard_reset.unwrap_or(false)
    }

    pub fn clear_need_hard_reset(&mut self) {
        self.need_hard_reset = ::std::option::Option::None;
    }

    pub fn has_need_hard_reset(&self) -> bool {
        self.need_hard_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_hard_reset(&mut self, v: bool) {
        self.need_hard_reset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseRestartGame| { &m.error },
            |m: &mut ResponseRestartGame| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &ResponseRestartGame| { &m.error_details },
            |m: &mut ResponseRestartGame| { &mut m.error_details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "need_hard_reset",
            |m: &ResponseRestartGame| { &m.need_hard_reset },
            |m: &mut ResponseRestartGame| { &mut m.need_hard_reset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseRestartGame>(
            "ResponseRestartGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseRestartGame {
    const NAME: &'static str = "ResponseRestartGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.need_hard_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.need_hard_reset {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.need_hard_reset {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseRestartGame {
        ResponseRestartGame::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.need_hard_reset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseRestartGame {
        static instance: ResponseRestartGame = ResponseRestartGame {
            error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            need_hard_reset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseRestartGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseRestartGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseRestartGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseRestartGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseRestartGame`
pub mod response_restart_game {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseRestartGame.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseRestartGame.Error.LaunchError)
        LaunchError = 1,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::LaunchError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "LaunchError" => ::std::option::Option::Some(Error::LaunchError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::LaunchError,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseRestartGame.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::LaunchError => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::LaunchError
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseRestartGame.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestStartReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestStartReplay {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStartReplay.map_data)
    pub map_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStartReplay.observed_player_id)
    pub observed_player_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStartReplay.options)
    pub options: ::protobuf::MessageField<InterfaceOptions>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStartReplay.disable_fog)
    pub disable_fog: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStartReplay.realtime)
    pub realtime: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStartReplay.record_replay)
    pub record_replay: ::std::option::Option<bool>,
    // message oneof groups
    pub replay: ::std::option::Option<request_start_replay::Replay>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestStartReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestStartReplay {
    fn default() -> &'a RequestStartReplay {
        <RequestStartReplay as ::protobuf::Message>::default_instance()
    }
}

impl RequestStartReplay {
    pub fn new() -> RequestStartReplay {
        ::std::default::Default::default()
    }

    // optional string replay_path = 1;

    pub fn replay_path(&self) -> &str {
        match self.replay {
            ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_replay_path(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_path(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_path(&mut self, v: ::std::string::String) {
        self.replay = ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(::std::string::String::new()));
        }
        match self.replay {
            ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_path(&mut self) -> ::std::string::String {
        if self.has_replay_path() {
            match self.replay.take() {
                ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bytes replay_data = 5;

    pub fn replay_data(&self) -> &[u8] {
        match self.replay {
            ::std::option::Option::Some(request_start_replay::Replay::ReplayData(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_replay_data(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_data(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(request_start_replay::Replay::ReplayData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.replay = ::std::option::Option::Some(request_start_replay::Replay::ReplayData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(request_start_replay::Replay::ReplayData(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(request_start_replay::Replay::ReplayData(::std::vec::Vec::new()));
        }
        match self.replay {
            ::std::option::Option::Some(request_start_replay::Replay::ReplayData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_replay_data() {
            match self.replay.take() {
                ::std::option::Option::Some(request_start_replay::Replay::ReplayData(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // optional bytes map_data = 6;

    pub fn map_data(&self) -> &[u8] {
        match self.map_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_map_data(&mut self) {
        self.map_data = ::std::option::Option::None;
    }

    pub fn has_map_data(&self) -> bool {
        self.map_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.map_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.map_data.is_none() {
            self.map_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.map_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_data(&mut self) -> ::std::vec::Vec<u8> {
        self.map_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 observed_player_id = 2;

    pub fn observed_player_id(&self) -> i32 {
        self.observed_player_id.unwrap_or(0)
    }

    pub fn clear_observed_player_id(&mut self) {
        self.observed_player_id = ::std::option::Option::None;
    }

    pub fn has_observed_player_id(&self) -> bool {
        self.observed_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observed_player_id(&mut self, v: i32) {
        self.observed_player_id = ::std::option::Option::Some(v);
    }

    // optional bool disable_fog = 4;

    pub fn disable_fog(&self) -> bool {
        self.disable_fog.unwrap_or(false)
    }

    pub fn clear_disable_fog(&mut self) {
        self.disable_fog = ::std::option::Option::None;
    }

    pub fn has_disable_fog(&self) -> bool {
        self.disable_fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_fog(&mut self, v: bool) {
        self.disable_fog = ::std::option::Option::Some(v);
    }

    // optional bool realtime = 7;

    pub fn realtime(&self) -> bool {
        self.realtime.unwrap_or(false)
    }

    pub fn clear_realtime(&mut self) {
        self.realtime = ::std::option::Option::None;
    }

    pub fn has_realtime(&self) -> bool {
        self.realtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realtime(&mut self, v: bool) {
        self.realtime = ::std::option::Option::Some(v);
    }

    // optional bool record_replay = 8;

    pub fn record_replay(&self) -> bool {
        self.record_replay.unwrap_or(false)
    }

    pub fn clear_record_replay(&mut self) {
        self.record_replay = ::std::option::Option::None;
    }

    pub fn has_record_replay(&self) -> bool {
        self.record_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record_replay(&mut self, v: bool) {
        self.record_replay = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "replay_path",
            RequestStartReplay::has_replay_path,
            RequestStartReplay::replay_path,
            RequestStartReplay::set_replay_path,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "replay_data",
            RequestStartReplay::has_replay_data,
            RequestStartReplay::replay_data,
            RequestStartReplay::set_replay_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_data",
            |m: &RequestStartReplay| { &m.map_data },
            |m: &mut RequestStartReplay| { &mut m.map_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observed_player_id",
            |m: &RequestStartReplay| { &m.observed_player_id },
            |m: &mut RequestStartReplay| { &mut m.observed_player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InterfaceOptions>(
            "options",
            |m: &RequestStartReplay| { &m.options },
            |m: &mut RequestStartReplay| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_fog",
            |m: &RequestStartReplay| { &m.disable_fog },
            |m: &mut RequestStartReplay| { &mut m.disable_fog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "realtime",
            |m: &RequestStartReplay| { &m.realtime },
            |m: &mut RequestStartReplay| { &mut m.realtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "record_replay",
            |m: &RequestStartReplay| { &m.record_replay },
            |m: &mut RequestStartReplay| { &mut m.record_replay },
        ));
        oneofs.push(request_start_replay::Replay::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestStartReplay>(
            "RequestStartReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestStartReplay {
    const NAME: &'static str = "RequestStartReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.replay = ::std::option::Option::Some(request_start_replay::Replay::ReplayPath(is.read_string()?));
                },
                42 => {
                    self.replay = ::std::option::Option::Some(request_start_replay::Replay::ReplayData(is.read_bytes()?));
                },
                50 => {
                    self.map_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.observed_player_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                32 => {
                    self.disable_fog = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.realtime = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.record_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.observed_player_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.disable_fog {
            my_size += 1 + 1;
        }
        if let Some(v) = self.realtime {
            my_size += 1 + 1;
        }
        if let Some(v) = self.record_replay {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &request_start_replay::Replay::ReplayPath(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &request_start_replay::Replay::ReplayData(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_data.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.observed_player_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.disable_fog {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.realtime {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.record_replay {
            os.write_bool(8, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &request_start_replay::Replay::ReplayPath(ref v) => {
                    os.write_string(1, v)?;
                },
                &request_start_replay::Replay::ReplayData(ref v) => {
                    os.write_bytes(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestStartReplay {
        RequestStartReplay::new()
    }

    fn clear(&mut self) {
        self.replay = ::std::option::Option::None;
        self.replay = ::std::option::Option::None;
        self.map_data = ::std::option::Option::None;
        self.observed_player_id = ::std::option::Option::None;
        self.options.clear();
        self.disable_fog = ::std::option::Option::None;
        self.realtime = ::std::option::Option::None;
        self.record_replay = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestStartReplay {
        static instance: RequestStartReplay = RequestStartReplay {
            map_data: ::std::option::Option::None,
            observed_player_id: ::std::option::Option::None,
            options: ::protobuf::MessageField::none(),
            disable_fog: ::std::option::Option::None,
            realtime: ::std::option::Option::None,
            record_replay: ::std::option::Option::None,
            replay: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestStartReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestStartReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestStartReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestStartReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RequestStartReplay`
pub mod request_start_replay {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.RequestStartReplay.replay)
    pub enum Replay {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestStartReplay.replay_path)
        ReplayPath(::std::string::String),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestStartReplay.replay_data)
        ReplayData(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Replay {
    }

    impl ::protobuf::OneofFull for Replay {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RequestStartReplay as ::protobuf::MessageFull>::descriptor().oneof_by_name("replay").unwrap()).clone()
        }
    }

    impl Replay {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Replay>("replay")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseStartReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseStartReplay {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseStartReplay.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_start_replay::Error>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseStartReplay.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseStartReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseStartReplay {
    fn default() -> &'a ResponseStartReplay {
        <ResponseStartReplay as ::protobuf::Message>::default_instance()
    }
}

impl ResponseStartReplay {
    pub fn new() -> ResponseStartReplay {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseStartReplay.Error error = 1;

    pub fn error(&self) -> response_start_replay::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_start_replay::Error::MissingReplay),
            None => response_start_replay::Error::MissingReplay,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_start_replay::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_details = 2;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseStartReplay| { &m.error },
            |m: &mut ResponseStartReplay| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &ResponseStartReplay| { &m.error_details },
            |m: &mut ResponseStartReplay| { &mut m.error_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseStartReplay>(
            "ResponseStartReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseStartReplay {
    const NAME: &'static str = "ResponseStartReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseStartReplay {
        ResponseStartReplay::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseStartReplay {
        static instance: ResponseStartReplay = ResponseStartReplay {
            error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseStartReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseStartReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseStartReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseStartReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseStartReplay`
pub mod response_start_replay {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseStartReplay.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.MissingReplay)
        MissingReplay = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.InvalidReplayPath)
        InvalidReplayPath = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.InvalidReplayData)
        InvalidReplayData = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.InvalidMapData)
        InvalidMapData = 4,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.InvalidObservedPlayerId)
        InvalidObservedPlayerId = 5,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.MissingOptions)
        MissingOptions = 6,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseStartReplay.Error.LaunchError)
        LaunchError = 7,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::MissingReplay),
                2 => ::std::option::Option::Some(Error::InvalidReplayPath),
                3 => ::std::option::Option::Some(Error::InvalidReplayData),
                4 => ::std::option::Option::Some(Error::InvalidMapData),
                5 => ::std::option::Option::Some(Error::InvalidObservedPlayerId),
                6 => ::std::option::Option::Some(Error::MissingOptions),
                7 => ::std::option::Option::Some(Error::LaunchError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "MissingReplay" => ::std::option::Option::Some(Error::MissingReplay),
                "InvalidReplayPath" => ::std::option::Option::Some(Error::InvalidReplayPath),
                "InvalidReplayData" => ::std::option::Option::Some(Error::InvalidReplayData),
                "InvalidMapData" => ::std::option::Option::Some(Error::InvalidMapData),
                "InvalidObservedPlayerId" => ::std::option::Option::Some(Error::InvalidObservedPlayerId),
                "MissingOptions" => ::std::option::Option::Some(Error::MissingOptions),
                "LaunchError" => ::std::option::Option::Some(Error::LaunchError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::MissingReplay,
            Error::InvalidReplayPath,
            Error::InvalidReplayData,
            Error::InvalidMapData,
            Error::InvalidObservedPlayerId,
            Error::MissingOptions,
            Error::LaunchError,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseStartReplay.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::MissingReplay => 0,
                Error::InvalidReplayPath => 1,
                Error::InvalidReplayData => 2,
                Error::InvalidMapData => 3,
                Error::InvalidObservedPlayerId => 4,
                Error::MissingOptions => 5,
                Error::LaunchError => 6,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::MissingReplay
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseStartReplay.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestMapCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestMapCommand {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestMapCommand.trigger_cmd)
    pub trigger_cmd: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestMapCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestMapCommand {
    fn default() -> &'a RequestMapCommand {
        <RequestMapCommand as ::protobuf::Message>::default_instance()
    }
}

impl RequestMapCommand {
    pub fn new() -> RequestMapCommand {
        ::std::default::Default::default()
    }

    // optional string trigger_cmd = 1;

    pub fn trigger_cmd(&self) -> &str {
        match self.trigger_cmd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_trigger_cmd(&mut self) {
        self.trigger_cmd = ::std::option::Option::None;
    }

    pub fn has_trigger_cmd(&self) -> bool {
        self.trigger_cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trigger_cmd(&mut self, v: ::std::string::String) {
        self.trigger_cmd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trigger_cmd(&mut self) -> &mut ::std::string::String {
        if self.trigger_cmd.is_none() {
            self.trigger_cmd = ::std::option::Option::Some(::std::string::String::new());
        }
        self.trigger_cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_trigger_cmd(&mut self) -> ::std::string::String {
        self.trigger_cmd.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trigger_cmd",
            |m: &RequestMapCommand| { &m.trigger_cmd },
            |m: &mut RequestMapCommand| { &mut m.trigger_cmd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestMapCommand>(
            "RequestMapCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestMapCommand {
    const NAME: &'static str = "RequestMapCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.trigger_cmd = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trigger_cmd.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.trigger_cmd.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestMapCommand {
        RequestMapCommand::new()
    }

    fn clear(&mut self) {
        self.trigger_cmd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestMapCommand {
        static instance: RequestMapCommand = RequestMapCommand {
            trigger_cmd: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestMapCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestMapCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestMapCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestMapCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseMapCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseMapCommand {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseMapCommand.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_map_command::Error>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseMapCommand.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseMapCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseMapCommand {
    fn default() -> &'a ResponseMapCommand {
        <ResponseMapCommand as ::protobuf::Message>::default_instance()
    }
}

impl ResponseMapCommand {
    pub fn new() -> ResponseMapCommand {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseMapCommand.Error error = 1;

    pub fn error(&self) -> response_map_command::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_map_command::Error::NoTriggerError),
            None => response_map_command::Error::NoTriggerError,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_map_command::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_details = 2;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseMapCommand| { &m.error },
            |m: &mut ResponseMapCommand| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &ResponseMapCommand| { &m.error_details },
            |m: &mut ResponseMapCommand| { &mut m.error_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseMapCommand>(
            "ResponseMapCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseMapCommand {
    const NAME: &'static str = "ResponseMapCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseMapCommand {
        ResponseMapCommand::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseMapCommand {
        static instance: ResponseMapCommand = ResponseMapCommand {
            error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseMapCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseMapCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseMapCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseMapCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseMapCommand`
pub mod response_map_command {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseMapCommand.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseMapCommand.Error.NoTriggerError)
        NoTriggerError = 1,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::NoTriggerError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "NoTriggerError" => ::std::option::Option::Some(Error::NoTriggerError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::NoTriggerError,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseMapCommand.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::NoTriggerError => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::NoTriggerError
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseMapCommand.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestLeaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestLeaveGame {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestLeaveGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestLeaveGame {
    fn default() -> &'a RequestLeaveGame {
        <RequestLeaveGame as ::protobuf::Message>::default_instance()
    }
}

impl RequestLeaveGame {
    pub fn new() -> RequestLeaveGame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestLeaveGame>(
            "RequestLeaveGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestLeaveGame {
    const NAME: &'static str = "RequestLeaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestLeaveGame {
        RequestLeaveGame::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestLeaveGame {
        static instance: RequestLeaveGame = RequestLeaveGame {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestLeaveGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestLeaveGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestLeaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestLeaveGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseLeaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseLeaveGame {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseLeaveGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseLeaveGame {
    fn default() -> &'a ResponseLeaveGame {
        <ResponseLeaveGame as ::protobuf::Message>::default_instance()
    }
}

impl ResponseLeaveGame {
    pub fn new() -> ResponseLeaveGame {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseLeaveGame>(
            "ResponseLeaveGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseLeaveGame {
    const NAME: &'static str = "ResponseLeaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseLeaveGame {
        ResponseLeaveGame::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseLeaveGame {
        static instance: ResponseLeaveGame = ResponseLeaveGame {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseLeaveGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseLeaveGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseLeaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseLeaveGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQuickSave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQuickSave {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQuickSave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQuickSave {
    fn default() -> &'a RequestQuickSave {
        <RequestQuickSave as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuickSave {
    pub fn new() -> RequestQuickSave {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQuickSave>(
            "RequestQuickSave",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQuickSave {
    const NAME: &'static str = "RequestQuickSave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQuickSave {
        RequestQuickSave::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQuickSave {
        static instance: RequestQuickSave = RequestQuickSave {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQuickSave {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQuickSave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQuickSave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuickSave {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQuickSave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQuickSave {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQuickSave.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQuickSave {
    fn default() -> &'a ResponseQuickSave {
        <ResponseQuickSave as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuickSave {
    pub fn new() -> ResponseQuickSave {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQuickSave>(
            "ResponseQuickSave",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQuickSave {
    const NAME: &'static str = "ResponseQuickSave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQuickSave {
        ResponseQuickSave::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQuickSave {
        static instance: ResponseQuickSave = ResponseQuickSave {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQuickSave {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQuickSave").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQuickSave {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuickSave {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQuickLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQuickLoad {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQuickLoad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQuickLoad {
    fn default() -> &'a RequestQuickLoad {
        <RequestQuickLoad as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuickLoad {
    pub fn new() -> RequestQuickLoad {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQuickLoad>(
            "RequestQuickLoad",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQuickLoad {
    const NAME: &'static str = "RequestQuickLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQuickLoad {
        RequestQuickLoad::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQuickLoad {
        static instance: RequestQuickLoad = RequestQuickLoad {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQuickLoad {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQuickLoad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQuickLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuickLoad {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQuickLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQuickLoad {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQuickLoad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQuickLoad {
    fn default() -> &'a ResponseQuickLoad {
        <ResponseQuickLoad as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuickLoad {
    pub fn new() -> ResponseQuickLoad {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQuickLoad>(
            "ResponseQuickLoad",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQuickLoad {
    const NAME: &'static str = "ResponseQuickLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQuickLoad {
        ResponseQuickLoad::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQuickLoad {
        static instance: ResponseQuickLoad = ResponseQuickLoad {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQuickLoad {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQuickLoad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQuickLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuickLoad {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestQuit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestQuit {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestQuit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestQuit {
    fn default() -> &'a RequestQuit {
        <RequestQuit as ::protobuf::Message>::default_instance()
    }
}

impl RequestQuit {
    pub fn new() -> RequestQuit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestQuit>(
            "RequestQuit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestQuit {
    const NAME: &'static str = "RequestQuit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestQuit {
        RequestQuit::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestQuit {
        static instance: RequestQuit = RequestQuit {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestQuit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestQuit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestQuit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestQuit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseQuit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseQuit {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseQuit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseQuit {
    fn default() -> &'a ResponseQuit {
        <ResponseQuit as ::protobuf::Message>::default_instance()
    }
}

impl ResponseQuit {
    pub fn new() -> ResponseQuit {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseQuit>(
            "ResponseQuit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseQuit {
    const NAME: &'static str = "ResponseQuit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseQuit {
        ResponseQuit::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseQuit {
        static instance: ResponseQuit = ResponseQuit {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseQuit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseQuit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseQuit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseQuit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestGameInfo {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestGameInfo {
    fn default() -> &'a RequestGameInfo {
        <RequestGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl RequestGameInfo {
    pub fn new() -> RequestGameInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestGameInfo>(
            "RequestGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestGameInfo {
    const NAME: &'static str = "RequestGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestGameInfo {
        RequestGameInfo::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestGameInfo {
        static instance: RequestGameInfo = RequestGameInfo {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseGameInfo {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseGameInfo.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseGameInfo.mod_names)
    pub mod_names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseGameInfo.local_map_path)
    pub local_map_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseGameInfo.player_info)
    pub player_info: ::std::vec::Vec<PlayerInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseGameInfo.start_raw)
    pub start_raw: ::protobuf::MessageField<super::raw::StartRaw>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseGameInfo.options)
    pub options: ::protobuf::MessageField<InterfaceOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseGameInfo {
    fn default() -> &'a ResponseGameInfo {
        <ResponseGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl ResponseGameInfo {
    pub fn new() -> ResponseGameInfo {
        ::std::default::Default::default()
    }

    // optional string map_name = 1;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_map_path = 2;

    pub fn local_map_path(&self) -> &str {
        match self.local_map_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_local_map_path(&mut self) {
        self.local_map_path = ::std::option::Option::None;
    }

    pub fn has_local_map_path(&self) -> bool {
        self.local_map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_map_path(&mut self, v: ::std::string::String) {
        self.local_map_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_map_path(&mut self) -> &mut ::std::string::String {
        if self.local_map_path.is_none() {
            self.local_map_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.local_map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_map_path(&mut self) -> ::std::string::String {
        self.local_map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &ResponseGameInfo| { &m.map_name },
            |m: &mut ResponseGameInfo| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mod_names",
            |m: &ResponseGameInfo| { &m.mod_names },
            |m: &mut ResponseGameInfo| { &mut m.mod_names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_map_path",
            |m: &ResponseGameInfo| { &m.local_map_path },
            |m: &mut ResponseGameInfo| { &mut m.local_map_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_info",
            |m: &ResponseGameInfo| { &m.player_info },
            |m: &mut ResponseGameInfo| { &mut m.player_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::raw::StartRaw>(
            "start_raw",
            |m: &ResponseGameInfo| { &m.start_raw },
            |m: &mut ResponseGameInfo| { &mut m.start_raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InterfaceOptions>(
            "options",
            |m: &ResponseGameInfo| { &m.options },
            |m: &mut ResponseGameInfo| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseGameInfo>(
            "ResponseGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseGameInfo {
    const NAME: &'static str = "ResponseGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mod_names.push(is.read_string()?);
                },
                18 => {
                    self.local_map_path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.player_info.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_raw)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.mod_names {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if let Some(v) = self.local_map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.player_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.start_raw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.mod_names {
            os.write_string(6, &v)?;
        };
        if let Some(v) = self.local_map_path.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.player_info {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.start_raw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseGameInfo {
        ResponseGameInfo::new()
    }

    fn clear(&mut self) {
        self.map_name = ::std::option::Option::None;
        self.mod_names.clear();
        self.local_map_path = ::std::option::Option::None;
        self.player_info.clear();
        self.start_raw.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseGameInfo {
        static instance: ResponseGameInfo = ResponseGameInfo {
            map_name: ::std::option::Option::None,
            mod_names: ::std::vec::Vec::new(),
            local_map_path: ::std::option::Option::None,
            player_info: ::std::vec::Vec::new(),
            start_raw: ::protobuf::MessageField::none(),
            options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestObservation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestObservation {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestObservation.disable_fog)
    pub disable_fog: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestObservation.game_loop)
    pub game_loop: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestObservation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestObservation {
    fn default() -> &'a RequestObservation {
        <RequestObservation as ::protobuf::Message>::default_instance()
    }
}

impl RequestObservation {
    pub fn new() -> RequestObservation {
        ::std::default::Default::default()
    }

    // optional bool disable_fog = 1;

    pub fn disable_fog(&self) -> bool {
        self.disable_fog.unwrap_or(false)
    }

    pub fn clear_disable_fog(&mut self) {
        self.disable_fog = ::std::option::Option::None;
    }

    pub fn has_disable_fog(&self) -> bool {
        self.disable_fog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_fog(&mut self, v: bool) {
        self.disable_fog = ::std::option::Option::Some(v);
    }

    // optional uint32 game_loop = 2;

    pub fn game_loop(&self) -> u32 {
        self.game_loop.unwrap_or(0)
    }

    pub fn clear_game_loop(&mut self) {
        self.game_loop = ::std::option::Option::None;
    }

    pub fn has_game_loop(&self) -> bool {
        self.game_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_loop(&mut self, v: u32) {
        self.game_loop = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_fog",
            |m: &RequestObservation| { &m.disable_fog },
            |m: &mut RequestObservation| { &mut m.disable_fog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_loop",
            |m: &RequestObservation| { &m.game_loop },
            |m: &mut RequestObservation| { &mut m.game_loop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestObservation>(
            "RequestObservation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestObservation {
    const NAME: &'static str = "RequestObservation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.disable_fog = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_loop = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.disable_fog {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_loop {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.disable_fog {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_loop {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestObservation {
        RequestObservation::new()
    }

    fn clear(&mut self) {
        self.disable_fog = ::std::option::Option::None;
        self.game_loop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestObservation {
        static instance: RequestObservation = RequestObservation {
            disable_fog: ::std::option::Option::None,
            game_loop: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestObservation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestObservation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestObservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestObservation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseObservation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseObservation {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseObservation.actions)
    pub actions: ::std::vec::Vec<Action>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseObservation.action_errors)
    pub action_errors: ::std::vec::Vec<ActionError>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseObservation.observation)
    pub observation: ::protobuf::MessageField<Observation>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseObservation.player_result)
    pub player_result: ::std::vec::Vec<PlayerResult>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseObservation.chat)
    pub chat: ::std::vec::Vec<ChatReceived>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseObservation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseObservation {
    fn default() -> &'a ResponseObservation {
        <ResponseObservation as ::protobuf::Message>::default_instance()
    }
}

impl ResponseObservation {
    pub fn new() -> ResponseObservation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &ResponseObservation| { &m.actions },
            |m: &mut ResponseObservation| { &mut m.actions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "action_errors",
            |m: &ResponseObservation| { &m.action_errors },
            |m: &mut ResponseObservation| { &mut m.action_errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Observation>(
            "observation",
            |m: &ResponseObservation| { &m.observation },
            |m: &mut ResponseObservation| { &mut m.observation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_result",
            |m: &ResponseObservation| { &m.player_result },
            |m: &mut ResponseObservation| { &mut m.player_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat",
            |m: &ResponseObservation| { &m.chat },
            |m: &mut ResponseObservation| { &mut m.chat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseObservation>(
            "ResponseObservation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseObservation {
    const NAME: &'static str = "ResponseObservation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                18 => {
                    self.action_errors.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.observation)?;
                },
                34 => {
                    self.player_result.push(is.read_message()?);
                },
                42 => {
                    self.chat.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.action_errors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.observation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.player_result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.chat {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.action_errors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.observation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.player_result {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.chat {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseObservation {
        ResponseObservation::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.action_errors.clear();
        self.observation.clear();
        self.player_result.clear();
        self.chat.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseObservation {
        static instance: ResponseObservation = ResponseObservation {
            actions: ::std::vec::Vec::new(),
            action_errors: ::std::vec::Vec::new(),
            observation: ::protobuf::MessageField::none(),
            player_result: ::std::vec::Vec::new(),
            chat: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseObservation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseObservation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseObservation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseObservation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ChatReceived)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatReceived {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ChatReceived.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ChatReceived.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ChatReceived.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatReceived {
    fn default() -> &'a ChatReceived {
        <ChatReceived as ::protobuf::Message>::default_instance()
    }
}

impl ChatReceived {
    pub fn new() -> ChatReceived {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &ChatReceived| { &m.player_id },
            |m: &mut ChatReceived| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ChatReceived| { &m.message },
            |m: &mut ChatReceived| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatReceived>(
            "ChatReceived",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatReceived {
    const NAME: &'static str = "ChatReceived";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatReceived {
        ChatReceived::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatReceived {
        static instance: ChatReceived = ChatReceived {
            player_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatReceived {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatReceived").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatReceived {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatReceived {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestAction {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestAction.actions)
    pub actions: ::std::vec::Vec<Action>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestAction {
    fn default() -> &'a RequestAction {
        <RequestAction as ::protobuf::Message>::default_instance()
    }
}

impl RequestAction {
    pub fn new() -> RequestAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &RequestAction| { &m.actions },
            |m: &mut RequestAction| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestAction>(
            "RequestAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestAction {
    const NAME: &'static str = "RequestAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestAction {
        RequestAction::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestAction {
        static instance: RequestAction = RequestAction {
            actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseAction {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseAction.result)
    pub result: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::error::ActionResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseAction {
    fn default() -> &'a ResponseAction {
        <ResponseAction as ::protobuf::Message>::default_instance()
    }
}

impl ResponseAction {
    pub fn new() -> ResponseAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "result",
            |m: &ResponseAction| { &m.result },
            |m: &mut ResponseAction| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseAction>(
            "ResponseAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseAction {
    const NAME: &'static str = "ResponseAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.result)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.result {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseAction {
        ResponseAction::new()
    }

    fn clear(&mut self) {
        self.result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseAction {
        static instance: ResponseAction = ResponseAction {
            result: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestObserverAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestObserverAction {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestObserverAction.actions)
    pub actions: ::std::vec::Vec<ObserverAction>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestObserverAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestObserverAction {
    fn default() -> &'a RequestObserverAction {
        <RequestObserverAction as ::protobuf::Message>::default_instance()
    }
}

impl RequestObserverAction {
    pub fn new() -> RequestObserverAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &RequestObserverAction| { &m.actions },
            |m: &mut RequestObserverAction| { &mut m.actions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestObserverAction>(
            "RequestObserverAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestObserverAction {
    const NAME: &'static str = "RequestObserverAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.actions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestObserverAction {
        RequestObserverAction::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestObserverAction {
        static instance: RequestObserverAction = RequestObserverAction {
            actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestObserverAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestObserverAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestObserverAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestObserverAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseObserverAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseObserverAction {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseObserverAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseObserverAction {
    fn default() -> &'a ResponseObserverAction {
        <ResponseObserverAction as ::protobuf::Message>::default_instance()
    }
}

impl ResponseObserverAction {
    pub fn new() -> ResponseObserverAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseObserverAction>(
            "ResponseObserverAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseObserverAction {
    const NAME: &'static str = "ResponseObserverAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseObserverAction {
        ResponseObserverAction::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseObserverAction {
        static instance: ResponseObserverAction = ResponseObserverAction {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseObserverAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseObserverAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseObserverAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseObserverAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestStep)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestStep {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestStep.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestStep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestStep {
    fn default() -> &'a RequestStep {
        <RequestStep as ::protobuf::Message>::default_instance()
    }
}

impl RequestStep {
    pub fn new() -> RequestStep {
        ::std::default::Default::default()
    }

    // optional uint32 count = 1;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &RequestStep| { &m.count },
            |m: &mut RequestStep| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestStep>(
            "RequestStep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestStep {
    const NAME: &'static str = "RequestStep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestStep {
        RequestStep::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestStep {
        static instance: RequestStep = RequestStep {
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestStep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestStep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestStep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseStep)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseStep {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseStep.simulation_loop)
    pub simulation_loop: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseStep.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseStep {
    fn default() -> &'a ResponseStep {
        <ResponseStep as ::protobuf::Message>::default_instance()
    }
}

impl ResponseStep {
    pub fn new() -> ResponseStep {
        ::std::default::Default::default()
    }

    // optional uint32 simulation_loop = 1;

    pub fn simulation_loop(&self) -> u32 {
        self.simulation_loop.unwrap_or(0)
    }

    pub fn clear_simulation_loop(&mut self) {
        self.simulation_loop = ::std::option::Option::None;
    }

    pub fn has_simulation_loop(&self) -> bool {
        self.simulation_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simulation_loop(&mut self, v: u32) {
        self.simulation_loop = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "simulation_loop",
            |m: &ResponseStep| { &m.simulation_loop },
            |m: &mut ResponseStep| { &mut m.simulation_loop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseStep>(
            "ResponseStep",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseStep {
    const NAME: &'static str = "ResponseStep";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.simulation_loop = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.simulation_loop {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.simulation_loop {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseStep {
        ResponseStep::new()
    }

    fn clear(&mut self) {
        self.simulation_loop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseStep {
        static instance: ResponseStep = ResponseStep {
            simulation_loop: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseStep {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseStep").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseStep {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestData {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestData.ability_id)
    pub ability_id: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestData.unit_type_id)
    pub unit_type_id: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestData.upgrade_id)
    pub upgrade_id: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestData.buff_id)
    pub buff_id: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestData.effect_id)
    pub effect_id: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestData {
    fn default() -> &'a RequestData {
        <RequestData as ::protobuf::Message>::default_instance()
    }
}

impl RequestData {
    pub fn new() -> RequestData {
        ::std::default::Default::default()
    }

    // optional bool ability_id = 1;

    pub fn ability_id(&self) -> bool {
        self.ability_id.unwrap_or(false)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: bool) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional bool unit_type_id = 2;

    pub fn unit_type_id(&self) -> bool {
        self.unit_type_id.unwrap_or(false)
    }

    pub fn clear_unit_type_id(&mut self) {
        self.unit_type_id = ::std::option::Option::None;
    }

    pub fn has_unit_type_id(&self) -> bool {
        self.unit_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type_id(&mut self, v: bool) {
        self.unit_type_id = ::std::option::Option::Some(v);
    }

    // optional bool upgrade_id = 3;

    pub fn upgrade_id(&self) -> bool {
        self.upgrade_id.unwrap_or(false)
    }

    pub fn clear_upgrade_id(&mut self) {
        self.upgrade_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_id(&self) -> bool {
        self.upgrade_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_id(&mut self, v: bool) {
        self.upgrade_id = ::std::option::Option::Some(v);
    }

    // optional bool buff_id = 4;

    pub fn buff_id(&self) -> bool {
        self.buff_id.unwrap_or(false)
    }

    pub fn clear_buff_id(&mut self) {
        self.buff_id = ::std::option::Option::None;
    }

    pub fn has_buff_id(&self) -> bool {
        self.buff_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buff_id(&mut self, v: bool) {
        self.buff_id = ::std::option::Option::Some(v);
    }

    // optional bool effect_id = 5;

    pub fn effect_id(&self) -> bool {
        self.effect_id.unwrap_or(false)
    }

    pub fn clear_effect_id(&mut self) {
        self.effect_id = ::std::option::Option::None;
    }

    pub fn has_effect_id(&self) -> bool {
        self.effect_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_id(&mut self, v: bool) {
        self.effect_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &RequestData| { &m.ability_id },
            |m: &mut RequestData| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type_id",
            |m: &RequestData| { &m.unit_type_id },
            |m: &mut RequestData| { &mut m.unit_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgrade_id",
            |m: &RequestData| { &m.upgrade_id },
            |m: &mut RequestData| { &mut m.upgrade_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buff_id",
            |m: &RequestData| { &m.buff_id },
            |m: &mut RequestData| { &mut m.buff_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_id",
            |m: &RequestData| { &m.effect_id },
            |m: &mut RequestData| { &mut m.effect_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestData>(
            "RequestData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestData {
    const NAME: &'static str = "RequestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.unit_type_id = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.upgrade_id = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.buff_id = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.effect_id = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unit_type_id {
            my_size += 1 + 1;
        }
        if let Some(v) = self.upgrade_id {
            my_size += 1 + 1;
        }
        if let Some(v) = self.buff_id {
            my_size += 1 + 1;
        }
        if let Some(v) = self.effect_id {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.unit_type_id {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.upgrade_id {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.buff_id {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.effect_id {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestData {
        RequestData::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.unit_type_id = ::std::option::Option::None;
        self.upgrade_id = ::std::option::Option::None;
        self.buff_id = ::std::option::Option::None;
        self.effect_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestData {
        static instance: RequestData = RequestData {
            ability_id: ::std::option::Option::None,
            unit_type_id: ::std::option::Option::None,
            upgrade_id: ::std::option::Option::None,
            buff_id: ::std::option::Option::None,
            effect_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseData {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseData.abilities)
    pub abilities: ::std::vec::Vec<super::data::AbilityData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseData.units)
    pub units: ::std::vec::Vec<super::data::UnitTypeData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseData.upgrades)
    pub upgrades: ::std::vec::Vec<super::data::UpgradeData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseData.buffs)
    pub buffs: ::std::vec::Vec<super::data::BuffData>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseData.effects)
    pub effects: ::std::vec::Vec<super::data::EffectData>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseData {
    fn default() -> &'a ResponseData {
        <ResponseData as ::protobuf::Message>::default_instance()
    }
}

impl ResponseData {
    pub fn new() -> ResponseData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &ResponseData| { &m.abilities },
            |m: &mut ResponseData| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "units",
            |m: &ResponseData| { &m.units },
            |m: &mut ResponseData| { &mut m.units },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "upgrades",
            |m: &ResponseData| { &m.upgrades },
            |m: &mut ResponseData| { &mut m.upgrades },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffs",
            |m: &ResponseData| { &m.buffs },
            |m: &mut ResponseData| { &mut m.buffs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &ResponseData| { &m.effects },
            |m: &mut ResponseData| { &mut m.effects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseData>(
            "ResponseData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseData {
    const NAME: &'static str = "ResponseData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.abilities.push(is.read_message()?);
                },
                18 => {
                    self.units.push(is.read_message()?);
                },
                26 => {
                    self.upgrades.push(is.read_message()?);
                },
                34 => {
                    self.buffs.push(is.read_message()?);
                },
                42 => {
                    self.effects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.units {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.upgrades {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.buffs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.units {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.upgrades {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.buffs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.effects {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseData {
        ResponseData::new()
    }

    fn clear(&mut self) {
        self.abilities.clear();
        self.units.clear();
        self.upgrades.clear();
        self.buffs.clear();
        self.effects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseData {
        static instance: ResponseData = ResponseData {
            abilities: ::std::vec::Vec::new(),
            units: ::std::vec::Vec::new(),
            upgrades: ::std::vec::Vec::new(),
            buffs: ::std::vec::Vec::new(),
            effects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestSaveReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestSaveReplay {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestSaveReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestSaveReplay {
    fn default() -> &'a RequestSaveReplay {
        <RequestSaveReplay as ::protobuf::Message>::default_instance()
    }
}

impl RequestSaveReplay {
    pub fn new() -> RequestSaveReplay {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestSaveReplay>(
            "RequestSaveReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestSaveReplay {
    const NAME: &'static str = "RequestSaveReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestSaveReplay {
        RequestSaveReplay::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestSaveReplay {
        static instance: RequestSaveReplay = RequestSaveReplay {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestSaveReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestSaveReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestSaveReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSaveReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseSaveReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseSaveReplay {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseSaveReplay.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseSaveReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseSaveReplay {
    fn default() -> &'a ResponseSaveReplay {
        <ResponseSaveReplay as ::protobuf::Message>::default_instance()
    }
}

impl ResponseSaveReplay {
    pub fn new() -> ResponseSaveReplay {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &ResponseSaveReplay| { &m.data },
            |m: &mut ResponseSaveReplay| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseSaveReplay>(
            "ResponseSaveReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseSaveReplay {
    const NAME: &'static str = "ResponseSaveReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseSaveReplay {
        ResponseSaveReplay::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseSaveReplay {
        static instance: ResponseSaveReplay = ResponseSaveReplay {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseSaveReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseSaveReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseSaveReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseSaveReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestReplayInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestReplayInfo {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestReplayInfo.download_data)
    pub download_data: ::std::option::Option<bool>,
    // message oneof groups
    pub replay: ::std::option::Option<request_replay_info::Replay>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestReplayInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestReplayInfo {
    fn default() -> &'a RequestReplayInfo {
        <RequestReplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl RequestReplayInfo {
    pub fn new() -> RequestReplayInfo {
        ::std::default::Default::default()
    }

    // optional string replay_path = 1;

    pub fn replay_path(&self) -> &str {
        match self.replay {
            ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_replay_path(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_path(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_path(&mut self, v: ::std::string::String) {
        self.replay = ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(::std::string::String::new()));
        }
        match self.replay {
            ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_path(&mut self) -> ::std::string::String {
        if self.has_replay_path() {
            match self.replay.take() {
                ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional bytes replay_data = 2;

    pub fn replay_data(&self) -> &[u8] {
        match self.replay {
            ::std::option::Option::Some(request_replay_info::Replay::ReplayData(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_replay_data(&mut self) {
        self.replay = ::std::option::Option::None;
    }

    pub fn has_replay_data(&self) -> bool {
        match self.replay {
            ::std::option::Option::Some(request_replay_info::Replay::ReplayData(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_replay_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.replay = ::std::option::Option::Some(request_replay_info::Replay::ReplayData(v))
    }

    // Mutable pointer to the field.
    pub fn mut_replay_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(request_replay_info::Replay::ReplayData(_)) = self.replay {
        } else {
            self.replay = ::std::option::Option::Some(request_replay_info::Replay::ReplayData(::std::vec::Vec::new()));
        }
        match self.replay {
            ::std::option::Option::Some(request_replay_info::Replay::ReplayData(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_replay_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_replay_data() {
            match self.replay.take() {
                ::std::option::Option::Some(request_replay_info::Replay::ReplayData(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // optional bool download_data = 3;

    pub fn download_data(&self) -> bool {
        self.download_data.unwrap_or(false)
    }

    pub fn clear_download_data(&mut self) {
        self.download_data = ::std::option::Option::None;
    }

    pub fn has_download_data(&self) -> bool {
        self.download_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_data(&mut self, v: bool) {
        self.download_data = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "replay_path",
            RequestReplayInfo::has_replay_path,
            RequestReplayInfo::replay_path,
            RequestReplayInfo::set_replay_path,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "replay_data",
            RequestReplayInfo::has_replay_data,
            RequestReplayInfo::replay_data,
            RequestReplayInfo::set_replay_data,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_data",
            |m: &RequestReplayInfo| { &m.download_data },
            |m: &mut RequestReplayInfo| { &mut m.download_data },
        ));
        oneofs.push(request_replay_info::Replay::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestReplayInfo>(
            "RequestReplayInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestReplayInfo {
    const NAME: &'static str = "RequestReplayInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.replay = ::std::option::Option::Some(request_replay_info::Replay::ReplayPath(is.read_string()?));
                },
                18 => {
                    self.replay = ::std::option::Option::Some(request_replay_info::Replay::ReplayData(is.read_bytes()?));
                },
                24 => {
                    self.download_data = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.download_data {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &request_replay_info::Replay::ReplayPath(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &request_replay_info::Replay::ReplayData(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.download_data {
            os.write_bool(3, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.replay {
            match v {
                &request_replay_info::Replay::ReplayPath(ref v) => {
                    os.write_string(1, v)?;
                },
                &request_replay_info::Replay::ReplayData(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestReplayInfo {
        RequestReplayInfo::new()
    }

    fn clear(&mut self) {
        self.replay = ::std::option::Option::None;
        self.replay = ::std::option::Option::None;
        self.download_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestReplayInfo {
        static instance: RequestReplayInfo = RequestReplayInfo {
            download_data: ::std::option::Option::None,
            replay: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestReplayInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestReplayInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestReplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestReplayInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RequestReplayInfo`
pub mod request_replay_info {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.RequestReplayInfo.replay)
    pub enum Replay {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestReplayInfo.replay_path)
        ReplayPath(::std::string::String),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.RequestReplayInfo.replay_data)
        ReplayData(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Replay {
    }

    impl ::protobuf::OneofFull for Replay {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RequestReplayInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("replay").unwrap()).clone()
        }
    }

    impl Replay {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Replay>("replay")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.PlayerInfoExtra)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerInfoExtra {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfoExtra.player_info)
    pub player_info: ::protobuf::MessageField<PlayerInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfoExtra.player_result)
    pub player_result: ::protobuf::MessageField<PlayerResult>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfoExtra.player_mmr)
    pub player_mmr: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfoExtra.player_apm)
    pub player_apm: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PlayerInfoExtra.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerInfoExtra {
    fn default() -> &'a PlayerInfoExtra {
        <PlayerInfoExtra as ::protobuf::Message>::default_instance()
    }
}

impl PlayerInfoExtra {
    pub fn new() -> PlayerInfoExtra {
        ::std::default::Default::default()
    }

    // optional int32 player_mmr = 3;

    pub fn player_mmr(&self) -> i32 {
        self.player_mmr.unwrap_or(0)
    }

    pub fn clear_player_mmr(&mut self) {
        self.player_mmr = ::std::option::Option::None;
    }

    pub fn has_player_mmr(&self) -> bool {
        self.player_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mmr(&mut self, v: i32) {
        self.player_mmr = ::std::option::Option::Some(v);
    }

    // optional int32 player_apm = 4;

    pub fn player_apm(&self) -> i32 {
        self.player_apm.unwrap_or(0)
    }

    pub fn clear_player_apm(&mut self) {
        self.player_apm = ::std::option::Option::None;
    }

    pub fn has_player_apm(&self) -> bool {
        self.player_apm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_apm(&mut self, v: i32) {
        self.player_apm = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerInfo>(
            "player_info",
            |m: &PlayerInfoExtra| { &m.player_info },
            |m: &mut PlayerInfoExtra| { &mut m.player_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerResult>(
            "player_result",
            |m: &PlayerInfoExtra| { &m.player_result },
            |m: &mut PlayerInfoExtra| { &mut m.player_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_mmr",
            |m: &PlayerInfoExtra| { &m.player_mmr },
            |m: &mut PlayerInfoExtra| { &mut m.player_mmr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_apm",
            |m: &PlayerInfoExtra| { &m.player_apm },
            |m: &mut PlayerInfoExtra| { &mut m.player_apm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerInfoExtra>(
            "PlayerInfoExtra",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerInfoExtra {
    const NAME: &'static str = "PlayerInfoExtra";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_result)?;
                },
                24 => {
                    self.player_mmr = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.player_apm = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_mmr {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.player_apm {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.player_result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.player_mmr {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.player_apm {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerInfoExtra {
        PlayerInfoExtra::new()
    }

    fn clear(&mut self) {
        self.player_info.clear();
        self.player_result.clear();
        self.player_mmr = ::std::option::Option::None;
        self.player_apm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerInfoExtra {
        static instance: PlayerInfoExtra = PlayerInfoExtra {
            player_info: ::protobuf::MessageField::none(),
            player_result: ::protobuf::MessageField::none(),
            player_mmr: ::std::option::Option::None,
            player_apm: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerInfoExtra {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerInfoExtra").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerInfoExtra {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerInfoExtra {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseReplayInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseReplayInfo {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.local_map_path)
    pub local_map_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.player_info)
    pub player_info: ::std::vec::Vec<PlayerInfoExtra>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.game_duration_loops)
    pub game_duration_loops: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.game_duration_seconds)
    pub game_duration_seconds: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.game_version)
    pub game_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.data_version)
    pub data_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.data_build)
    pub data_build: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.base_build)
    pub base_build: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_replay_info::Error>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseReplayInfo.error_details)
    pub error_details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseReplayInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseReplayInfo {
    fn default() -> &'a ResponseReplayInfo {
        <ResponseReplayInfo as ::protobuf::Message>::default_instance()
    }
}

impl ResponseReplayInfo {
    pub fn new() -> ResponseReplayInfo {
        ::std::default::Default::default()
    }

    // optional string map_name = 1;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string local_map_path = 2;

    pub fn local_map_path(&self) -> &str {
        match self.local_map_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_local_map_path(&mut self) {
        self.local_map_path = ::std::option::Option::None;
    }

    pub fn has_local_map_path(&self) -> bool {
        self.local_map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_map_path(&mut self, v: ::std::string::String) {
        self.local_map_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_map_path(&mut self) -> &mut ::std::string::String {
        if self.local_map_path.is_none() {
            self.local_map_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.local_map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_local_map_path(&mut self) -> ::std::string::String {
        self.local_map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 game_duration_loops = 4;

    pub fn game_duration_loops(&self) -> u32 {
        self.game_duration_loops.unwrap_or(0)
    }

    pub fn clear_game_duration_loops(&mut self) {
        self.game_duration_loops = ::std::option::Option::None;
    }

    pub fn has_game_duration_loops(&self) -> bool {
        self.game_duration_loops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_duration_loops(&mut self, v: u32) {
        self.game_duration_loops = ::std::option::Option::Some(v);
    }

    // optional float game_duration_seconds = 5;

    pub fn game_duration_seconds(&self) -> f32 {
        self.game_duration_seconds.unwrap_or(0.)
    }

    pub fn clear_game_duration_seconds(&mut self) {
        self.game_duration_seconds = ::std::option::Option::None;
    }

    pub fn has_game_duration_seconds(&self) -> bool {
        self.game_duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_duration_seconds(&mut self, v: f32) {
        self.game_duration_seconds = ::std::option::Option::Some(v);
    }

    // optional string game_version = 6;

    pub fn game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_version(&mut self) {
        self.game_version = ::std::option::Option::None;
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string data_version = 11;

    pub fn data_version(&self) -> &str {
        match self.data_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_data_version(&mut self) {
        self.data_version = ::std::option::Option::None;
    }

    pub fn has_data_version(&self) -> bool {
        self.data_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_version(&mut self, v: ::std::string::String) {
        self.data_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_version(&mut self) -> &mut ::std::string::String {
        if self.data_version.is_none() {
            self.data_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.data_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_version(&mut self) -> ::std::string::String {
        self.data_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 data_build = 7;

    pub fn data_build(&self) -> u32 {
        self.data_build.unwrap_or(0)
    }

    pub fn clear_data_build(&mut self) {
        self.data_build = ::std::option::Option::None;
    }

    pub fn has_data_build(&self) -> bool {
        self.data_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_build(&mut self, v: u32) {
        self.data_build = ::std::option::Option::Some(v);
    }

    // optional uint32 base_build = 8;

    pub fn base_build(&self) -> u32 {
        self.base_build.unwrap_or(0)
    }

    pub fn clear_base_build(&mut self) {
        self.base_build = ::std::option::Option::None;
    }

    pub fn has_base_build(&self) -> bool {
        self.base_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_build(&mut self, v: u32) {
        self.base_build = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.ResponseReplayInfo.Error error = 9;

    pub fn error(&self) -> response_replay_info::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_replay_info::Error::MissingReplay),
            None => response_replay_info::Error::MissingReplay,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_replay_info::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_details = 10;

    pub fn error_details(&self) -> &str {
        match self.error_details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_details(&mut self) {
        self.error_details = ::std::option::Option::None;
    }

    pub fn has_error_details(&self) -> bool {
        self.error_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_details(&mut self, v: ::std::string::String) {
        self.error_details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_details(&mut self) -> &mut ::std::string::String {
        if self.error_details.is_none() {
            self.error_details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_details(&mut self) -> ::std::string::String {
        self.error_details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &ResponseReplayInfo| { &m.map_name },
            |m: &mut ResponseReplayInfo| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_map_path",
            |m: &ResponseReplayInfo| { &m.local_map_path },
            |m: &mut ResponseReplayInfo| { &mut m.local_map_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_info",
            |m: &ResponseReplayInfo| { &m.player_info },
            |m: &mut ResponseReplayInfo| { &mut m.player_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_duration_loops",
            |m: &ResponseReplayInfo| { &m.game_duration_loops },
            |m: &mut ResponseReplayInfo| { &mut m.game_duration_loops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_duration_seconds",
            |m: &ResponseReplayInfo| { &m.game_duration_seconds },
            |m: &mut ResponseReplayInfo| { &mut m.game_duration_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_version",
            |m: &ResponseReplayInfo| { &m.game_version },
            |m: &mut ResponseReplayInfo| { &mut m.game_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_version",
            |m: &ResponseReplayInfo| { &m.data_version },
            |m: &mut ResponseReplayInfo| { &mut m.data_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_build",
            |m: &ResponseReplayInfo| { &m.data_build },
            |m: &mut ResponseReplayInfo| { &mut m.data_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_build",
            |m: &ResponseReplayInfo| { &m.base_build },
            |m: &mut ResponseReplayInfo| { &mut m.base_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseReplayInfo| { &m.error },
            |m: &mut ResponseReplayInfo| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_details",
            |m: &ResponseReplayInfo| { &m.error_details },
            |m: &mut ResponseReplayInfo| { &mut m.error_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseReplayInfo>(
            "ResponseReplayInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseReplayInfo {
    const NAME: &'static str = "ResponseReplayInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.local_map_path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.player_info.push(is.read_message()?);
                },
                32 => {
                    self.game_duration_loops = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.game_duration_seconds = ::std::option::Option::Some(is.read_float()?);
                },
                50 => {
                    self.game_version = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.data_version = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.data_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.base_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                82 => {
                    self.error_details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.local_map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.player_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.game_duration_loops {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_duration_seconds {
            my_size += 1 + 4;
        }
        if let Some(v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.data_version.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.data_build {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.base_build {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.error_details.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.local_map_path.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.player_info {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.game_duration_loops {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_duration_seconds {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.game_version.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.data_version.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.data_build {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.base_build {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.error {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_details.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseReplayInfo {
        ResponseReplayInfo::new()
    }

    fn clear(&mut self) {
        self.map_name = ::std::option::Option::None;
        self.local_map_path = ::std::option::Option::None;
        self.player_info.clear();
        self.game_duration_loops = ::std::option::Option::None;
        self.game_duration_seconds = ::std::option::Option::None;
        self.game_version = ::std::option::Option::None;
        self.data_version = ::std::option::Option::None;
        self.data_build = ::std::option::Option::None;
        self.base_build = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.error_details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseReplayInfo {
        static instance: ResponseReplayInfo = ResponseReplayInfo {
            map_name: ::std::option::Option::None,
            local_map_path: ::std::option::Option::None,
            player_info: ::std::vec::Vec::new(),
            game_duration_loops: ::std::option::Option::None,
            game_duration_seconds: ::std::option::Option::None,
            game_version: ::std::option::Option::None,
            data_version: ::std::option::Option::None,
            data_build: ::std::option::Option::None,
            base_build: ::std::option::Option::None,
            error: ::std::option::Option::None,
            error_details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseReplayInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseReplayInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseReplayInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseReplayInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseReplayInfo`
pub mod response_replay_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseReplayInfo.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseReplayInfo.Error.MissingReplay)
        MissingReplay = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseReplayInfo.Error.InvalidReplayPath)
        InvalidReplayPath = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseReplayInfo.Error.InvalidReplayData)
        InvalidReplayData = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseReplayInfo.Error.ParsingError)
        ParsingError = 4,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseReplayInfo.Error.DownloadError)
        DownloadError = 5,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::MissingReplay),
                2 => ::std::option::Option::Some(Error::InvalidReplayPath),
                3 => ::std::option::Option::Some(Error::InvalidReplayData),
                4 => ::std::option::Option::Some(Error::ParsingError),
                5 => ::std::option::Option::Some(Error::DownloadError),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "MissingReplay" => ::std::option::Option::Some(Error::MissingReplay),
                "InvalidReplayPath" => ::std::option::Option::Some(Error::InvalidReplayPath),
                "InvalidReplayData" => ::std::option::Option::Some(Error::InvalidReplayData),
                "ParsingError" => ::std::option::Option::Some(Error::ParsingError),
                "DownloadError" => ::std::option::Option::Some(Error::DownloadError),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::MissingReplay,
            Error::InvalidReplayPath,
            Error::InvalidReplayData,
            Error::ParsingError,
            Error::DownloadError,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseReplayInfo.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::MissingReplay => 0,
                Error::InvalidReplayPath => 1,
                Error::InvalidReplayData => 2,
                Error::ParsingError => 3,
                Error::DownloadError => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::MissingReplay
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseReplayInfo.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestAvailableMaps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestAvailableMaps {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestAvailableMaps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestAvailableMaps {
    fn default() -> &'a RequestAvailableMaps {
        <RequestAvailableMaps as ::protobuf::Message>::default_instance()
    }
}

impl RequestAvailableMaps {
    pub fn new() -> RequestAvailableMaps {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestAvailableMaps>(
            "RequestAvailableMaps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestAvailableMaps {
    const NAME: &'static str = "RequestAvailableMaps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestAvailableMaps {
        RequestAvailableMaps::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestAvailableMaps {
        static instance: RequestAvailableMaps = RequestAvailableMaps {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestAvailableMaps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestAvailableMaps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestAvailableMaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestAvailableMaps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseAvailableMaps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseAvailableMaps {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseAvailableMaps.local_map_paths)
    pub local_map_paths: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseAvailableMaps.battlenet_map_names)
    pub battlenet_map_names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseAvailableMaps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseAvailableMaps {
    fn default() -> &'a ResponseAvailableMaps {
        <ResponseAvailableMaps as ::protobuf::Message>::default_instance()
    }
}

impl ResponseAvailableMaps {
    pub fn new() -> ResponseAvailableMaps {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "local_map_paths",
            |m: &ResponseAvailableMaps| { &m.local_map_paths },
            |m: &mut ResponseAvailableMaps| { &mut m.local_map_paths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "battlenet_map_names",
            |m: &ResponseAvailableMaps| { &m.battlenet_map_names },
            |m: &mut ResponseAvailableMaps| { &mut m.battlenet_map_names },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseAvailableMaps>(
            "ResponseAvailableMaps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseAvailableMaps {
    const NAME: &'static str = "ResponseAvailableMaps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.local_map_paths.push(is.read_string()?);
                },
                18 => {
                    self.battlenet_map_names.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.local_map_paths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.battlenet_map_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.local_map_paths {
            os.write_string(1, &v)?;
        };
        for v in &self.battlenet_map_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseAvailableMaps {
        ResponseAvailableMaps::new()
    }

    fn clear(&mut self) {
        self.local_map_paths.clear();
        self.battlenet_map_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseAvailableMaps {
        static instance: ResponseAvailableMaps = ResponseAvailableMaps {
            local_map_paths: ::std::vec::Vec::new(),
            battlenet_map_names: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseAvailableMaps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseAvailableMaps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseAvailableMaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseAvailableMaps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestSaveMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestSaveMap {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestSaveMap.map_path)
    pub map_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestSaveMap.map_data)
    pub map_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestSaveMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestSaveMap {
    fn default() -> &'a RequestSaveMap {
        <RequestSaveMap as ::protobuf::Message>::default_instance()
    }
}

impl RequestSaveMap {
    pub fn new() -> RequestSaveMap {
        ::std::default::Default::default()
    }

    // optional string map_path = 1;

    pub fn map_path(&self) -> &str {
        match self.map_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_path(&mut self) {
        self.map_path = ::std::option::Option::None;
    }

    pub fn has_map_path(&self) -> bool {
        self.map_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_path(&mut self, v: ::std::string::String) {
        self.map_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_path(&mut self) -> &mut ::std::string::String {
        if self.map_path.is_none() {
            self.map_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_path(&mut self) -> ::std::string::String {
        self.map_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes map_data = 2;

    pub fn map_data(&self) -> &[u8] {
        match self.map_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_map_data(&mut self) {
        self.map_data = ::std::option::Option::None;
    }

    pub fn has_map_data(&self) -> bool {
        self.map_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.map_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.map_data.is_none() {
            self.map_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.map_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_data(&mut self) -> ::std::vec::Vec<u8> {
        self.map_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_path",
            |m: &RequestSaveMap| { &m.map_path },
            |m: &mut RequestSaveMap| { &mut m.map_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_data",
            |m: &RequestSaveMap| { &m.map_data },
            |m: &mut RequestSaveMap| { &mut m.map_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestSaveMap>(
            "RequestSaveMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestSaveMap {
    const NAME: &'static str = "RequestSaveMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.map_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.map_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.map_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestSaveMap {
        RequestSaveMap::new()
    }

    fn clear(&mut self) {
        self.map_path = ::std::option::Option::None;
        self.map_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestSaveMap {
        static instance: RequestSaveMap = RequestSaveMap {
            map_path: ::std::option::Option::None,
            map_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestSaveMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestSaveMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestSaveMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestSaveMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseSaveMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseSaveMap {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponseSaveMap.error)
    pub error: ::std::option::Option<::protobuf::EnumOrUnknown<response_save_map::Error>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseSaveMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseSaveMap {
    fn default() -> &'a ResponseSaveMap {
        <ResponseSaveMap as ::protobuf::Message>::default_instance()
    }
}

impl ResponseSaveMap {
    pub fn new() -> ResponseSaveMap {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ResponseSaveMap.Error error = 1;

    pub fn error(&self) -> response_save_map::Error {
        match self.error {
            Some(e) => e.enum_value_or(response_save_map::Error::InvalidMapData),
            None => response_save_map::Error::InvalidMapData,
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: response_save_map::Error) {
        self.error = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &ResponseSaveMap| { &m.error },
            |m: &mut ResponseSaveMap| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseSaveMap>(
            "ResponseSaveMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseSaveMap {
    const NAME: &'static str = "ResponseSaveMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseSaveMap {
        ResponseSaveMap::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseSaveMap {
        static instance: ResponseSaveMap = ResponseSaveMap {
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseSaveMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseSaveMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseSaveMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseSaveMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ResponseSaveMap`
pub mod response_save_map {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ResponseSaveMap.Error)
    pub enum Error {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ResponseSaveMap.Error.InvalidMapData)
        InvalidMapData = 1,
    }

    impl ::protobuf::Enum for Error {
        const NAME: &'static str = "Error";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Error> {
            match value {
                1 => ::std::option::Option::Some(Error::InvalidMapData),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Error> {
            match str {
                "InvalidMapData" => ::std::option::Option::Some(Error::InvalidMapData),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Error] = &[
            Error::InvalidMapData,
        ];
    }

    impl ::protobuf::EnumFull for Error {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ResponseSaveMap.Error").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Error::InvalidMapData => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Error::InvalidMapData
        }
    }

    impl Error {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Error>("ResponseSaveMap.Error")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestPing {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestPing {
    fn default() -> &'a RequestPing {
        <RequestPing as ::protobuf::Message>::default_instance()
    }
}

impl RequestPing {
    pub fn new() -> RequestPing {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestPing>(
            "RequestPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestPing {
    const NAME: &'static str = "RequestPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestPing {
        RequestPing::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestPing {
        static instance: RequestPing = RequestPing {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponsePing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponsePing {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponsePing.game_version)
    pub game_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponsePing.data_version)
    pub data_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponsePing.data_build)
    pub data_build: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ResponsePing.base_build)
    pub base_build: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponsePing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponsePing {
    fn default() -> &'a ResponsePing {
        <ResponsePing as ::protobuf::Message>::default_instance()
    }
}

impl ResponsePing {
    pub fn new() -> ResponsePing {
        ::std::default::Default::default()
    }

    // optional string game_version = 1;

    pub fn game_version(&self) -> &str {
        match self.game_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_version(&mut self) {
        self.game_version = ::std::option::Option::None;
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version(&mut self) -> &mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string data_version = 2;

    pub fn data_version(&self) -> &str {
        match self.data_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_data_version(&mut self) {
        self.data_version = ::std::option::Option::None;
    }

    pub fn has_data_version(&self) -> bool {
        self.data_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_version(&mut self, v: ::std::string::String) {
        self.data_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_version(&mut self) -> &mut ::std::string::String {
        if self.data_version.is_none() {
            self.data_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.data_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_version(&mut self) -> ::std::string::String {
        self.data_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 data_build = 3;

    pub fn data_build(&self) -> u32 {
        self.data_build.unwrap_or(0)
    }

    pub fn clear_data_build(&mut self) {
        self.data_build = ::std::option::Option::None;
    }

    pub fn has_data_build(&self) -> bool {
        self.data_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_build(&mut self, v: u32) {
        self.data_build = ::std::option::Option::Some(v);
    }

    // optional uint32 base_build = 4;

    pub fn base_build(&self) -> u32 {
        self.base_build.unwrap_or(0)
    }

    pub fn clear_base_build(&mut self) {
        self.base_build = ::std::option::Option::None;
    }

    pub fn has_base_build(&self) -> bool {
        self.base_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_build(&mut self, v: u32) {
        self.base_build = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_version",
            |m: &ResponsePing| { &m.game_version },
            |m: &mut ResponsePing| { &mut m.game_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_version",
            |m: &ResponsePing| { &m.data_version },
            |m: &mut ResponsePing| { &mut m.data_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_build",
            |m: &ResponsePing| { &m.data_build },
            |m: &mut ResponsePing| { &mut m.data_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "base_build",
            |m: &ResponsePing| { &m.base_build },
            |m: &mut ResponsePing| { &mut m.base_build },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponsePing>(
            "ResponsePing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponsePing {
    const NAME: &'static str = "ResponsePing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.game_version = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.data_version = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.data_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.base_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.data_version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.data_build {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.base_build {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.data_version.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data_build {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.base_build {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponsePing {
        ResponsePing::new()
    }

    fn clear(&mut self) {
        self.game_version = ::std::option::Option::None;
        self.data_version = ::std::option::Option::None;
        self.data_build = ::std::option::Option::None;
        self.base_build = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponsePing {
        static instance: ResponsePing = ResponsePing {
            game_version: ::std::option::Option::None,
            data_version: ::std::option::Option::None,
            data_build: ::std::option::Option::None,
            base_build: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponsePing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponsePing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponsePing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponsePing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.RequestDebug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestDebug {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.RequestDebug.debug)
    pub debug: ::std::vec::Vec<super::debug::DebugCommand>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.RequestDebug.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestDebug {
    fn default() -> &'a RequestDebug {
        <RequestDebug as ::protobuf::Message>::default_instance()
    }
}

impl RequestDebug {
    pub fn new() -> RequestDebug {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "debug",
            |m: &RequestDebug| { &m.debug },
            |m: &mut RequestDebug| { &mut m.debug },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestDebug>(
            "RequestDebug",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestDebug {
    const NAME: &'static str = "RequestDebug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.debug.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.debug {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.debug {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestDebug {
        RequestDebug::new()
    }

    fn clear(&mut self) {
        self.debug.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestDebug {
        static instance: RequestDebug = RequestDebug {
            debug: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestDebug {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestDebug").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestDebug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestDebug {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ResponseDebug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResponseDebug {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ResponseDebug.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResponseDebug {
    fn default() -> &'a ResponseDebug {
        <ResponseDebug as ::protobuf::Message>::default_instance()
    }
}

impl ResponseDebug {
    pub fn new() -> ResponseDebug {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResponseDebug>(
            "ResponseDebug",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResponseDebug {
    const NAME: &'static str = "ResponseDebug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResponseDebug {
        ResponseDebug::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResponseDebug {
        static instance: ResponseDebug = ResponseDebug {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResponseDebug {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResponseDebug").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResponseDebug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseDebug {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.PlayerSetup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerSetup {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerSetup.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<PlayerType>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerSetup.race)
    pub race: ::std::option::Option<::protobuf::EnumOrUnknown<super::common::Race>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerSetup.difficulty)
    pub difficulty: ::std::option::Option<::protobuf::EnumOrUnknown<Difficulty>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerSetup.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerSetup.ai_build)
    pub ai_build: ::std::option::Option<::protobuf::EnumOrUnknown<AIBuild>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PlayerSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerSetup {
    fn default() -> &'a PlayerSetup {
        <PlayerSetup as ::protobuf::Message>::default_instance()
    }
}

impl PlayerSetup {
    pub fn new() -> PlayerSetup {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.PlayerType type = 1;

    pub fn type_(&self) -> PlayerType {
        match self.type_ {
            Some(e) => e.enum_value_or(PlayerType::Participant),
            None => PlayerType::Participant,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: PlayerType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.Race race = 2;

    pub fn race(&self) -> super::common::Race {
        match self.race {
            Some(e) => e.enum_value_or(super::common::Race::NoRace),
            None => super::common::Race::NoRace,
        }
    }

    pub fn clear_race(&mut self) {
        self.race = ::std::option::Option::None;
    }

    pub fn has_race(&self) -> bool {
        self.race.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race(&mut self, v: super::common::Race) {
        self.race = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.Difficulty difficulty = 3;

    pub fn difficulty(&self) -> Difficulty {
        match self.difficulty {
            Some(e) => e.enum_value_or(Difficulty::VeryEasy),
            None => Difficulty::VeryEasy,
        }
    }

    pub fn clear_difficulty(&mut self) {
        self.difficulty = ::std::option::Option::None;
    }

    pub fn has_difficulty(&self) -> bool {
        self.difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: Difficulty) {
        self.difficulty = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string player_name = 4;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .SC2APIProtocol.AIBuild ai_build = 5;

    pub fn ai_build(&self) -> AIBuild {
        match self.ai_build {
            Some(e) => e.enum_value_or(AIBuild::RandomBuild),
            None => AIBuild::RandomBuild,
        }
    }

    pub fn clear_ai_build(&mut self) {
        self.ai_build = ::std::option::Option::None;
    }

    pub fn has_ai_build(&self) -> bool {
        self.ai_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_build(&mut self, v: AIBuild) {
        self.ai_build = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PlayerSetup| { &m.type_ },
            |m: &mut PlayerSetup| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "race",
            |m: &PlayerSetup| { &m.race },
            |m: &mut PlayerSetup| { &mut m.race },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "difficulty",
            |m: &PlayerSetup| { &m.difficulty },
            |m: &mut PlayerSetup| { &mut m.difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &PlayerSetup| { &m.player_name },
            |m: &mut PlayerSetup| { &mut m.player_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ai_build",
            |m: &PlayerSetup| { &m.ai_build },
            |m: &mut PlayerSetup| { &mut m.ai_build },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerSetup>(
            "PlayerSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerSetup {
    const NAME: &'static str = "PlayerSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.race = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.difficulty = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.ai_build = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.race {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.difficulty {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.ai_build {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.race {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.difficulty {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.ai_build {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerSetup {
        PlayerSetup::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.race = ::std::option::Option::None;
        self.difficulty = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.ai_build = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerSetup {
        static instance: PlayerSetup = PlayerSetup {
            type_: ::std::option::Option::None,
            race: ::std::option::Option::None,
            difficulty: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            ai_build: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.SpatialCameraSetup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SpatialCameraSetup {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.SpatialCameraSetup.resolution)
    pub resolution: ::protobuf::MessageField<super::common::Size2DI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SpatialCameraSetup.minimap_resolution)
    pub minimap_resolution: ::protobuf::MessageField<super::common::Size2DI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SpatialCameraSetup.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SpatialCameraSetup.crop_to_playable_area)
    pub crop_to_playable_area: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SpatialCameraSetup.allow_cheating_layers)
    pub allow_cheating_layers: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.SpatialCameraSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SpatialCameraSetup {
    fn default() -> &'a SpatialCameraSetup {
        <SpatialCameraSetup as ::protobuf::Message>::default_instance()
    }
}

impl SpatialCameraSetup {
    pub fn new() -> SpatialCameraSetup {
        ::std::default::Default::default()
    }

    // optional float width = 1;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional bool crop_to_playable_area = 4;

    pub fn crop_to_playable_area(&self) -> bool {
        self.crop_to_playable_area.unwrap_or(false)
    }

    pub fn clear_crop_to_playable_area(&mut self) {
        self.crop_to_playable_area = ::std::option::Option::None;
    }

    pub fn has_crop_to_playable_area(&self) -> bool {
        self.crop_to_playable_area.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crop_to_playable_area(&mut self, v: bool) {
        self.crop_to_playable_area = ::std::option::Option::Some(v);
    }

    // optional bool allow_cheating_layers = 5;

    pub fn allow_cheating_layers(&self) -> bool {
        self.allow_cheating_layers.unwrap_or(false)
    }

    pub fn clear_allow_cheating_layers(&mut self) {
        self.allow_cheating_layers = ::std::option::Option::None;
    }

    pub fn has_allow_cheating_layers(&self) -> bool {
        self.allow_cheating_layers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheating_layers(&mut self, v: bool) {
        self.allow_cheating_layers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Size2DI>(
            "resolution",
            |m: &SpatialCameraSetup| { &m.resolution },
            |m: &mut SpatialCameraSetup| { &mut m.resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Size2DI>(
            "minimap_resolution",
            |m: &SpatialCameraSetup| { &m.minimap_resolution },
            |m: &mut SpatialCameraSetup| { &mut m.minimap_resolution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &SpatialCameraSetup| { &m.width },
            |m: &mut SpatialCameraSetup| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crop_to_playable_area",
            |m: &SpatialCameraSetup| { &m.crop_to_playable_area },
            |m: &mut SpatialCameraSetup| { &mut m.crop_to_playable_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_cheating_layers",
            |m: &SpatialCameraSetup| { &m.allow_cheating_layers },
            |m: &mut SpatialCameraSetup| { &mut m.allow_cheating_layers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpatialCameraSetup>(
            "SpatialCameraSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SpatialCameraSetup {
    const NAME: &'static str = "SpatialCameraSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resolution)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.minimap_resolution)?;
                },
                13 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.crop_to_playable_area = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.allow_cheating_layers = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.minimap_resolution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.crop_to_playable_area {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_cheating_layers {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resolution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.minimap_resolution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.width {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.crop_to_playable_area {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.allow_cheating_layers {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SpatialCameraSetup {
        SpatialCameraSetup::new()
    }

    fn clear(&mut self) {
        self.resolution.clear();
        self.minimap_resolution.clear();
        self.width = ::std::option::Option::None;
        self.crop_to_playable_area = ::std::option::Option::None;
        self.allow_cheating_layers = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SpatialCameraSetup {
        static instance: SpatialCameraSetup = SpatialCameraSetup {
            resolution: ::protobuf::MessageField::none(),
            minimap_resolution: ::protobuf::MessageField::none(),
            width: ::std::option::Option::None,
            crop_to_playable_area: ::std::option::Option::None,
            allow_cheating_layers: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SpatialCameraSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SpatialCameraSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SpatialCameraSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpatialCameraSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.InterfaceOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InterfaceOptions {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.raw)
    pub raw: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.score)
    pub score: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.feature_layer)
    pub feature_layer: ::protobuf::MessageField<SpatialCameraSetup>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.render)
    pub render: ::protobuf::MessageField<SpatialCameraSetup>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.show_cloaked)
    pub show_cloaked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.show_burrowed_shadows)
    pub show_burrowed_shadows: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.show_placeholders)
    pub show_placeholders: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.raw_affects_selection)
    pub raw_affects_selection: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:SC2APIProtocol.InterfaceOptions.raw_crop_to_playable_area)
    pub raw_crop_to_playable_area: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.InterfaceOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InterfaceOptions {
    fn default() -> &'a InterfaceOptions {
        <InterfaceOptions as ::protobuf::Message>::default_instance()
    }
}

impl InterfaceOptions {
    pub fn new() -> InterfaceOptions {
        ::std::default::Default::default()
    }

    // optional bool raw = 1;

    pub fn raw(&self) -> bool {
        self.raw.unwrap_or(false)
    }

    pub fn clear_raw(&mut self) {
        self.raw = ::std::option::Option::None;
    }

    pub fn has_raw(&self) -> bool {
        self.raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw(&mut self, v: bool) {
        self.raw = ::std::option::Option::Some(v);
    }

    // optional bool score = 2;

    pub fn score(&self) -> bool {
        self.score.unwrap_or(false)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: bool) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bool show_cloaked = 5;

    pub fn show_cloaked(&self) -> bool {
        self.show_cloaked.unwrap_or(false)
    }

    pub fn clear_show_cloaked(&mut self) {
        self.show_cloaked = ::std::option::Option::None;
    }

    pub fn has_show_cloaked(&self) -> bool {
        self.show_cloaked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_cloaked(&mut self, v: bool) {
        self.show_cloaked = ::std::option::Option::Some(v);
    }

    // optional bool show_burrowed_shadows = 9;

    pub fn show_burrowed_shadows(&self) -> bool {
        self.show_burrowed_shadows.unwrap_or(false)
    }

    pub fn clear_show_burrowed_shadows(&mut self) {
        self.show_burrowed_shadows = ::std::option::Option::None;
    }

    pub fn has_show_burrowed_shadows(&self) -> bool {
        self.show_burrowed_shadows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_burrowed_shadows(&mut self, v: bool) {
        self.show_burrowed_shadows = ::std::option::Option::Some(v);
    }

    // optional bool show_placeholders = 8;

    pub fn show_placeholders(&self) -> bool {
        self.show_placeholders.unwrap_or(false)
    }

    pub fn clear_show_placeholders(&mut self) {
        self.show_placeholders = ::std::option::Option::None;
    }

    pub fn has_show_placeholders(&self) -> bool {
        self.show_placeholders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_placeholders(&mut self, v: bool) {
        self.show_placeholders = ::std::option::Option::Some(v);
    }

    // optional bool raw_affects_selection = 6;

    pub fn raw_affects_selection(&self) -> bool {
        self.raw_affects_selection.unwrap_or(false)
    }

    pub fn clear_raw_affects_selection(&mut self) {
        self.raw_affects_selection = ::std::option::Option::None;
    }

    pub fn has_raw_affects_selection(&self) -> bool {
        self.raw_affects_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_affects_selection(&mut self, v: bool) {
        self.raw_affects_selection = ::std::option::Option::Some(v);
    }

    // optional bool raw_crop_to_playable_area = 7;

    pub fn raw_crop_to_playable_area(&self) -> bool {
        self.raw_crop_to_playable_area.unwrap_or(false)
    }

    pub fn clear_raw_crop_to_playable_area(&mut self) {
        self.raw_crop_to_playable_area = ::std::option::Option::None;
    }

    pub fn has_raw_crop_to_playable_area(&self) -> bool {
        self.raw_crop_to_playable_area.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_crop_to_playable_area(&mut self, v: bool) {
        self.raw_crop_to_playable_area = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw",
            |m: &InterfaceOptions| { &m.raw },
            |m: &mut InterfaceOptions| { &mut m.raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &InterfaceOptions| { &m.score },
            |m: &mut InterfaceOptions| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpatialCameraSetup>(
            "feature_layer",
            |m: &InterfaceOptions| { &m.feature_layer },
            |m: &mut InterfaceOptions| { &mut m.feature_layer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpatialCameraSetup>(
            "render",
            |m: &InterfaceOptions| { &m.render },
            |m: &mut InterfaceOptions| { &mut m.render },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_cloaked",
            |m: &InterfaceOptions| { &m.show_cloaked },
            |m: &mut InterfaceOptions| { &mut m.show_cloaked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_burrowed_shadows",
            |m: &InterfaceOptions| { &m.show_burrowed_shadows },
            |m: &mut InterfaceOptions| { &mut m.show_burrowed_shadows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_placeholders",
            |m: &InterfaceOptions| { &m.show_placeholders },
            |m: &mut InterfaceOptions| { &mut m.show_placeholders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_affects_selection",
            |m: &InterfaceOptions| { &m.raw_affects_selection },
            |m: &mut InterfaceOptions| { &mut m.raw_affects_selection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "raw_crop_to_playable_area",
            |m: &InterfaceOptions| { &m.raw_crop_to_playable_area },
            |m: &mut InterfaceOptions| { &mut m.raw_crop_to_playable_area },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InterfaceOptions>(
            "InterfaceOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InterfaceOptions {
    const NAME: &'static str = "InterfaceOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.raw = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.score = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feature_layer)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.render)?;
                },
                40 => {
                    self.show_cloaked = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.show_burrowed_shadows = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.show_placeholders = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.raw_affects_selection = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.raw_crop_to_playable_area = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.raw {
            my_size += 1 + 1;
        }
        if let Some(v) = self.score {
            my_size += 1 + 1;
        }
        if let Some(v) = self.feature_layer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.render.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.show_cloaked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_burrowed_shadows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_placeholders {
            my_size += 1 + 1;
        }
        if let Some(v) = self.raw_affects_selection {
            my_size += 1 + 1;
        }
        if let Some(v) = self.raw_crop_to_playable_area {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.raw {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.feature_layer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.render.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.show_cloaked {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.show_burrowed_shadows {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.show_placeholders {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.raw_affects_selection {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.raw_crop_to_playable_area {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InterfaceOptions {
        InterfaceOptions::new()
    }

    fn clear(&mut self) {
        self.raw = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.feature_layer.clear();
        self.render.clear();
        self.show_cloaked = ::std::option::Option::None;
        self.show_burrowed_shadows = ::std::option::Option::None;
        self.show_placeholders = ::std::option::Option::None;
        self.raw_affects_selection = ::std::option::Option::None;
        self.raw_crop_to_playable_area = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InterfaceOptions {
        static instance: InterfaceOptions = InterfaceOptions {
            raw: ::std::option::Option::None,
            score: ::std::option::Option::None,
            feature_layer: ::protobuf::MessageField::none(),
            render: ::protobuf::MessageField::none(),
            show_cloaked: ::std::option::Option::None,
            show_burrowed_shadows: ::std::option::Option::None,
            show_placeholders: ::std::option::Option::None,
            raw_affects_selection: ::std::option::Option::None,
            raw_crop_to_playable_area: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InterfaceOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InterfaceOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InterfaceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InterfaceOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.PlayerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerInfo {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<PlayerType>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.race_requested)
    pub race_requested: ::std::option::Option<::protobuf::EnumOrUnknown<super::common::Race>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.race_actual)
    pub race_actual: ::std::option::Option<::protobuf::EnumOrUnknown<super::common::Race>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.difficulty)
    pub difficulty: ::std::option::Option<::protobuf::EnumOrUnknown<Difficulty>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.ai_build)
    pub ai_build: ::std::option::Option<::protobuf::EnumOrUnknown<AIBuild>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerInfo.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PlayerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerInfo {
    fn default() -> &'a PlayerInfo {
        <PlayerInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerInfo {
    pub fn new() -> PlayerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.PlayerType type = 2;

    pub fn type_(&self) -> PlayerType {
        match self.type_ {
            Some(e) => e.enum_value_or(PlayerType::Participant),
            None => PlayerType::Participant,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: PlayerType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.Race race_requested = 3;

    pub fn race_requested(&self) -> super::common::Race {
        match self.race_requested {
            Some(e) => e.enum_value_or(super::common::Race::NoRace),
            None => super::common::Race::NoRace,
        }
    }

    pub fn clear_race_requested(&mut self) {
        self.race_requested = ::std::option::Option::None;
    }

    pub fn has_race_requested(&self) -> bool {
        self.race_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race_requested(&mut self, v: super::common::Race) {
        self.race_requested = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.Race race_actual = 4;

    pub fn race_actual(&self) -> super::common::Race {
        match self.race_actual {
            Some(e) => e.enum_value_or(super::common::Race::NoRace),
            None => super::common::Race::NoRace,
        }
    }

    pub fn clear_race_actual(&mut self) {
        self.race_actual = ::std::option::Option::None;
    }

    pub fn has_race_actual(&self) -> bool {
        self.race_actual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_race_actual(&mut self, v: super::common::Race) {
        self.race_actual = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.Difficulty difficulty = 5;

    pub fn difficulty(&self) -> Difficulty {
        match self.difficulty {
            Some(e) => e.enum_value_or(Difficulty::VeryEasy),
            None => Difficulty::VeryEasy,
        }
    }

    pub fn clear_difficulty(&mut self) {
        self.difficulty = ::std::option::Option::None;
    }

    pub fn has_difficulty(&self) -> bool {
        self.difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: Difficulty) {
        self.difficulty = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .SC2APIProtocol.AIBuild ai_build = 7;

    pub fn ai_build(&self) -> AIBuild {
        match self.ai_build {
            Some(e) => e.enum_value_or(AIBuild::RandomBuild),
            None => AIBuild::RandomBuild,
        }
    }

    pub fn clear_ai_build(&mut self) {
        self.ai_build = ::std::option::Option::None;
    }

    pub fn has_ai_build(&self) -> bool {
        self.ai_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ai_build(&mut self, v: AIBuild) {
        self.ai_build = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string player_name = 6;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &PlayerInfo| { &m.player_id },
            |m: &mut PlayerInfo| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PlayerInfo| { &m.type_ },
            |m: &mut PlayerInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "race_requested",
            |m: &PlayerInfo| { &m.race_requested },
            |m: &mut PlayerInfo| { &mut m.race_requested },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "race_actual",
            |m: &PlayerInfo| { &m.race_actual },
            |m: &mut PlayerInfo| { &mut m.race_actual },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "difficulty",
            |m: &PlayerInfo| { &m.difficulty },
            |m: &mut PlayerInfo| { &mut m.difficulty },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ai_build",
            |m: &PlayerInfo| { &m.ai_build },
            |m: &mut PlayerInfo| { &mut m.ai_build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &PlayerInfo| { &m.player_name },
            |m: &mut PlayerInfo| { &mut m.player_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerInfo>(
            "PlayerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerInfo {
    const NAME: &'static str = "PlayerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.race_requested = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.race_actual = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.difficulty = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.ai_build = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.race_requested {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.race_actual {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.difficulty {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.ai_build {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.race_requested {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.race_actual {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.difficulty {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ai_build {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerInfo {
        PlayerInfo::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.race_requested = ::std::option::Option::None;
        self.race_actual = ::std::option::Option::None;
        self.difficulty = ::std::option::Option::None;
        self.ai_build = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerInfo {
        static instance: PlayerInfo = PlayerInfo {
            player_id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            race_requested: ::std::option::Option::None,
            race_actual: ::std::option::Option::None,
            difficulty: ::std::option::Option::None,
            ai_build: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.PlayerCommon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerCommon {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.minerals)
    pub minerals: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.vespene)
    pub vespene: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.food_cap)
    pub food_cap: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.food_used)
    pub food_used: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.food_army)
    pub food_army: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.food_workers)
    pub food_workers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.idle_worker_count)
    pub idle_worker_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.army_count)
    pub army_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.warp_gate_count)
    pub warp_gate_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerCommon.larva_count)
    pub larva_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PlayerCommon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerCommon {
    fn default() -> &'a PlayerCommon {
        <PlayerCommon as ::protobuf::Message>::default_instance()
    }
}

impl PlayerCommon {
    pub fn new() -> PlayerCommon {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional uint32 minerals = 2;

    pub fn minerals(&self) -> u32 {
        self.minerals.unwrap_or(0)
    }

    pub fn clear_minerals(&mut self) {
        self.minerals = ::std::option::Option::None;
    }

    pub fn has_minerals(&self) -> bool {
        self.minerals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minerals(&mut self, v: u32) {
        self.minerals = ::std::option::Option::Some(v);
    }

    // optional uint32 vespene = 3;

    pub fn vespene(&self) -> u32 {
        self.vespene.unwrap_or(0)
    }

    pub fn clear_vespene(&mut self) {
        self.vespene = ::std::option::Option::None;
    }

    pub fn has_vespene(&self) -> bool {
        self.vespene.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vespene(&mut self, v: u32) {
        self.vespene = ::std::option::Option::Some(v);
    }

    // optional uint32 food_cap = 4;

    pub fn food_cap(&self) -> u32 {
        self.food_cap.unwrap_or(0)
    }

    pub fn clear_food_cap(&mut self) {
        self.food_cap = ::std::option::Option::None;
    }

    pub fn has_food_cap(&self) -> bool {
        self.food_cap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_cap(&mut self, v: u32) {
        self.food_cap = ::std::option::Option::Some(v);
    }

    // optional uint32 food_used = 5;

    pub fn food_used(&self) -> u32 {
        self.food_used.unwrap_or(0)
    }

    pub fn clear_food_used(&mut self) {
        self.food_used = ::std::option::Option::None;
    }

    pub fn has_food_used(&self) -> bool {
        self.food_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_used(&mut self, v: u32) {
        self.food_used = ::std::option::Option::Some(v);
    }

    // optional uint32 food_army = 6;

    pub fn food_army(&self) -> u32 {
        self.food_army.unwrap_or(0)
    }

    pub fn clear_food_army(&mut self) {
        self.food_army = ::std::option::Option::None;
    }

    pub fn has_food_army(&self) -> bool {
        self.food_army.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_army(&mut self, v: u32) {
        self.food_army = ::std::option::Option::Some(v);
    }

    // optional uint32 food_workers = 7;

    pub fn food_workers(&self) -> u32 {
        self.food_workers.unwrap_or(0)
    }

    pub fn clear_food_workers(&mut self) {
        self.food_workers = ::std::option::Option::None;
    }

    pub fn has_food_workers(&self) -> bool {
        self.food_workers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_workers(&mut self, v: u32) {
        self.food_workers = ::std::option::Option::Some(v);
    }

    // optional uint32 idle_worker_count = 8;

    pub fn idle_worker_count(&self) -> u32 {
        self.idle_worker_count.unwrap_or(0)
    }

    pub fn clear_idle_worker_count(&mut self) {
        self.idle_worker_count = ::std::option::Option::None;
    }

    pub fn has_idle_worker_count(&self) -> bool {
        self.idle_worker_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_worker_count(&mut self, v: u32) {
        self.idle_worker_count = ::std::option::Option::Some(v);
    }

    // optional uint32 army_count = 9;

    pub fn army_count(&self) -> u32 {
        self.army_count.unwrap_or(0)
    }

    pub fn clear_army_count(&mut self) {
        self.army_count = ::std::option::Option::None;
    }

    pub fn has_army_count(&self) -> bool {
        self.army_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_army_count(&mut self, v: u32) {
        self.army_count = ::std::option::Option::Some(v);
    }

    // optional uint32 warp_gate_count = 10;

    pub fn warp_gate_count(&self) -> u32 {
        self.warp_gate_count.unwrap_or(0)
    }

    pub fn clear_warp_gate_count(&mut self) {
        self.warp_gate_count = ::std::option::Option::None;
    }

    pub fn has_warp_gate_count(&self) -> bool {
        self.warp_gate_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warp_gate_count(&mut self, v: u32) {
        self.warp_gate_count = ::std::option::Option::Some(v);
    }

    // optional uint32 larva_count = 11;

    pub fn larva_count(&self) -> u32 {
        self.larva_count.unwrap_or(0)
    }

    pub fn clear_larva_count(&mut self) {
        self.larva_count = ::std::option::Option::None;
    }

    pub fn has_larva_count(&self) -> bool {
        self.larva_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_larva_count(&mut self, v: u32) {
        self.larva_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &PlayerCommon| { &m.player_id },
            |m: &mut PlayerCommon| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minerals",
            |m: &PlayerCommon| { &m.minerals },
            |m: &mut PlayerCommon| { &mut m.minerals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vespene",
            |m: &PlayerCommon| { &m.vespene },
            |m: &mut PlayerCommon| { &mut m.vespene },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "food_cap",
            |m: &PlayerCommon| { &m.food_cap },
            |m: &mut PlayerCommon| { &mut m.food_cap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "food_used",
            |m: &PlayerCommon| { &m.food_used },
            |m: &mut PlayerCommon| { &mut m.food_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "food_army",
            |m: &PlayerCommon| { &m.food_army },
            |m: &mut PlayerCommon| { &mut m.food_army },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "food_workers",
            |m: &PlayerCommon| { &m.food_workers },
            |m: &mut PlayerCommon| { &mut m.food_workers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idle_worker_count",
            |m: &PlayerCommon| { &m.idle_worker_count },
            |m: &mut PlayerCommon| { &mut m.idle_worker_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "army_count",
            |m: &PlayerCommon| { &m.army_count },
            |m: &mut PlayerCommon| { &mut m.army_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "warp_gate_count",
            |m: &PlayerCommon| { &m.warp_gate_count },
            |m: &mut PlayerCommon| { &mut m.warp_gate_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "larva_count",
            |m: &PlayerCommon| { &m.larva_count },
            |m: &mut PlayerCommon| { &mut m.larva_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerCommon>(
            "PlayerCommon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerCommon {
    const NAME: &'static str = "PlayerCommon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.minerals = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.vespene = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.food_cap = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.food_used = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.food_army = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.food_workers = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.idle_worker_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.army_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.warp_gate_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.larva_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.minerals {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.vespene {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.food_cap {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.food_used {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.food_army {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.food_workers {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.idle_worker_count {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.army_count {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.warp_gate_count {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.larva_count {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.minerals {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.vespene {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.food_cap {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.food_used {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.food_army {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.food_workers {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.idle_worker_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.army_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.warp_gate_count {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.larva_count {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerCommon {
        PlayerCommon::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.minerals = ::std::option::Option::None;
        self.vespene = ::std::option::Option::None;
        self.food_cap = ::std::option::Option::None;
        self.food_used = ::std::option::Option::None;
        self.food_army = ::std::option::Option::None;
        self.food_workers = ::std::option::Option::None;
        self.idle_worker_count = ::std::option::Option::None;
        self.army_count = ::std::option::Option::None;
        self.warp_gate_count = ::std::option::Option::None;
        self.larva_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerCommon {
        static instance: PlayerCommon = PlayerCommon {
            player_id: ::std::option::Option::None,
            minerals: ::std::option::Option::None,
            vespene: ::std::option::Option::None,
            food_cap: ::std::option::Option::None,
            food_used: ::std::option::Option::None,
            food_army: ::std::option::Option::None,
            food_workers: ::std::option::Option::None,
            idle_worker_count: ::std::option::Option::None,
            army_count: ::std::option::Option::None,
            warp_gate_count: ::std::option::Option::None,
            larva_count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerCommon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerCommon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerCommon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.Observation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Observation {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.game_loop)
    pub game_loop: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.player_common)
    pub player_common: ::protobuf::MessageField<PlayerCommon>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.alerts)
    pub alerts: ::std::vec::Vec<::protobuf::EnumOrUnknown<Alert>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.abilities)
    pub abilities: ::std::vec::Vec<super::common::AvailableAbility>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.score)
    pub score: ::protobuf::MessageField<super::score::Score>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.raw_data)
    pub raw_data: ::protobuf::MessageField<super::raw::ObservationRaw>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.feature_layer_data)
    pub feature_layer_data: ::protobuf::MessageField<super::spatial::ObservationFeatureLayer>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.render_data)
    pub render_data: ::protobuf::MessageField<super::spatial::ObservationRender>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Observation.ui_data)
    pub ui_data: ::protobuf::MessageField<super::ui::ObservationUI>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Observation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Observation {
    fn default() -> &'a Observation {
        <Observation as ::protobuf::Message>::default_instance()
    }
}

impl Observation {
    pub fn new() -> Observation {
        ::std::default::Default::default()
    }

    // optional uint32 game_loop = 9;

    pub fn game_loop(&self) -> u32 {
        self.game_loop.unwrap_or(0)
    }

    pub fn clear_game_loop(&mut self) {
        self.game_loop = ::std::option::Option::None;
    }

    pub fn has_game_loop(&self) -> bool {
        self.game_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_loop(&mut self, v: u32) {
        self.game_loop = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_loop",
            |m: &Observation| { &m.game_loop },
            |m: &mut Observation| { &mut m.game_loop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommon>(
            "player_common",
            |m: &Observation| { &m.player_common },
            |m: &mut Observation| { &mut m.player_common },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alerts",
            |m: &Observation| { &m.alerts },
            |m: &mut Observation| { &mut m.alerts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &Observation| { &m.abilities },
            |m: &mut Observation| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::score::Score>(
            "score",
            |m: &Observation| { &m.score },
            |m: &mut Observation| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::raw::ObservationRaw>(
            "raw_data",
            |m: &Observation| { &m.raw_data },
            |m: &mut Observation| { &mut m.raw_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spatial::ObservationFeatureLayer>(
            "feature_layer_data",
            |m: &Observation| { &m.feature_layer_data },
            |m: &mut Observation| { &mut m.feature_layer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spatial::ObservationRender>(
            "render_data",
            |m: &Observation| { &m.render_data },
            |m: &mut Observation| { &mut m.render_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ui::ObservationUI>(
            "ui_data",
            |m: &Observation| { &m.ui_data },
            |m: &mut Observation| { &mut m.ui_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Observation>(
            "Observation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Observation {
    const NAME: &'static str = "Observation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                72 => {
                    self.game_loop = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_common)?;
                },
                80 => {
                    self.alerts.push(is.read_enum_or_unknown()?);
                },
                82 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.alerts)?
                },
                26 => {
                    self.abilities.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.score)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.raw_data)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feature_layer_data)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.render_data)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ui_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_loop {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.player_common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.alerts {
            my_size += ::protobuf::rt::int32_size(10, value.value());
        };
        for value in &self.abilities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.score.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.raw_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.feature_layer_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.render_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_loop {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.player_common.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.alerts {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.abilities {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.score.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.raw_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.feature_layer_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.render_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.ui_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Observation {
        Observation::new()
    }

    fn clear(&mut self) {
        self.game_loop = ::std::option::Option::None;
        self.player_common.clear();
        self.alerts.clear();
        self.abilities.clear();
        self.score.clear();
        self.raw_data.clear();
        self.feature_layer_data.clear();
        self.render_data.clear();
        self.ui_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Observation {
        static instance: Observation = Observation {
            game_loop: ::std::option::Option::None,
            player_common: ::protobuf::MessageField::none(),
            alerts: ::std::vec::Vec::new(),
            abilities: ::std::vec::Vec::new(),
            score: ::protobuf::MessageField::none(),
            raw_data: ::protobuf::MessageField::none(),
            feature_layer_data: ::protobuf::MessageField::none(),
            render_data: ::protobuf::MessageField::none(),
            ui_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Observation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Observation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Observation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Observation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.Action)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Action {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.Action.action_raw)
    pub action_raw: ::protobuf::MessageField<super::raw::ActionRaw>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Action.action_feature_layer)
    pub action_feature_layer: ::protobuf::MessageField<super::spatial::ActionSpatial>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Action.action_render)
    pub action_render: ::protobuf::MessageField<super::spatial::ActionSpatial>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Action.action_ui)
    pub action_ui: ::protobuf::MessageField<super::ui::ActionUI>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Action.action_chat)
    pub action_chat: ::protobuf::MessageField<ActionChat>,
    // @@protoc_insertion_point(field:SC2APIProtocol.Action.game_loop)
    pub game_loop: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.Action.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Action {
    fn default() -> &'a Action {
        <Action as ::protobuf::Message>::default_instance()
    }
}

impl Action {
    pub fn new() -> Action {
        ::std::default::Default::default()
    }

    // optional uint32 game_loop = 7;

    pub fn game_loop(&self) -> u32 {
        self.game_loop.unwrap_or(0)
    }

    pub fn clear_game_loop(&mut self) {
        self.game_loop = ::std::option::Option::None;
    }

    pub fn has_game_loop(&self) -> bool {
        self.game_loop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_loop(&mut self, v: u32) {
        self.game_loop = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::raw::ActionRaw>(
            "action_raw",
            |m: &Action| { &m.action_raw },
            |m: &mut Action| { &mut m.action_raw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spatial::ActionSpatial>(
            "action_feature_layer",
            |m: &Action| { &m.action_feature_layer },
            |m: &mut Action| { &mut m.action_feature_layer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spatial::ActionSpatial>(
            "action_render",
            |m: &Action| { &m.action_render },
            |m: &mut Action| { &mut m.action_render },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ui::ActionUI>(
            "action_ui",
            |m: &Action| { &m.action_ui },
            |m: &mut Action| { &mut m.action_ui },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActionChat>(
            "action_chat",
            |m: &Action| { &m.action_chat },
            |m: &mut Action| { &mut m.action_chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_loop",
            |m: &Action| { &m.game_loop },
            |m: &mut Action| { &mut m.game_loop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Action>(
            "Action",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Action {
    const NAME: &'static str = "Action";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action_raw)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action_feature_layer)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action_render)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action_ui)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.action_chat)?;
                },
                56 => {
                    self.game_loop = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action_raw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.action_feature_layer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.action_render.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.action_ui.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.action_chat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_loop {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action_raw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.action_feature_layer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.action_render.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.action_ui.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.action_chat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.game_loop {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Action {
        Action::new()
    }

    fn clear(&mut self) {
        self.action_raw.clear();
        self.action_feature_layer.clear();
        self.action_render.clear();
        self.action_ui.clear();
        self.action_chat.clear();
        self.game_loop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Action {
        static instance: Action = Action {
            action_raw: ::protobuf::MessageField::none(),
            action_feature_layer: ::protobuf::MessageField::none(),
            action_render: ::protobuf::MessageField::none(),
            action_ui: ::protobuf::MessageField::none(),
            action_chat: ::protobuf::MessageField::none(),
            game_loop: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Action {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Action").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Action {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionChat {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionChat.channel)
    pub channel: ::std::option::Option<::protobuf::EnumOrUnknown<action_chat::Channel>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionChat.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionChat {
    fn default() -> &'a ActionChat {
        <ActionChat as ::protobuf::Message>::default_instance()
    }
}

impl ActionChat {
    pub fn new() -> ActionChat {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionChat.Channel channel = 1;

    pub fn channel(&self) -> action_chat::Channel {
        match self.channel {
            Some(e) => e.enum_value_or(action_chat::Channel::Broadcast),
            None => action_chat::Channel::Broadcast,
        }
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: action_chat::Channel) {
        self.channel = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &ActionChat| { &m.channel },
            |m: &mut ActionChat| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ActionChat| { &m.message },
            |m: &mut ActionChat| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionChat>(
            "ActionChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionChat {
    const NAME: &'static str = "ActionChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionChat {
        ActionChat::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionChat {
        static instance: ActionChat = ActionChat {
            channel: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionChat`
pub mod action_chat {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ActionChat.Channel)
    pub enum Channel {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionChat.Channel.Broadcast)
        Broadcast = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionChat.Channel.Team)
        Team = 2,
    }

    impl ::protobuf::Enum for Channel {
        const NAME: &'static str = "Channel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Channel> {
            match value {
                1 => ::std::option::Option::Some(Channel::Broadcast),
                2 => ::std::option::Option::Some(Channel::Team),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Channel> {
            match str {
                "Broadcast" => ::std::option::Option::Some(Channel::Broadcast),
                "Team" => ::std::option::Option::Some(Channel::Team),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Channel] = &[
            Channel::Broadcast,
            Channel::Team,
        ];
    }

    impl ::protobuf::EnumFull for Channel {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActionChat.Channel").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Channel::Broadcast => 0,
                Channel::Team => 1,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Channel {
        fn default() -> Self {
            Channel::Broadcast
        }
    }

    impl Channel {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Channel>("ActionChat.Channel")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionError {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionError.unit_tag)
    pub unit_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionError.ability_id)
    pub ability_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionError.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<super::error::ActionResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionError {
    fn default() -> &'a ActionError {
        <ActionError as ::protobuf::Message>::default_instance()
    }
}

impl ActionError {
    pub fn new() -> ActionError {
        ::std::default::Default::default()
    }

    // optional uint64 unit_tag = 1;

    pub fn unit_tag(&self) -> u64 {
        self.unit_tag.unwrap_or(0)
    }

    pub fn clear_unit_tag(&mut self) {
        self.unit_tag = ::std::option::Option::None;
    }

    pub fn has_unit_tag(&self) -> bool {
        self.unit_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_tag(&mut self, v: u64) {
        self.unit_tag = ::std::option::Option::Some(v);
    }

    // optional uint64 ability_id = 2;

    pub fn ability_id(&self) -> u64 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u64) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.ActionResult result = 3;

    pub fn result(&self) -> super::error::ActionResult {
        match self.result {
            Some(e) => e.enum_value_or(super::error::ActionResult::Success),
            None => super::error::ActionResult::Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::error::ActionResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_tag",
            |m: &ActionError| { &m.unit_tag },
            |m: &mut ActionError| { &mut m.unit_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &ActionError| { &m.ability_id },
            |m: &mut ActionError| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &ActionError| { &m.result },
            |m: &mut ActionError| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionError>(
            "ActionError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionError {
    const NAME: &'static str = "ActionError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_tag {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_tag {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionError {
        ActionError::new()
    }

    fn clear(&mut self) {
        self.unit_tag = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionError {
        static instance: ActionError = ActionError {
            unit_tag: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ObserverAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObserverAction {
    // message oneof groups
    pub action: ::std::option::Option<observer_action::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ObserverAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObserverAction {
    fn default() -> &'a ObserverAction {
        <ObserverAction as ::protobuf::Message>::default_instance()
    }
}

impl ObserverAction {
    pub fn new() -> ObserverAction {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionObserverPlayerPerspective player_perspective = 1;

    pub fn player_perspective(&self) -> &ActionObserverPlayerPerspective {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::PlayerPerspective(ref v)) => v,
            _ => <ActionObserverPlayerPerspective as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_player_perspective(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_player_perspective(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::PlayerPerspective(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_player_perspective(&mut self, v: ActionObserverPlayerPerspective) {
        self.action = ::std::option::Option::Some(observer_action::Action::PlayerPerspective(v))
    }

    // Mutable pointer to the field.
    pub fn mut_player_perspective(&mut self) -> &mut ActionObserverPlayerPerspective {
        if let ::std::option::Option::Some(observer_action::Action::PlayerPerspective(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(observer_action::Action::PlayerPerspective(ActionObserverPlayerPerspective::new()));
        }
        match self.action {
            ::std::option::Option::Some(observer_action::Action::PlayerPerspective(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_player_perspective(&mut self) -> ActionObserverPlayerPerspective {
        if self.has_player_perspective() {
            match self.action.take() {
                ::std::option::Option::Some(observer_action::Action::PlayerPerspective(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverPlayerPerspective::new()
        }
    }

    // optional .SC2APIProtocol.ActionObserverCameraMove camera_move = 2;

    pub fn camera_move(&self) -> &ActionObserverCameraMove {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraMove(ref v)) => v,
            _ => <ActionObserverCameraMove as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_camera_move(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_move(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraMove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_move(&mut self, v: ActionObserverCameraMove) {
        self.action = ::std::option::Option::Some(observer_action::Action::CameraMove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_move(&mut self) -> &mut ActionObserverCameraMove {
        if let ::std::option::Option::Some(observer_action::Action::CameraMove(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(observer_action::Action::CameraMove(ActionObserverCameraMove::new()));
        }
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraMove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_move(&mut self) -> ActionObserverCameraMove {
        if self.has_camera_move() {
            match self.action.take() {
                ::std::option::Option::Some(observer_action::Action::CameraMove(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverCameraMove::new()
        }
    }

    // optional .SC2APIProtocol.ActionObserverCameraFollowPlayer camera_follow_player = 3;

    pub fn camera_follow_player(&self) -> &ActionObserverCameraFollowPlayer {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(ref v)) => v,
            _ => <ActionObserverCameraFollowPlayer as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_camera_follow_player(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_follow_player(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_follow_player(&mut self, v: ActionObserverCameraFollowPlayer) {
        self.action = ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_follow_player(&mut self) -> &mut ActionObserverCameraFollowPlayer {
        if let ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(ActionObserverCameraFollowPlayer::new()));
        }
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_follow_player(&mut self) -> ActionObserverCameraFollowPlayer {
        if self.has_camera_follow_player() {
            match self.action.take() {
                ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverCameraFollowPlayer::new()
        }
    }

    // optional .SC2APIProtocol.ActionObserverCameraFollowUnits camera_follow_units = 4;

    pub fn camera_follow_units(&self) -> &ActionObserverCameraFollowUnits {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(ref v)) => v,
            _ => <ActionObserverCameraFollowUnits as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_camera_follow_units(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_camera_follow_units(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_camera_follow_units(&mut self, v: ActionObserverCameraFollowUnits) {
        self.action = ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(v))
    }

    // Mutable pointer to the field.
    pub fn mut_camera_follow_units(&mut self) -> &mut ActionObserverCameraFollowUnits {
        if let ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(ActionObserverCameraFollowUnits::new()));
        }
        match self.action {
            ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_camera_follow_units(&mut self) -> ActionObserverCameraFollowUnits {
        if self.has_camera_follow_units() {
            match self.action.take() {
                ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionObserverCameraFollowUnits::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionObserverPlayerPerspective>(
            "player_perspective",
            ObserverAction::has_player_perspective,
            ObserverAction::player_perspective,
            ObserverAction::mut_player_perspective,
            ObserverAction::set_player_perspective,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionObserverCameraMove>(
            "camera_move",
            ObserverAction::has_camera_move,
            ObserverAction::camera_move,
            ObserverAction::mut_camera_move,
            ObserverAction::set_camera_move,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionObserverCameraFollowPlayer>(
            "camera_follow_player",
            ObserverAction::has_camera_follow_player,
            ObserverAction::camera_follow_player,
            ObserverAction::mut_camera_follow_player,
            ObserverAction::set_camera_follow_player,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionObserverCameraFollowUnits>(
            "camera_follow_units",
            ObserverAction::has_camera_follow_units,
            ObserverAction::camera_follow_units,
            ObserverAction::mut_camera_follow_units,
            ObserverAction::set_camera_follow_units,
        ));
        oneofs.push(observer_action::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObserverAction>(
            "ObserverAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObserverAction {
    const NAME: &'static str = "ObserverAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.action = ::std::option::Option::Some(observer_action::Action::PlayerPerspective(is.read_message()?));
                },
                18 => {
                    self.action = ::std::option::Option::Some(observer_action::Action::CameraMove(is.read_message()?));
                },
                26 => {
                    self.action = ::std::option::Option::Some(observer_action::Action::CameraFollowPlayer(is.read_message()?));
                },
                34 => {
                    self.action = ::std::option::Option::Some(observer_action::Action::CameraFollowUnits(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &observer_action::Action::PlayerPerspective(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &observer_action::Action::CameraMove(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &observer_action::Action::CameraFollowPlayer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &observer_action::Action::CameraFollowUnits(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &observer_action::Action::PlayerPerspective(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &observer_action::Action::CameraMove(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &observer_action::Action::CameraFollowPlayer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &observer_action::Action::CameraFollowUnits(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObserverAction {
        ObserverAction::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObserverAction {
        static instance: ObserverAction = ObserverAction {
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObserverAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObserverAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObserverAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObserverAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ObserverAction`
pub mod observer_action {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ObserverAction.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObserverAction.player_perspective)
        PlayerPerspective(super::ActionObserverPlayerPerspective),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObserverAction.camera_move)
        CameraMove(super::ActionObserverCameraMove),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObserverAction.camera_follow_player)
        CameraFollowPlayer(super::ActionObserverCameraFollowPlayer),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObserverAction.camera_follow_units)
        CameraFollowUnits(super::ActionObserverCameraFollowUnits),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ObserverAction as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionObserverPlayerPerspective)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionObserverPlayerPerspective {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionObserverPlayerPerspective.player_id)
    pub player_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionObserverPlayerPerspective.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionObserverPlayerPerspective {
    fn default() -> &'a ActionObserverPlayerPerspective {
        <ActionObserverPlayerPerspective as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverPlayerPerspective {
    pub fn new() -> ActionObserverPlayerPerspective {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &ActionObserverPlayerPerspective| { &m.player_id },
            |m: &mut ActionObserverPlayerPerspective| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionObserverPlayerPerspective>(
            "ActionObserverPlayerPerspective",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionObserverPlayerPerspective {
    const NAME: &'static str = "ActionObserverPlayerPerspective";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionObserverPlayerPerspective {
        ActionObserverPlayerPerspective::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionObserverPlayerPerspective {
        static instance: ActionObserverPlayerPerspective = ActionObserverPlayerPerspective {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionObserverPlayerPerspective {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionObserverPlayerPerspective").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionObserverPlayerPerspective {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverPlayerPerspective {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionObserverCameraMove)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionObserverCameraMove {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionObserverCameraMove.world_pos)
    pub world_pos: ::protobuf::MessageField<super::common::Point2D>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionObserverCameraMove.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionObserverCameraMove.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionObserverCameraMove {
    fn default() -> &'a ActionObserverCameraMove {
        <ActionObserverCameraMove as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverCameraMove {
    pub fn new() -> ActionObserverCameraMove {
        ::std::default::Default::default()
    }

    // optional float distance = 2;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::common::Point2D>(
            "world_pos",
            |m: &ActionObserverCameraMove| { &m.world_pos },
            |m: &mut ActionObserverCameraMove| { &mut m.world_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance",
            |m: &ActionObserverCameraMove| { &m.distance },
            |m: &mut ActionObserverCameraMove| { &mut m.distance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionObserverCameraMove>(
            "ActionObserverCameraMove",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionObserverCameraMove {
    const NAME: &'static str = "ActionObserverCameraMove";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.world_pos)?;
                },
                21 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.world_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.distance {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionObserverCameraMove {
        ActionObserverCameraMove::new()
    }

    fn clear(&mut self) {
        self.world_pos.clear();
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionObserverCameraMove {
        static instance: ActionObserverCameraMove = ActionObserverCameraMove {
            world_pos: ::protobuf::MessageField::none(),
            distance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionObserverCameraMove {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionObserverCameraMove").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionObserverCameraMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverCameraMove {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionObserverCameraFollowPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionObserverCameraFollowPlayer {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionObserverCameraFollowPlayer.player_id)
    pub player_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionObserverCameraFollowPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionObserverCameraFollowPlayer {
    fn default() -> &'a ActionObserverCameraFollowPlayer {
        <ActionObserverCameraFollowPlayer as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverCameraFollowPlayer {
    pub fn new() -> ActionObserverCameraFollowPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &ActionObserverCameraFollowPlayer| { &m.player_id },
            |m: &mut ActionObserverCameraFollowPlayer| { &mut m.player_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionObserverCameraFollowPlayer>(
            "ActionObserverCameraFollowPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionObserverCameraFollowPlayer {
    const NAME: &'static str = "ActionObserverCameraFollowPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionObserverCameraFollowPlayer {
        ActionObserverCameraFollowPlayer::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionObserverCameraFollowPlayer {
        static instance: ActionObserverCameraFollowPlayer = ActionObserverCameraFollowPlayer {
            player_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionObserverCameraFollowPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionObserverCameraFollowPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionObserverCameraFollowPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverCameraFollowPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.ActionObserverCameraFollowUnits)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActionObserverCameraFollowUnits {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionObserverCameraFollowUnits.unit_tags)
    pub unit_tags: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionObserverCameraFollowUnits.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionObserverCameraFollowUnits {
    fn default() -> &'a ActionObserverCameraFollowUnits {
        <ActionObserverCameraFollowUnits as ::protobuf::Message>::default_instance()
    }
}

impl ActionObserverCameraFollowUnits {
    pub fn new() -> ActionObserverCameraFollowUnits {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "unit_tags",
            |m: &ActionObserverCameraFollowUnits| { &m.unit_tags },
            |m: &mut ActionObserverCameraFollowUnits| { &mut m.unit_tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionObserverCameraFollowUnits>(
            "ActionObserverCameraFollowUnits",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionObserverCameraFollowUnits {
    const NAME: &'static str = "ActionObserverCameraFollowUnits";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.unit_tags)?;
                },
                8 => {
                    self.unit_tags.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.unit_tags {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.unit_tags {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionObserverCameraFollowUnits {
        ActionObserverCameraFollowUnits::new()
    }

    fn clear(&mut self) {
        self.unit_tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionObserverCameraFollowUnits {
        static instance: ActionObserverCameraFollowUnits = ActionObserverCameraFollowUnits {
            unit_tags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionObserverCameraFollowUnits {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionObserverCameraFollowUnits").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionObserverCameraFollowUnits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionObserverCameraFollowUnits {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SC2APIProtocol.PlayerResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerResult {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerResult.player_id)
    pub player_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.PlayerResult.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.PlayerResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerResult {
    fn default() -> &'a PlayerResult {
        <PlayerResult as ::protobuf::Message>::default_instance()
    }
}

impl PlayerResult {
    pub fn new() -> PlayerResult {
        ::std::default::Default::default()
    }

    // optional uint32 player_id = 1;

    pub fn player_id(&self) -> u32 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u32) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional .SC2APIProtocol.Result result = 2;

    pub fn result(&self) -> Result {
        match self.result {
            Some(e) => e.enum_value_or(Result::Victory),
            None => Result::Victory,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: Result) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_id",
            |m: &PlayerResult| { &m.player_id },
            |m: &mut PlayerResult| { &mut m.player_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &PlayerResult| { &m.result },
            |m: &mut PlayerResult| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerResult>(
            "PlayerResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerResult {
    const NAME: &'static str = "PlayerResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerResult {
        PlayerResult::new()
    }

    fn clear(&mut self) {
        self.player_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerResult {
        static instance: PlayerResult = PlayerResult {
            player_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.Status)
pub enum Status {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.launched)
    launched = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.init_game)
    init_game = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.in_game)
    in_game = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.in_replay)
    in_replay = 4,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.ended)
    ended = 5,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.quit)
    quit = 6,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Status.unknown)
    unknown = 99,
}

impl ::protobuf::Enum for Status {
    const NAME: &'static str = "Status";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            1 => ::std::option::Option::Some(Status::launched),
            2 => ::std::option::Option::Some(Status::init_game),
            3 => ::std::option::Option::Some(Status::in_game),
            4 => ::std::option::Option::Some(Status::in_replay),
            5 => ::std::option::Option::Some(Status::ended),
            6 => ::std::option::Option::Some(Status::quit),
            99 => ::std::option::Option::Some(Status::unknown),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Status> {
        match str {
            "launched" => ::std::option::Option::Some(Status::launched),
            "init_game" => ::std::option::Option::Some(Status::init_game),
            "in_game" => ::std::option::Option::Some(Status::in_game),
            "in_replay" => ::std::option::Option::Some(Status::in_replay),
            "ended" => ::std::option::Option::Some(Status::ended),
            "quit" => ::std::option::Option::Some(Status::quit),
            "unknown" => ::std::option::Option::Some(Status::unknown),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Status] = &[
        Status::launched,
        Status::init_game,
        Status::in_game,
        Status::in_replay,
        Status::ended,
        Status::quit,
        Status::unknown,
    ];
}

impl ::protobuf::EnumFull for Status {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Status").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Status::launched => 0,
            Status::init_game => 1,
            Status::in_game => 2,
            Status::in_replay => 3,
            Status::ended => 4,
            Status::quit => 5,
            Status::unknown => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::launched
    }
}

impl Status {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("Status")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.Difficulty)
pub enum Difficulty {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.VeryEasy)
    VeryEasy = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.Easy)
    Easy = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.Medium)
    Medium = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.MediumHard)
    MediumHard = 4,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.Hard)
    Hard = 5,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.Harder)
    Harder = 6,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.VeryHard)
    VeryHard = 7,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.CheatVision)
    CheatVision = 8,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.CheatMoney)
    CheatMoney = 9,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Difficulty.CheatInsane)
    CheatInsane = 10,
}

impl ::protobuf::Enum for Difficulty {
    const NAME: &'static str = "Difficulty";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Difficulty> {
        match value {
            1 => ::std::option::Option::Some(Difficulty::VeryEasy),
            2 => ::std::option::Option::Some(Difficulty::Easy),
            3 => ::std::option::Option::Some(Difficulty::Medium),
            4 => ::std::option::Option::Some(Difficulty::MediumHard),
            5 => ::std::option::Option::Some(Difficulty::Hard),
            6 => ::std::option::Option::Some(Difficulty::Harder),
            7 => ::std::option::Option::Some(Difficulty::VeryHard),
            8 => ::std::option::Option::Some(Difficulty::CheatVision),
            9 => ::std::option::Option::Some(Difficulty::CheatMoney),
            10 => ::std::option::Option::Some(Difficulty::CheatInsane),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Difficulty> {
        match str {
            "VeryEasy" => ::std::option::Option::Some(Difficulty::VeryEasy),
            "Easy" => ::std::option::Option::Some(Difficulty::Easy),
            "Medium" => ::std::option::Option::Some(Difficulty::Medium),
            "MediumHard" => ::std::option::Option::Some(Difficulty::MediumHard),
            "Hard" => ::std::option::Option::Some(Difficulty::Hard),
            "Harder" => ::std::option::Option::Some(Difficulty::Harder),
            "VeryHard" => ::std::option::Option::Some(Difficulty::VeryHard),
            "CheatVision" => ::std::option::Option::Some(Difficulty::CheatVision),
            "CheatMoney" => ::std::option::Option::Some(Difficulty::CheatMoney),
            "CheatInsane" => ::std::option::Option::Some(Difficulty::CheatInsane),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Difficulty] = &[
        Difficulty::VeryEasy,
        Difficulty::Easy,
        Difficulty::Medium,
        Difficulty::MediumHard,
        Difficulty::Hard,
        Difficulty::Harder,
        Difficulty::VeryHard,
        Difficulty::CheatVision,
        Difficulty::CheatMoney,
        Difficulty::CheatInsane,
    ];
}

impl ::protobuf::EnumFull for Difficulty {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Difficulty").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Difficulty::VeryEasy => 0,
            Difficulty::Easy => 1,
            Difficulty::Medium => 2,
            Difficulty::MediumHard => 3,
            Difficulty::Hard => 4,
            Difficulty::Harder => 5,
            Difficulty::VeryHard => 6,
            Difficulty::CheatVision => 7,
            Difficulty::CheatMoney => 8,
            Difficulty::CheatInsane => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Difficulty {
    fn default() -> Self {
        Difficulty::VeryEasy
    }
}

impl Difficulty {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Difficulty>("Difficulty")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.PlayerType)
pub enum PlayerType {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.PlayerType.Participant)
    Participant = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.PlayerType.Computer)
    Computer = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.PlayerType.Observer)
    Observer = 3,
}

impl ::protobuf::Enum for PlayerType {
    const NAME: &'static str = "PlayerType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlayerType> {
        match value {
            1 => ::std::option::Option::Some(PlayerType::Participant),
            2 => ::std::option::Option::Some(PlayerType::Computer),
            3 => ::std::option::Option::Some(PlayerType::Observer),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PlayerType> {
        match str {
            "Participant" => ::std::option::Option::Some(PlayerType::Participant),
            "Computer" => ::std::option::Option::Some(PlayerType::Computer),
            "Observer" => ::std::option::Option::Some(PlayerType::Observer),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PlayerType] = &[
        PlayerType::Participant,
        PlayerType::Computer,
        PlayerType::Observer,
    ];
}

impl ::protobuf::EnumFull for PlayerType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PlayerType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PlayerType::Participant => 0,
            PlayerType::Computer => 1,
            PlayerType::Observer => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PlayerType {
    fn default() -> Self {
        PlayerType::Participant
    }
}

impl PlayerType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PlayerType>("PlayerType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.AIBuild)
pub enum AIBuild {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.AIBuild.RandomBuild)
    RandomBuild = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.AIBuild.Rush)
    Rush = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.AIBuild.Timing)
    Timing = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.AIBuild.Power)
    Power = 4,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.AIBuild.Macro)
    Macro = 5,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.AIBuild.Air)
    Air = 6,
}

impl ::protobuf::Enum for AIBuild {
    const NAME: &'static str = "AIBuild";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AIBuild> {
        match value {
            1 => ::std::option::Option::Some(AIBuild::RandomBuild),
            2 => ::std::option::Option::Some(AIBuild::Rush),
            3 => ::std::option::Option::Some(AIBuild::Timing),
            4 => ::std::option::Option::Some(AIBuild::Power),
            5 => ::std::option::Option::Some(AIBuild::Macro),
            6 => ::std::option::Option::Some(AIBuild::Air),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AIBuild> {
        match str {
            "RandomBuild" => ::std::option::Option::Some(AIBuild::RandomBuild),
            "Rush" => ::std::option::Option::Some(AIBuild::Rush),
            "Timing" => ::std::option::Option::Some(AIBuild::Timing),
            "Power" => ::std::option::Option::Some(AIBuild::Power),
            "Macro" => ::std::option::Option::Some(AIBuild::Macro),
            "Air" => ::std::option::Option::Some(AIBuild::Air),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AIBuild] = &[
        AIBuild::RandomBuild,
        AIBuild::Rush,
        AIBuild::Timing,
        AIBuild::Power,
        AIBuild::Macro,
        AIBuild::Air,
    ];
}

impl ::protobuf::EnumFull for AIBuild {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AIBuild").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            AIBuild::RandomBuild => 0,
            AIBuild::Rush => 1,
            AIBuild::Timing => 2,
            AIBuild::Power => 3,
            AIBuild::Macro => 4,
            AIBuild::Air => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for AIBuild {
    fn default() -> Self {
        AIBuild::RandomBuild
    }
}

impl AIBuild {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AIBuild>("AIBuild")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.Alert)
pub enum Alert {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.AlertError)
    AlertError = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.AddOnComplete)
    AddOnComplete = 4,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.BuildingComplete)
    BuildingComplete = 5,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.BuildingUnderAttack)
    BuildingUnderAttack = 6,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.LarvaHatched)
    LarvaHatched = 7,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.MergeComplete)
    MergeComplete = 8,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.MineralsExhausted)
    MineralsExhausted = 9,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.MorphComplete)
    MorphComplete = 10,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.MothershipComplete)
    MothershipComplete = 11,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.MULEExpired)
    MULEExpired = 12,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.NuclearLaunchDetected)
    NuclearLaunchDetected = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.NukeComplete)
    NukeComplete = 13,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.NydusWormDetected)
    NydusWormDetected = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.ResearchComplete)
    ResearchComplete = 14,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.TrainError)
    TrainError = 15,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.TrainUnitComplete)
    TrainUnitComplete = 16,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.TrainWorkerComplete)
    TrainWorkerComplete = 17,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.TransformationComplete)
    TransformationComplete = 18,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.UnitUnderAttack)
    UnitUnderAttack = 19,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.UpgradeComplete)
    UpgradeComplete = 20,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.VespeneExhausted)
    VespeneExhausted = 21,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Alert.WarpInComplete)
    WarpInComplete = 22,
}

impl ::protobuf::Enum for Alert {
    const NAME: &'static str = "Alert";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Alert> {
        match value {
            3 => ::std::option::Option::Some(Alert::AlertError),
            4 => ::std::option::Option::Some(Alert::AddOnComplete),
            5 => ::std::option::Option::Some(Alert::BuildingComplete),
            6 => ::std::option::Option::Some(Alert::BuildingUnderAttack),
            7 => ::std::option::Option::Some(Alert::LarvaHatched),
            8 => ::std::option::Option::Some(Alert::MergeComplete),
            9 => ::std::option::Option::Some(Alert::MineralsExhausted),
            10 => ::std::option::Option::Some(Alert::MorphComplete),
            11 => ::std::option::Option::Some(Alert::MothershipComplete),
            12 => ::std::option::Option::Some(Alert::MULEExpired),
            1 => ::std::option::Option::Some(Alert::NuclearLaunchDetected),
            13 => ::std::option::Option::Some(Alert::NukeComplete),
            2 => ::std::option::Option::Some(Alert::NydusWormDetected),
            14 => ::std::option::Option::Some(Alert::ResearchComplete),
            15 => ::std::option::Option::Some(Alert::TrainError),
            16 => ::std::option::Option::Some(Alert::TrainUnitComplete),
            17 => ::std::option::Option::Some(Alert::TrainWorkerComplete),
            18 => ::std::option::Option::Some(Alert::TransformationComplete),
            19 => ::std::option::Option::Some(Alert::UnitUnderAttack),
            20 => ::std::option::Option::Some(Alert::UpgradeComplete),
            21 => ::std::option::Option::Some(Alert::VespeneExhausted),
            22 => ::std::option::Option::Some(Alert::WarpInComplete),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Alert> {
        match str {
            "AlertError" => ::std::option::Option::Some(Alert::AlertError),
            "AddOnComplete" => ::std::option::Option::Some(Alert::AddOnComplete),
            "BuildingComplete" => ::std::option::Option::Some(Alert::BuildingComplete),
            "BuildingUnderAttack" => ::std::option::Option::Some(Alert::BuildingUnderAttack),
            "LarvaHatched" => ::std::option::Option::Some(Alert::LarvaHatched),
            "MergeComplete" => ::std::option::Option::Some(Alert::MergeComplete),
            "MineralsExhausted" => ::std::option::Option::Some(Alert::MineralsExhausted),
            "MorphComplete" => ::std::option::Option::Some(Alert::MorphComplete),
            "MothershipComplete" => ::std::option::Option::Some(Alert::MothershipComplete),
            "MULEExpired" => ::std::option::Option::Some(Alert::MULEExpired),
            "NuclearLaunchDetected" => ::std::option::Option::Some(Alert::NuclearLaunchDetected),
            "NukeComplete" => ::std::option::Option::Some(Alert::NukeComplete),
            "NydusWormDetected" => ::std::option::Option::Some(Alert::NydusWormDetected),
            "ResearchComplete" => ::std::option::Option::Some(Alert::ResearchComplete),
            "TrainError" => ::std::option::Option::Some(Alert::TrainError),
            "TrainUnitComplete" => ::std::option::Option::Some(Alert::TrainUnitComplete),
            "TrainWorkerComplete" => ::std::option::Option::Some(Alert::TrainWorkerComplete),
            "TransformationComplete" => ::std::option::Option::Some(Alert::TransformationComplete),
            "UnitUnderAttack" => ::std::option::Option::Some(Alert::UnitUnderAttack),
            "UpgradeComplete" => ::std::option::Option::Some(Alert::UpgradeComplete),
            "VespeneExhausted" => ::std::option::Option::Some(Alert::VespeneExhausted),
            "WarpInComplete" => ::std::option::Option::Some(Alert::WarpInComplete),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Alert] = &[
        Alert::AlertError,
        Alert::AddOnComplete,
        Alert::BuildingComplete,
        Alert::BuildingUnderAttack,
        Alert::LarvaHatched,
        Alert::MergeComplete,
        Alert::MineralsExhausted,
        Alert::MorphComplete,
        Alert::MothershipComplete,
        Alert::MULEExpired,
        Alert::NuclearLaunchDetected,
        Alert::NukeComplete,
        Alert::NydusWormDetected,
        Alert::ResearchComplete,
        Alert::TrainError,
        Alert::TrainUnitComplete,
        Alert::TrainWorkerComplete,
        Alert::TransformationComplete,
        Alert::UnitUnderAttack,
        Alert::UpgradeComplete,
        Alert::VespeneExhausted,
        Alert::WarpInComplete,
    ];
}

impl ::protobuf::EnumFull for Alert {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Alert").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Alert::AlertError => 0,
            Alert::AddOnComplete => 1,
            Alert::BuildingComplete => 2,
            Alert::BuildingUnderAttack => 3,
            Alert::LarvaHatched => 4,
            Alert::MergeComplete => 5,
            Alert::MineralsExhausted => 6,
            Alert::MorphComplete => 7,
            Alert::MothershipComplete => 8,
            Alert::MULEExpired => 9,
            Alert::NuclearLaunchDetected => 10,
            Alert::NukeComplete => 11,
            Alert::NydusWormDetected => 12,
            Alert::ResearchComplete => 13,
            Alert::TrainError => 14,
            Alert::TrainUnitComplete => 15,
            Alert::TrainWorkerComplete => 16,
            Alert::TransformationComplete => 17,
            Alert::UnitUnderAttack => 18,
            Alert::UpgradeComplete => 19,
            Alert::VespeneExhausted => 20,
            Alert::WarpInComplete => 21,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Alert {
    fn default() -> Self {
        Alert::AlertError
    }
}

impl Alert {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Alert>("Alert")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SC2APIProtocol.Result)
pub enum Result {
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Result.Victory)
    Victory = 1,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Result.Defeat)
    Defeat = 2,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Result.Tie)
    Tie = 3,
    // @@protoc_insertion_point(enum_value:SC2APIProtocol.Result.Undecided)
    Undecided = 4,
}

impl ::protobuf::Enum for Result {
    const NAME: &'static str = "Result";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Result> {
        match value {
            1 => ::std::option::Option::Some(Result::Victory),
            2 => ::std::option::Option::Some(Result::Defeat),
            3 => ::std::option::Option::Some(Result::Tie),
            4 => ::std::option::Option::Some(Result::Undecided),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Result> {
        match str {
            "Victory" => ::std::option::Option::Some(Result::Victory),
            "Defeat" => ::std::option::Option::Some(Result::Defeat),
            "Tie" => ::std::option::Option::Some(Result::Tie),
            "Undecided" => ::std::option::Option::Some(Result::Undecided),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Result] = &[
        Result::Victory,
        Result::Defeat,
        Result::Tie,
        Result::Undecided,
    ];
}

impl ::protobuf::EnumFull for Result {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Result").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Result::Victory => 0,
            Result::Defeat => 1,
            Result::Tie => 2,
            Result::Undecided => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Result {
    fn default() -> Self {
        Result::Victory
    }
}

impl Result {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Result>("Result")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ds2clientprotocol/sc2api.proto\x12\x0eSC2APIProtocol\x1a\x1ds2clien\
    tprotocol/common.proto\x1a\x1bs2clientprotocol/data.proto\x1a\x1cs2clien\
    tprotocol/debug.proto\x1a\x1cs2clientprotocol/error.proto\x1a\x1cs2clien\
    tprotocol/query.proto\x1a\x1as2clientprotocol/raw.proto\x1a\x1cs2clientp\
    rotocol/score.proto\x1a\x1es2clientprotocol/spatial.proto\x1a\x19s2clien\
    tprotocol/ui.proto\"\xa4\x0b\n\x07Request\x12D\n\x0bcreate_game\x18\x01\
    \x20\x01(\x0b2!.SC2APIProtocol.RequestCreateGameH\0R\ncreateGame\x12>\n\
    \tjoin_game\x18\x02\x20\x01(\x0b2\x1f.SC2APIProtocol.RequestJoinGameH\0R\
    \x08joinGame\x12G\n\x0crestart_game\x18\x03\x20\x01(\x0b2\".SC2APIProtoc\
    ol.RequestRestartGameH\0R\x0brestartGame\x12G\n\x0cstart_replay\x18\x04\
    \x20\x01(\x0b2\".SC2APIProtocol.RequestStartReplayH\0R\x0bstartReplay\
    \x12A\n\nleave_game\x18\x05\x20\x01(\x0b2\x20.SC2APIProtocol.RequestLeav\
    eGameH\0R\tleaveGame\x12A\n\nquick_save\x18\x06\x20\x01(\x0b2\x20.SC2API\
    Protocol.RequestQuickSaveH\0R\tquickSave\x12A\n\nquick_load\x18\x07\x20\
    \x01(\x0b2\x20.SC2APIProtocol.RequestQuickLoadH\0R\tquickLoad\x121\n\x04\
    quit\x18\x08\x20\x01(\x0b2\x1b.SC2APIProtocol.RequestQuitH\0R\x04quit\
    \x12>\n\tgame_info\x18\t\x20\x01(\x0b2\x1f.SC2APIProtocol.RequestGameInf\
    oH\0R\x08gameInfo\x12F\n\x0bobservation\x18\n\x20\x01(\x0b2\".SC2APIProt\
    ocol.RequestObservationH\0R\x0bobservation\x127\n\x06action\x18\x0b\x20\
    \x01(\x0b2\x1d.SC2APIProtocol.RequestActionH\0R\x06action\x12F\n\nobs_ac\
    tion\x18\x15\x20\x01(\x0b2%.SC2APIProtocol.RequestObserverActionH\0R\tob\
    sAction\x121\n\x04step\x18\x0c\x20\x01(\x0b2\x1b.SC2APIProtocol.RequestS\
    tepH\0R\x04step\x121\n\x04data\x18\r\x20\x01(\x0b2\x1b.SC2APIProtocol.Re\
    questDataH\0R\x04data\x124\n\x05query\x18\x0e\x20\x01(\x0b2\x1c.SC2APIPr\
    otocol.RequestQueryH\0R\x05query\x12D\n\x0bsave_replay\x18\x0f\x20\x01(\
    \x0b2!.SC2APIProtocol.RequestSaveReplayH\0R\nsaveReplay\x12D\n\x0bmap_co\
    mmand\x18\x16\x20\x01(\x0b2!.SC2APIProtocol.RequestMapCommandH\0R\nmapCo\
    mmand\x12D\n\x0breplay_info\x18\x10\x20\x01(\x0b2!.SC2APIProtocol.Reques\
    tReplayInfoH\0R\nreplayInfo\x12M\n\x0eavailable_maps\x18\x11\x20\x01(\
    \x0b2$.SC2APIProtocol.RequestAvailableMapsH\0R\ravailableMaps\x12;\n\x08\
    save_map\x18\x12\x20\x01(\x0b2\x1e.SC2APIProtocol.RequestSaveMapH\0R\x07\
    saveMap\x121\n\x04ping\x18\x13\x20\x01(\x0b2\x1b.SC2APIProtocol.RequestP\
    ingH\0R\x04ping\x124\n\x05debug\x18\x14\x20\x01(\x0b2\x1c.SC2APIProtocol\
    .RequestDebugH\0R\x05debug\x12\x0e\n\x02id\x18a\x20\x01(\rR\x02idB\t\n\
    \x07request\"\x82\x0c\n\x08Response\x12E\n\x0bcreate_game\x18\x01\x20\
    \x01(\x0b2\".SC2APIProtocol.ResponseCreateGameH\0R\ncreateGame\x12?\n\tj\
    oin_game\x18\x02\x20\x01(\x0b2\x20.SC2APIProtocol.ResponseJoinGameH\0R\
    \x08joinGame\x12H\n\x0crestart_game\x18\x03\x20\x01(\x0b2#.SC2APIProtoco\
    l.ResponseRestartGameH\0R\x0brestartGame\x12H\n\x0cstart_replay\x18\x04\
    \x20\x01(\x0b2#.SC2APIProtocol.ResponseStartReplayH\0R\x0bstartReplay\
    \x12B\n\nleave_game\x18\x05\x20\x01(\x0b2!.SC2APIProtocol.ResponseLeaveG\
    ameH\0R\tleaveGame\x12B\n\nquick_save\x18\x06\x20\x01(\x0b2!.SC2APIProto\
    col.ResponseQuickSaveH\0R\tquickSave\x12B\n\nquick_load\x18\x07\x20\x01(\
    \x0b2!.SC2APIProtocol.ResponseQuickLoadH\0R\tquickLoad\x122\n\x04quit\
    \x18\x08\x20\x01(\x0b2\x1c.SC2APIProtocol.ResponseQuitH\0R\x04quit\x12?\
    \n\tgame_info\x18\t\x20\x01(\x0b2\x20.SC2APIProtocol.ResponseGameInfoH\0\
    R\x08gameInfo\x12G\n\x0bobservation\x18\n\x20\x01(\x0b2#.SC2APIProtocol.\
    ResponseObservationH\0R\x0bobservation\x128\n\x06action\x18\x0b\x20\x01(\
    \x0b2\x1e.SC2APIProtocol.ResponseActionH\0R\x06action\x12G\n\nobs_action\
    \x18\x15\x20\x01(\x0b2&.SC2APIProtocol.ResponseObserverActionH\0R\tobsAc\
    tion\x122\n\x04step\x18\x0c\x20\x01(\x0b2\x1c.SC2APIProtocol.ResponseSte\
    pH\0R\x04step\x122\n\x04data\x18\r\x20\x01(\x0b2\x1c.SC2APIProtocol.Resp\
    onseDataH\0R\x04data\x125\n\x05query\x18\x0e\x20\x01(\x0b2\x1d.SC2APIPro\
    tocol.ResponseQueryH\0R\x05query\x12E\n\x0bsave_replay\x18\x0f\x20\x01(\
    \x0b2\".SC2APIProtocol.ResponseSaveReplayH\0R\nsaveReplay\x12E\n\x0brepl\
    ay_info\x18\x10\x20\x01(\x0b2\".SC2APIProtocol.ResponseReplayInfoH\0R\nr\
    eplayInfo\x12N\n\x0eavailable_maps\x18\x11\x20\x01(\x0b2%.SC2APIProtocol\
    .ResponseAvailableMapsH\0R\ravailableMaps\x12<\n\x08save_map\x18\x12\x20\
    \x01(\x0b2\x1f.SC2APIProtocol.ResponseSaveMapH\0R\x07saveMap\x12E\n\x0bm\
    ap_command\x18\x16\x20\x01(\x0b2\".SC2APIProtocol.ResponseMapCommandH\0R\
    \nmapCommand\x122\n\x04ping\x18\x13\x20\x01(\x0b2\x1c.SC2APIProtocol.Res\
    ponsePingH\0R\x04ping\x125\n\x05debug\x18\x14\x20\x01(\x0b2\x1d.SC2APIPr\
    otocol.ResponseDebugH\0R\x05debug\x12\x0e\n\x02id\x18a\x20\x01(\rR\x02id\
    \x12\x14\n\x05error\x18b\x20\x03(\tR\x05error\x12.\n\x06status\x18c\x20\
    \x01(\x0e2\x16.SC2APIProtocol.StatusR\x06statusB\n\n\x08response\"\xa1\
    \x02\n\x11RequestCreateGame\x127\n\tlocal_map\x18\x01\x20\x01(\x0b2\x18.\
    SC2APIProtocol.LocalMapH\0R\x08localMap\x12.\n\x12battlenet_map_name\x18\
    \x02\x20\x01(\tH\0R\x10battlenetMapName\x12>\n\x0cplayer_setup\x18\x03\
    \x20\x03(\x0b2\x1b.SC2APIProtocol.PlayerSetupR\x0bplayerSetup\x12\x1f\n\
    \x0bdisable_fog\x18\x04\x20\x01(\x08R\ndisableFog\x12\x1f\n\x0brandom_se\
    ed\x18\x05\x20\x01(\rR\nrandomSeed\x12\x1a\n\x08realtime\x18\x06\x20\x01\
    (\x08R\x08realtimeB\x05\n\x03Map\"@\n\x08LocalMap\x12\x19\n\x08map_path\
    \x18\x01\x20\x01(\tR\x07mapPath\x12\x19\n\x08map_data\x18\x07\x20\x01(\
    \x0cR\x07mapData\"\xb1\x02\n\x12ResponseCreateGame\x12>\n\x05error\x18\
    \x01\x20\x01(\x0e2(.SC2APIProtocol.ResponseCreateGame.ErrorR\x05error\
    \x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cerrorDetails\"\xb5\x01\n\
    \x05Error\x12\x0e\n\nMissingMap\x10\x01\x12\x12\n\x0eInvalidMapPath\x10\
    \x02\x12\x12\n\x0eInvalidMapData\x10\x03\x12\x12\n\x0eInvalidMapName\x10\
    \x04\x12\x14\n\x10InvalidMapHandle\x10\x05\x12\x16\n\x12MissingPlayerSet\
    up\x10\x06\x12\x16\n\x12InvalidPlayerSetup\x10\x07\x12\x1a\n\x16Multipla\
    yerUnsupported\x10\x08\"\x8d\x03\n\x0fRequestJoinGame\x12*\n\x04race\x18\
    \x01\x20\x01(\x0e2\x14.SC2APIProtocol.RaceH\0R\x04race\x12.\n\x12observe\
    d_player_id\x18\x02\x20\x01(\rH\0R\x10observedPlayerId\x12:\n\x07options\
    \x18\x03\x20\x01(\x0b2\x20.SC2APIProtocol.InterfaceOptionsR\x07options\
    \x12:\n\x0cserver_ports\x18\x04\x20\x01(\x0b2\x17.SC2APIProtocol.PortSet\
    R\x0bserverPorts\x12:\n\x0cclient_ports\x18\x05\x20\x03(\x0b2\x17.SC2API\
    Protocol.PortSetR\x0bclientPorts\x12\x1f\n\x0bshared_port\x18\x06\x20\
    \x01(\x05R\nsharedPort\x12\x1f\n\x0bplayer_name\x18\x07\x20\x01(\tR\npla\
    yerName\x12\x17\n\x07host_ip\x18\x08\x20\x01(\tR\x06hostIpB\x0f\n\rparti\
    cipation\"C\n\x07PortSet\x12\x1b\n\tgame_port\x18\x01\x20\x01(\x05R\x08g\
    amePort\x12\x1b\n\tbase_port\x18\x02\x20\x01(\x05R\x08basePort\"\xa1\x03\
    \n\x10ResponseJoinGame\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playe\
    rId\x12<\n\x05error\x18\x02\x20\x01(\x0e2&.SC2APIProtocol.ResponseJoinGa\
    me.ErrorR\x05error\x12#\n\rerror_details\x18\x03\x20\x01(\tR\x0cerrorDet\
    ails\"\x8c\x02\n\x05Error\x12\x18\n\x14MissingParticipation\x10\x01\x12\
    \x1b\n\x17InvalidObservedPlayerId\x10\x02\x12\x12\n\x0eMissingOptions\
    \x10\x03\x12\x10\n\x0cMissingPorts\x10\x04\x12\x0c\n\x08GameFull\x10\x05\
    \x12\x0f\n\x0bLaunchError\x10\x06\x12\x16\n\x12FeatureUnsupported\x10\
    \x07\x12\x12\n\x0eNoSpaceForUser\x10\x08\x12\x13\n\x0fMapDoesNotExist\
    \x10\t\x12\x11\n\rCannotOpenMap\x10\n\x12\x11\n\rChecksumError\x10\x0b\
    \x12\x10\n\x0cNetworkError\x10\x0c\x12\x0e\n\nOtherError\x10\r\"\x14\n\
    \x12RequestRestartGame\"\xbd\x01\n\x13ResponseRestartGame\x12?\n\x05erro\
    r\x18\x01\x20\x01(\x0e2).SC2APIProtocol.ResponseRestartGame.ErrorR\x05er\
    ror\x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cerrorDetails\x12&\n\x0f\
    need_hard_reset\x18\x03\x20\x01(\x08R\rneedHardReset\"\x18\n\x05Error\
    \x12\x0f\n\x0bLaunchError\x10\x01\"\xcb\x02\n\x12RequestStartReplay\x12!\
    \n\x0breplay_path\x18\x01\x20\x01(\tH\0R\nreplayPath\x12!\n\x0breplay_da\
    ta\x18\x05\x20\x01(\x0cH\0R\nreplayData\x12\x19\n\x08map_data\x18\x06\
    \x20\x01(\x0cR\x07mapData\x12,\n\x12observed_player_id\x18\x02\x20\x01(\
    \x05R\x10observedPlayerId\x12:\n\x07options\x18\x03\x20\x01(\x0b2\x20.SC\
    2APIProtocol.InterfaceOptionsR\x07options\x12\x1f\n\x0bdisable_fog\x18\
    \x04\x20\x01(\x08R\ndisableFog\x12\x1a\n\x08realtime\x18\x07\x20\x01(\
    \x08R\x08realtime\x12#\n\rrecord_replay\x18\x08\x20\x01(\x08R\x0crecordR\
    eplayB\x08\n\x06replay\"\x9c\x02\n\x13ResponseStartReplay\x12?\n\x05erro\
    r\x18\x01\x20\x01(\x0e2).SC2APIProtocol.ResponseStartReplay.ErrorR\x05er\
    ror\x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cerrorDetails\"\x9e\x01\
    \n\x05Error\x12\x11\n\rMissingReplay\x10\x01\x12\x15\n\x11InvalidReplayP\
    ath\x10\x02\x12\x15\n\x11InvalidReplayData\x10\x03\x12\x12\n\x0eInvalidM\
    apData\x10\x04\x12\x1b\n\x17InvalidObservedPlayerId\x10\x05\x12\x12\n\
    \x0eMissingOptions\x10\x06\x12\x0f\n\x0bLaunchError\x10\x07\"4\n\x11Requ\
    estMapCommand\x12\x1f\n\x0btrigger_cmd\x18\x01\x20\x01(\tR\ntriggerCmd\"\
    \x96\x01\n\x12ResponseMapCommand\x12>\n\x05error\x18\x01\x20\x01(\x0e2(.\
    SC2APIProtocol.ResponseMapCommand.ErrorR\x05error\x12#\n\rerror_details\
    \x18\x02\x20\x01(\tR\x0cerrorDetails\"\x1b\n\x05Error\x12\x12\n\x0eNoTri\
    ggerError\x10\x01\"\x12\n\x10RequestLeaveGame\"\x13\n\x11ResponseLeaveGa\
    me\"\x12\n\x10RequestQuickSave\"\x13\n\x11ResponseQuickSave\"\x12\n\x10R\
    equestQuickLoad\"\x13\n\x11ResponseQuickLoad\"\r\n\x0bRequestQuit\"\x0e\
    \n\x0cResponseQuit\"\x11\n\x0fRequestGameInfo\"\xa0\x02\n\x10ResponseGam\
    eInfo\x12\x19\n\x08map_name\x18\x01\x20\x01(\tR\x07mapName\x12\x1b\n\tmo\
    d_names\x18\x06\x20\x03(\tR\x08modNames\x12$\n\x0elocal_map_path\x18\x02\
    \x20\x01(\tR\x0clocalMapPath\x12;\n\x0bplayer_info\x18\x03\x20\x03(\x0b2\
    \x1a.SC2APIProtocol.PlayerInfoR\nplayerInfo\x125\n\tstart_raw\x18\x04\
    \x20\x01(\x0b2\x18.SC2APIProtocol.StartRawR\x08startRaw\x12:\n\x07option\
    s\x18\x05\x20\x01(\x0b2\x20.SC2APIProtocol.InterfaceOptionsR\x07options\
    \"R\n\x12RequestObservation\x12\x1f\n\x0bdisable_fog\x18\x01\x20\x01(\
    \x08R\ndisableFog\x12\x1b\n\tgame_loop\x18\x02\x20\x01(\rR\x08gameLoop\"\
    \xbd\x02\n\x13ResponseObservation\x120\n\x07actions\x18\x01\x20\x03(\x0b\
    2\x16.SC2APIProtocol.ActionR\x07actions\x12@\n\raction_errors\x18\x02\
    \x20\x03(\x0b2\x1b.SC2APIProtocol.ActionErrorR\x0cactionErrors\x12=\n\
    \x0bobservation\x18\x03\x20\x01(\x0b2\x1b.SC2APIProtocol.ObservationR\
    \x0bobservation\x12A\n\rplayer_result\x18\x04\x20\x03(\x0b2\x1c.SC2APIPr\
    otocol.PlayerResultR\x0cplayerResult\x120\n\x04chat\x18\x05\x20\x03(\x0b\
    2\x1c.SC2APIProtocol.ChatReceivedR\x04chat\"E\n\x0cChatReceived\x12\x1b\
    \n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"A\n\rRequestAction\x120\n\x07actions\x18\
    \x01\x20\x03(\x0b2\x16.SC2APIProtocol.ActionR\x07actions\"F\n\x0eRespons\
    eAction\x124\n\x06result\x18\x01\x20\x03(\x0e2\x1c.SC2APIProtocol.Action\
    ResultR\x06result\"Q\n\x15RequestObserverAction\x128\n\x07actions\x18\
    \x01\x20\x03(\x0b2\x1e.SC2APIProtocol.ObserverActionR\x07actions\"\x18\n\
    \x16ResponseObserverAction\"#\n\x0bRequestStep\x12\x14\n\x05count\x18\
    \x01\x20\x01(\rR\x05count\"7\n\x0cResponseStep\x12'\n\x0fsimulation_loop\
    \x18\x01\x20\x01(\rR\x0esimulationLoop\"\xa3\x01\n\x0bRequestData\x12\
    \x1d\n\nability_id\x18\x01\x20\x01(\x08R\tabilityId\x12\x20\n\x0cunit_ty\
    pe_id\x18\x02\x20\x01(\x08R\nunitTypeId\x12\x1d\n\nupgrade_id\x18\x03\
    \x20\x01(\x08R\tupgradeId\x12\x17\n\x07buff_id\x18\x04\x20\x01(\x08R\x06\
    buffId\x12\x1b\n\teffect_id\x18\x05\x20\x01(\x08R\x08effectId\"\x9c\x02\
    \n\x0cResponseData\x129\n\tabilities\x18\x01\x20\x03(\x0b2\x1b.SC2APIPro\
    tocol.AbilityDataR\tabilities\x122\n\x05units\x18\x02\x20\x03(\x0b2\x1c.\
    SC2APIProtocol.UnitTypeDataR\x05units\x127\n\x08upgrades\x18\x03\x20\x03\
    (\x0b2\x1b.SC2APIProtocol.UpgradeDataR\x08upgrades\x12.\n\x05buffs\x18\
    \x04\x20\x03(\x0b2\x18.SC2APIProtocol.BuffDataR\x05buffs\x124\n\x07effec\
    ts\x18\x05\x20\x03(\x0b2\x1a.SC2APIProtocol.EffectDataR\x07effects\"\x13\
    \n\x11RequestSaveReplay\"(\n\x12ResponseSaveReplay\x12\x12\n\x04data\x18\
    \x01\x20\x01(\x0cR\x04data\"\x88\x01\n\x11RequestReplayInfo\x12!\n\x0bre\
    play_path\x18\x01\x20\x01(\tH\0R\nreplayPath\x12!\n\x0breplay_data\x18\
    \x02\x20\x01(\x0cH\0R\nreplayData\x12#\n\rdownload_data\x18\x03\x20\x01(\
    \x08R\x0cdownloadDataB\x08\n\x06replay\"\xcf\x01\n\x0fPlayerInfoExtra\
    \x12;\n\x0bplayer_info\x18\x01\x20\x01(\x0b2\x1a.SC2APIProtocol.PlayerIn\
    foR\nplayerInfo\x12A\n\rplayer_result\x18\x02\x20\x01(\x0b2\x1c.SC2APIPr\
    otocol.PlayerResultR\x0cplayerResult\x12\x1d\n\nplayer_mmr\x18\x03\x20\
    \x01(\x05R\tplayerMmr\x12\x1d\n\nplayer_apm\x18\x04\x20\x01(\x05R\tplaye\
    rApm\"\xd3\x04\n\x12ResponseReplayInfo\x12\x19\n\x08map_name\x18\x01\x20\
    \x01(\tR\x07mapName\x12$\n\x0elocal_map_path\x18\x02\x20\x01(\tR\x0cloca\
    lMapPath\x12@\n\x0bplayer_info\x18\x03\x20\x03(\x0b2\x1f.SC2APIProtocol.\
    PlayerInfoExtraR\nplayerInfo\x12.\n\x13game_duration_loops\x18\x04\x20\
    \x01(\rR\x11gameDurationLoops\x122\n\x15game_duration_seconds\x18\x05\
    \x20\x01(\x02R\x13gameDurationSeconds\x12!\n\x0cgame_version\x18\x06\x20\
    \x01(\tR\x0bgameVersion\x12!\n\x0cdata_version\x18\x0b\x20\x01(\tR\x0bda\
    taVersion\x12\x1d\n\ndata_build\x18\x07\x20\x01(\rR\tdataBuild\x12\x1d\n\
    \nbase_build\x18\x08\x20\x01(\rR\tbaseBuild\x12>\n\x05error\x18\t\x20\
    \x01(\x0e2(.SC2APIProtocol.ResponseReplayInfo.ErrorR\x05error\x12#\n\rer\
    ror_details\x18\n\x20\x01(\tR\x0cerrorDetails\"m\n\x05Error\x12\x11\n\rM\
    issingReplay\x10\x01\x12\x15\n\x11InvalidReplayPath\x10\x02\x12\x15\n\
    \x11InvalidReplayData\x10\x03\x12\x10\n\x0cParsingError\x10\x04\x12\x11\
    \n\rDownloadError\x10\x05\"\x16\n\x14RequestAvailableMaps\"o\n\x15Respon\
    seAvailableMaps\x12&\n\x0flocal_map_paths\x18\x01\x20\x03(\tR\rlocalMapP\
    aths\x12.\n\x13battlenet_map_names\x18\x02\x20\x03(\tR\x11battlenetMapNa\
    mes\"F\n\x0eRequestSaveMap\x12\x19\n\x08map_path\x18\x01\x20\x01(\tR\x07\
    mapPath\x12\x19\n\x08map_data\x18\x02\x20\x01(\x0cR\x07mapData\"k\n\x0fR\
    esponseSaveMap\x12;\n\x05error\x18\x01\x20\x01(\x0e2%.SC2APIProtocol.Res\
    ponseSaveMap.ErrorR\x05error\"\x1b\n\x05Error\x12\x12\n\x0eInvalidMapDat\
    a\x10\x01\"\r\n\x0bRequestPing\"\x92\x01\n\x0cResponsePing\x12!\n\x0cgam\
    e_version\x18\x01\x20\x01(\tR\x0bgameVersion\x12!\n\x0cdata_version\x18\
    \x02\x20\x01(\tR\x0bdataVersion\x12\x1d\n\ndata_build\x18\x03\x20\x01(\r\
    R\tdataBuild\x12\x1d\n\nbase_build\x18\x04\x20\x01(\rR\tbaseBuild\"B\n\
    \x0cRequestDebug\x122\n\x05debug\x18\x01\x20\x03(\x0b2\x1c.SC2APIProtoco\
    l.DebugCommandR\x05debug\"\x0f\n\rResponseDebug\"\xf8\x01\n\x0bPlayerSet\
    up\x12.\n\x04type\x18\x01\x20\x01(\x0e2\x1a.SC2APIProtocol.PlayerTypeR\
    \x04type\x12(\n\x04race\x18\x02\x20\x01(\x0e2\x14.SC2APIProtocol.RaceR\
    \x04race\x12:\n\ndifficulty\x18\x03\x20\x01(\x0e2\x1a.SC2APIProtocol.Dif\
    ficultyR\ndifficulty\x12\x1f\n\x0bplayer_name\x18\x04\x20\x01(\tR\nplaye\
    rName\x122\n\x08ai_build\x18\x05\x20\x01(\x0e2\x17.SC2APIProtocol.AIBuil\
    dR\x07aiBuild\"\x92\x02\n\x12SpatialCameraSetup\x127\n\nresolution\x18\
    \x02\x20\x01(\x0b2\x17.SC2APIProtocol.Size2DIR\nresolution\x12F\n\x12min\
    imap_resolution\x18\x03\x20\x01(\x0b2\x17.SC2APIProtocol.Size2DIR\x11min\
    imapResolution\x12\x14\n\x05width\x18\x01\x20\x01(\x02R\x05width\x121\n\
    \x15crop_to_playable_area\x18\x04\x20\x01(\x08R\x12cropToPlayableArea\
    \x122\n\x15allow_cheating_layers\x18\x05\x20\x01(\x08R\x13allowCheatingL\
    ayers\"\xb1\x03\n\x10InterfaceOptions\x12\x10\n\x03raw\x18\x01\x20\x01(\
    \x08R\x03raw\x12\x14\n\x05score\x18\x02\x20\x01(\x08R\x05score\x12G\n\rf\
    eature_layer\x18\x03\x20\x01(\x0b2\".SC2APIProtocol.SpatialCameraSetupR\
    \x0cfeatureLayer\x12:\n\x06render\x18\x04\x20\x01(\x0b2\".SC2APIProtocol\
    .SpatialCameraSetupR\x06render\x12!\n\x0cshow_cloaked\x18\x05\x20\x01(\
    \x08R\x0bshowCloaked\x122\n\x15show_burrowed_shadows\x18\t\x20\x01(\x08R\
    \x13showBurrowedShadows\x12+\n\x11show_placeholders\x18\x08\x20\x01(\x08\
    R\x10showPlaceholders\x122\n\x15raw_affects_selection\x18\x06\x20\x01(\
    \x08R\x13rawAffectsSelection\x128\n\x19raw_crop_to_playable_area\x18\x07\
    \x20\x01(\x08R\x15rawCropToPlayableArea\"\xde\x02\n\nPlayerInfo\x12\x1b\
    \n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\x12.\n\x04type\x18\x02\x20\
    \x01(\x0e2\x1a.SC2APIProtocol.PlayerTypeR\x04type\x12;\n\x0erace_request\
    ed\x18\x03\x20\x01(\x0e2\x14.SC2APIProtocol.RaceR\rraceRequested\x125\n\
    \x0brace_actual\x18\x04\x20\x01(\x0e2\x14.SC2APIProtocol.RaceR\nraceActu\
    al\x12:\n\ndifficulty\x18\x05\x20\x01(\x0e2\x1a.SC2APIProtocol.Difficult\
    yR\ndifficulty\x122\n\x08ai_build\x18\x07\x20\x01(\x0e2\x17.SC2APIProtoc\
    ol.AIBuildR\x07aiBuild\x12\x1f\n\x0bplayer_name\x18\x06\x20\x01(\tR\npla\
    yerName\"\xed\x02\n\x0cPlayerCommon\x12\x1b\n\tplayer_id\x18\x01\x20\x01\
    (\rR\x08playerId\x12\x1a\n\x08minerals\x18\x02\x20\x01(\rR\x08minerals\
    \x12\x18\n\x07vespene\x18\x03\x20\x01(\rR\x07vespene\x12\x19\n\x08food_c\
    ap\x18\x04\x20\x01(\rR\x07foodCap\x12\x1b\n\tfood_used\x18\x05\x20\x01(\
    \rR\x08foodUsed\x12\x1b\n\tfood_army\x18\x06\x20\x01(\rR\x08foodArmy\x12\
    !\n\x0cfood_workers\x18\x07\x20\x01(\rR\x0bfoodWorkers\x12*\n\x11idle_wo\
    rker_count\x18\x08\x20\x01(\rR\x0fidleWorkerCount\x12\x1d\n\narmy_count\
    \x18\t\x20\x01(\rR\tarmyCount\x12&\n\x0fwarp_gate_count\x18\n\x20\x01(\r\
    R\rwarpGateCount\x12\x1f\n\x0blarva_count\x18\x0b\x20\x01(\rR\nlarvaCoun\
    t\"\x97\x04\n\x0bObservation\x12\x1b\n\tgame_loop\x18\t\x20\x01(\rR\x08g\
    ameLoop\x12A\n\rplayer_common\x18\x01\x20\x01(\x0b2\x1c.SC2APIProtocol.P\
    layerCommonR\x0cplayerCommon\x12-\n\x06alerts\x18\n\x20\x03(\x0e2\x15.SC\
    2APIProtocol.AlertR\x06alerts\x12>\n\tabilities\x18\x03\x20\x03(\x0b2\
    \x20.SC2APIProtocol.AvailableAbilityR\tabilities\x12+\n\x05score\x18\x04\
    \x20\x01(\x0b2\x15.SC2APIProtocol.ScoreR\x05score\x129\n\x08raw_data\x18\
    \x05\x20\x01(\x0b2\x1e.SC2APIProtocol.ObservationRawR\x07rawData\x12U\n\
    \x12feature_layer_data\x18\x06\x20\x01(\x0b2'.SC2APIProtocol.Observation\
    FeatureLayerR\x10featureLayerData\x12B\n\x0brender_data\x18\x07\x20\x01(\
    \x0b2!.SC2APIProtocol.ObservationRenderR\nrenderData\x126\n\x07ui_data\
    \x18\x08\x20\x01(\x0b2\x1d.SC2APIProtocol.ObservationUIR\x06uiData\"\xe8\
    \x02\n\x06Action\x128\n\naction_raw\x18\x01\x20\x01(\x0b2\x19.SC2APIProt\
    ocol.ActionRawR\tactionRaw\x12O\n\x14action_feature_layer\x18\x02\x20\
    \x01(\x0b2\x1d.SC2APIProtocol.ActionSpatialR\x12actionFeatureLayer\x12B\
    \n\raction_render\x18\x03\x20\x01(\x0b2\x1d.SC2APIProtocol.ActionSpatial\
    R\x0cactionRender\x125\n\taction_ui\x18\x04\x20\x01(\x0b2\x18.SC2APIProt\
    ocol.ActionUIR\x08actionUi\x12;\n\x0baction_chat\x18\x06\x20\x01(\x0b2\
    \x1a.SC2APIProtocol.ActionChatR\nactionChat\x12\x1b\n\tgame_loop\x18\x07\
    \x20\x01(\rR\x08gameLoop\"\x88\x01\n\nActionChat\x12<\n\x07channel\x18\
    \x01\x20\x01(\x0e2\".SC2APIProtocol.ActionChat.ChannelR\x07channel\x12\
    \x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\"\n\x07Channel\x12\r\
    \n\tBroadcast\x10\x01\x12\x08\n\x04Team\x10\x02\"}\n\x0bActionError\x12\
    \x19\n\x08unit_tag\x18\x01\x20\x01(\x04R\x07unitTag\x12\x1d\n\nability_i\
    d\x18\x02\x20\x01(\x04R\tabilityId\x124\n\x06result\x18\x03\x20\x01(\x0e\
    2\x1c.SC2APIProtocol.ActionResultR\x06result\"\x92\x03\n\x0eObserverActi\
    on\x12`\n\x12player_perspective\x18\x01\x20\x01(\x0b2/.SC2APIProtocol.Ac\
    tionObserverPlayerPerspectiveH\0R\x11playerPerspective\x12K\n\x0bcamera_\
    move\x18\x02\x20\x01(\x0b2(.SC2APIProtocol.ActionObserverCameraMoveH\0R\
    \ncameraMove\x12d\n\x14camera_follow_player\x18\x03\x20\x01(\x0b20.SC2AP\
    IProtocol.ActionObserverCameraFollowPlayerH\0R\x12cameraFollowPlayer\x12\
    a\n\x13camera_follow_units\x18\x04\x20\x01(\x0b2/.SC2APIProtocol.ActionO\
    bserverCameraFollowUnitsH\0R\x11cameraFollowUnitsB\x08\n\x06action\">\n\
    \x1fActionObserverPlayerPerspective\x12\x1b\n\tplayer_id\x18\x01\x20\x01\
    (\rR\x08playerId\"l\n\x18ActionObserverCameraMove\x124\n\tworld_pos\x18\
    \x01\x20\x01(\x0b2\x17.SC2APIProtocol.Point2DR\x08worldPos\x12\x1a\n\x08\
    distance\x18\x02\x20\x01(\x02R\x08distance\"?\n\x20ActionObserverCameraF\
    ollowPlayer\x12\x1b\n\tplayer_id\x18\x01\x20\x01(\rR\x08playerId\">\n\
    \x1fActionObserverCameraFollowUnits\x12\x1b\n\tunit_tags\x18\x01\x20\x03\
    (\x04R\x08unitTags\"[\n\x0cPlayerResult\x12\x1b\n\tplayer_id\x18\x01\x20\
    \x01(\rR\x08playerId\x12.\n\x06result\x18\x02\x20\x01(\x0e2\x16.SC2APIPr\
    otocol.ResultR\x06result*c\n\x06Status\x12\x0c\n\x08launched\x10\x01\x12\
    \r\n\tinit_game\x10\x02\x12\x0b\n\x07in_game\x10\x03\x12\r\n\tin_replay\
    \x10\x04\x12\t\n\x05ended\x10\x05\x12\x08\n\x04quit\x10\x06\x12\x0b\n\
    \x07unknown\x10c*\x96\x01\n\nDifficulty\x12\x0c\n\x08VeryEasy\x10\x01\
    \x12\x08\n\x04Easy\x10\x02\x12\n\n\x06Medium\x10\x03\x12\x0e\n\nMediumHa\
    rd\x10\x04\x12\x08\n\x04Hard\x10\x05\x12\n\n\x06Harder\x10\x06\x12\x0c\n\
    \x08VeryHard\x10\x07\x12\x0f\n\x0bCheatVision\x10\x08\x12\x0e\n\nCheatMo\
    ney\x10\t\x12\x0f\n\x0bCheatInsane\x10\n*9\n\nPlayerType\x12\x0f\n\x0bPa\
    rticipant\x10\x01\x12\x0c\n\x08Computer\x10\x02\x12\x0c\n\x08Observer\
    \x10\x03*O\n\x07AIBuild\x12\x0f\n\x0bRandomBuild\x10\x01\x12\x08\n\x04Ru\
    sh\x10\x02\x12\n\n\x06Timing\x10\x03\x12\t\n\x05Power\x10\x04\x12\t\n\
    \x05Macro\x10\x05\x12\x07\n\x03Air\x10\x06*\xdb\x03\n\x05Alert\x12\x0e\n\
    \nAlertError\x10\x03\x12\x11\n\rAddOnComplete\x10\x04\x12\x14\n\x10Build\
    ingComplete\x10\x05\x12\x17\n\x13BuildingUnderAttack\x10\x06\x12\x10\n\
    \x0cLarvaHatched\x10\x07\x12\x11\n\rMergeComplete\x10\x08\x12\x15\n\x11M\
    ineralsExhausted\x10\t\x12\x11\n\rMorphComplete\x10\n\x12\x16\n\x12Mothe\
    rshipComplete\x10\x0b\x12\x0f\n\x0bMULEExpired\x10\x0c\x12\x19\n\x15Nucl\
    earLaunchDetected\x10\x01\x12\x10\n\x0cNukeComplete\x10\r\x12\x15\n\x11N\
    ydusWormDetected\x10\x02\x12\x14\n\x10ResearchComplete\x10\x0e\x12\x0e\n\
    \nTrainError\x10\x0f\x12\x15\n\x11TrainUnitComplete\x10\x10\x12\x17\n\
    \x13TrainWorkerComplete\x10\x11\x12\x1a\n\x16TransformationComplete\x10\
    \x12\x12\x13\n\x0fUnitUnderAttack\x10\x13\x12\x13\n\x0fUpgradeComplete\
    \x10\x14\x12\x14\n\x10VespeneExhausted\x10\x15\x12\x12\n\x0eWarpInComple\
    te\x10\x16*9\n\x06Result\x12\x0b\n\x07Victory\x10\x01\x12\n\n\x06Defeat\
    \x10\x02\x12\x07\n\x03Tie\x10\x03\x12\r\n\tUndecided\x10\x04\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(9);
            deps.push(super::common::file_descriptor().clone());
            deps.push(super::data::file_descriptor().clone());
            deps.push(super::debug::file_descriptor().clone());
            deps.push(super::error::file_descriptor().clone());
            deps.push(super::query::file_descriptor().clone());
            deps.push(super::raw::file_descriptor().clone());
            deps.push(super::score::file_descriptor().clone());
            deps.push(super::spatial::file_descriptor().clone());
            deps.push(super::ui::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(63);
            messages.push(Request::generated_message_descriptor_data());
            messages.push(Response::generated_message_descriptor_data());
            messages.push(RequestCreateGame::generated_message_descriptor_data());
            messages.push(LocalMap::generated_message_descriptor_data());
            messages.push(ResponseCreateGame::generated_message_descriptor_data());
            messages.push(RequestJoinGame::generated_message_descriptor_data());
            messages.push(PortSet::generated_message_descriptor_data());
            messages.push(ResponseJoinGame::generated_message_descriptor_data());
            messages.push(RequestRestartGame::generated_message_descriptor_data());
            messages.push(ResponseRestartGame::generated_message_descriptor_data());
            messages.push(RequestStartReplay::generated_message_descriptor_data());
            messages.push(ResponseStartReplay::generated_message_descriptor_data());
            messages.push(RequestMapCommand::generated_message_descriptor_data());
            messages.push(ResponseMapCommand::generated_message_descriptor_data());
            messages.push(RequestLeaveGame::generated_message_descriptor_data());
            messages.push(ResponseLeaveGame::generated_message_descriptor_data());
            messages.push(RequestQuickSave::generated_message_descriptor_data());
            messages.push(ResponseQuickSave::generated_message_descriptor_data());
            messages.push(RequestQuickLoad::generated_message_descriptor_data());
            messages.push(ResponseQuickLoad::generated_message_descriptor_data());
            messages.push(RequestQuit::generated_message_descriptor_data());
            messages.push(ResponseQuit::generated_message_descriptor_data());
            messages.push(RequestGameInfo::generated_message_descriptor_data());
            messages.push(ResponseGameInfo::generated_message_descriptor_data());
            messages.push(RequestObservation::generated_message_descriptor_data());
            messages.push(ResponseObservation::generated_message_descriptor_data());
            messages.push(ChatReceived::generated_message_descriptor_data());
            messages.push(RequestAction::generated_message_descriptor_data());
            messages.push(ResponseAction::generated_message_descriptor_data());
            messages.push(RequestObserverAction::generated_message_descriptor_data());
            messages.push(ResponseObserverAction::generated_message_descriptor_data());
            messages.push(RequestStep::generated_message_descriptor_data());
            messages.push(ResponseStep::generated_message_descriptor_data());
            messages.push(RequestData::generated_message_descriptor_data());
            messages.push(ResponseData::generated_message_descriptor_data());
            messages.push(RequestSaveReplay::generated_message_descriptor_data());
            messages.push(ResponseSaveReplay::generated_message_descriptor_data());
            messages.push(RequestReplayInfo::generated_message_descriptor_data());
            messages.push(PlayerInfoExtra::generated_message_descriptor_data());
            messages.push(ResponseReplayInfo::generated_message_descriptor_data());
            messages.push(RequestAvailableMaps::generated_message_descriptor_data());
            messages.push(ResponseAvailableMaps::generated_message_descriptor_data());
            messages.push(RequestSaveMap::generated_message_descriptor_data());
            messages.push(ResponseSaveMap::generated_message_descriptor_data());
            messages.push(RequestPing::generated_message_descriptor_data());
            messages.push(ResponsePing::generated_message_descriptor_data());
            messages.push(RequestDebug::generated_message_descriptor_data());
            messages.push(ResponseDebug::generated_message_descriptor_data());
            messages.push(PlayerSetup::generated_message_descriptor_data());
            messages.push(SpatialCameraSetup::generated_message_descriptor_data());
            messages.push(InterfaceOptions::generated_message_descriptor_data());
            messages.push(PlayerInfo::generated_message_descriptor_data());
            messages.push(PlayerCommon::generated_message_descriptor_data());
            messages.push(Observation::generated_message_descriptor_data());
            messages.push(Action::generated_message_descriptor_data());
            messages.push(ActionChat::generated_message_descriptor_data());
            messages.push(ActionError::generated_message_descriptor_data());
            messages.push(ObserverAction::generated_message_descriptor_data());
            messages.push(ActionObserverPlayerPerspective::generated_message_descriptor_data());
            messages.push(ActionObserverCameraMove::generated_message_descriptor_data());
            messages.push(ActionObserverCameraFollowPlayer::generated_message_descriptor_data());
            messages.push(ActionObserverCameraFollowUnits::generated_message_descriptor_data());
            messages.push(PlayerResult::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(14);
            enums.push(Status::generated_enum_descriptor_data());
            enums.push(Difficulty::generated_enum_descriptor_data());
            enums.push(PlayerType::generated_enum_descriptor_data());
            enums.push(AIBuild::generated_enum_descriptor_data());
            enums.push(Alert::generated_enum_descriptor_data());
            enums.push(Result::generated_enum_descriptor_data());
            enums.push(response_create_game::Error::generated_enum_descriptor_data());
            enums.push(response_join_game::Error::generated_enum_descriptor_data());
            enums.push(response_restart_game::Error::generated_enum_descriptor_data());
            enums.push(response_start_replay::Error::generated_enum_descriptor_data());
            enums.push(response_map_command::Error::generated_enum_descriptor_data());
            enums.push(response_replay_info::Error::generated_enum_descriptor_data());
            enums.push(response_save_map::Error::generated_enum_descriptor_data());
            enums.push(action_chat::Channel::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

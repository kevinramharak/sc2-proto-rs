// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `s2clientprotocol/ui.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ObservationUI)
pub struct ObservationUI {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ObservationUI.groups)
    pub groups: ::std::vec::Vec<ControlGroup>,
    // message oneof groups
    pub panel: ::std::option::Option<observation_ui::Panel>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ObservationUI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObservationUI {
    fn default() -> &'a ObservationUI {
        <ObservationUI as ::protobuf::Message>::default_instance()
    }
}

impl ObservationUI {
    pub fn new() -> ObservationUI {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.SinglePanel single = 2;

    pub fn single(&self) -> &SinglePanel {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Single(ref v)) => v,
            _ => <SinglePanel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_single(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_single(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Single(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_single(&mut self, v: SinglePanel) {
        self.panel = ::std::option::Option::Some(observation_ui::Panel::Single(v))
    }

    // Mutable pointer to the field.
    pub fn mut_single(&mut self) -> &mut SinglePanel {
        if let ::std::option::Option::Some(observation_ui::Panel::Single(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(observation_ui::Panel::Single(SinglePanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Single(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_single(&mut self) -> SinglePanel {
        if self.has_single() {
            match self.panel.take() {
                ::std::option::Option::Some(observation_ui::Panel::Single(v)) => v,
                _ => panic!(),
            }
        } else {
            SinglePanel::new()
        }
    }

    // optional .SC2APIProtocol.MultiPanel multi = 3;

    pub fn multi(&self) -> &MultiPanel {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Multi(ref v)) => v,
            _ => <MultiPanel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_multi(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Multi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi(&mut self, v: MultiPanel) {
        self.panel = ::std::option::Option::Some(observation_ui::Panel::Multi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi(&mut self) -> &mut MultiPanel {
        if let ::std::option::Option::Some(observation_ui::Panel::Multi(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(observation_ui::Panel::Multi(MultiPanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Multi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi(&mut self) -> MultiPanel {
        if self.has_multi() {
            match self.panel.take() {
                ::std::option::Option::Some(observation_ui::Panel::Multi(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiPanel::new()
        }
    }

    // optional .SC2APIProtocol.CargoPanel cargo = 4;

    pub fn cargo(&self) -> &CargoPanel {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Cargo(ref v)) => v,
            _ => <CargoPanel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cargo(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_cargo(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Cargo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cargo(&mut self, v: CargoPanel) {
        self.panel = ::std::option::Option::Some(observation_ui::Panel::Cargo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cargo(&mut self) -> &mut CargoPanel {
        if let ::std::option::Option::Some(observation_ui::Panel::Cargo(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(observation_ui::Panel::Cargo(CargoPanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Cargo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cargo(&mut self) -> CargoPanel {
        if self.has_cargo() {
            match self.panel.take() {
                ::std::option::Option::Some(observation_ui::Panel::Cargo(v)) => v,
                _ => panic!(),
            }
        } else {
            CargoPanel::new()
        }
    }

    // optional .SC2APIProtocol.ProductionPanel production = 5;

    pub fn production(&self) -> &ProductionPanel {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Production(ref v)) => v,
            _ => <ProductionPanel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_production(&mut self) {
        self.panel = ::std::option::Option::None;
    }

    pub fn has_production(&self) -> bool {
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Production(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_production(&mut self, v: ProductionPanel) {
        self.panel = ::std::option::Option::Some(observation_ui::Panel::Production(v))
    }

    // Mutable pointer to the field.
    pub fn mut_production(&mut self) -> &mut ProductionPanel {
        if let ::std::option::Option::Some(observation_ui::Panel::Production(_)) = self.panel {
        } else {
            self.panel = ::std::option::Option::Some(observation_ui::Panel::Production(ProductionPanel::new()));
        }
        match self.panel {
            ::std::option::Option::Some(observation_ui::Panel::Production(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_production(&mut self) -> ProductionPanel {
        if self.has_production() {
            match self.panel.take() {
                ::std::option::Option::Some(observation_ui::Panel::Production(v)) => v,
                _ => panic!(),
            }
        } else {
            ProductionPanel::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &ObservationUI| { &m.groups },
            |m: &mut ObservationUI| { &mut m.groups },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SinglePanel>(
            "single",
            ObservationUI::has_single,
            ObservationUI::single,
            ObservationUI::mut_single,
            ObservationUI::set_single,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiPanel>(
            "multi",
            ObservationUI::has_multi,
            ObservationUI::multi,
            ObservationUI::mut_multi,
            ObservationUI::set_multi,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CargoPanel>(
            "cargo",
            ObservationUI::has_cargo,
            ObservationUI::cargo,
            ObservationUI::mut_cargo,
            ObservationUI::set_cargo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ProductionPanel>(
            "production",
            ObservationUI::has_production,
            ObservationUI::production,
            ObservationUI::mut_production,
            ObservationUI::set_production,
        ));
        oneofs.push(observation_ui::Panel::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ObservationUI>(
            "ObservationUI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ObservationUI {
    const NAME: &'static str = "ObservationUI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groups.push(is.read_message()?);
                },
                18 => {
                    self.panel = ::std::option::Option::Some(observation_ui::Panel::Single(is.read_message()?));
                },
                26 => {
                    self.panel = ::std::option::Option::Some(observation_ui::Panel::Multi(is.read_message()?));
                },
                34 => {
                    self.panel = ::std::option::Option::Some(observation_ui::Panel::Cargo(is.read_message()?));
                },
                42 => {
                    self.panel = ::std::option::Option::Some(observation_ui::Panel::Production(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.panel {
            match v {
                &observation_ui::Panel::Single(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &observation_ui::Panel::Multi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &observation_ui::Panel::Cargo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &observation_ui::Panel::Production(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.panel {
            match v {
                &observation_ui::Panel::Single(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &observation_ui::Panel::Multi(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &observation_ui::Panel::Cargo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &observation_ui::Panel::Production(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObservationUI {
        ObservationUI::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.panel = ::std::option::Option::None;
        self.panel = ::std::option::Option::None;
        self.panel = ::std::option::Option::None;
        self.panel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObservationUI {
        static instance: ObservationUI = ObservationUI {
            groups: ::std::vec::Vec::new(),
            panel: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ObservationUI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ObservationUI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ObservationUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationUI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ObservationUI`
pub mod observation_ui {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ObservationUI.panel)
    pub enum Panel {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObservationUI.single)
        Single(super::SinglePanel),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObservationUI.multi)
        Multi(super::MultiPanel),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObservationUI.cargo)
        Cargo(super::CargoPanel),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ObservationUI.production)
        Production(super::ProductionPanel),
    }

    impl ::protobuf::Oneof for Panel {
    }

    impl ::protobuf::OneofFull for Panel {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ObservationUI as ::protobuf::MessageFull>::descriptor().oneof_by_name("panel").unwrap()).clone()
        }
    }

    impl Panel {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Panel>("panel")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ControlGroup)
pub struct ControlGroup {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ControlGroup.control_group_index)
    pub control_group_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ControlGroup.leader_unit_type)
    pub leader_unit_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ControlGroup.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ControlGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ControlGroup {
    fn default() -> &'a ControlGroup {
        <ControlGroup as ::protobuf::Message>::default_instance()
    }
}

impl ControlGroup {
    pub fn new() -> ControlGroup {
        ::std::default::Default::default()
    }

    // optional uint32 control_group_index = 1;

    pub fn control_group_index(&self) -> u32 {
        self.control_group_index.unwrap_or(0)
    }

    pub fn clear_control_group_index(&mut self) {
        self.control_group_index = ::std::option::Option::None;
    }

    pub fn has_control_group_index(&self) -> bool {
        self.control_group_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_group_index(&mut self, v: u32) {
        self.control_group_index = ::std::option::Option::Some(v);
    }

    // optional uint32 leader_unit_type = 2;

    pub fn leader_unit_type(&self) -> u32 {
        self.leader_unit_type.unwrap_or(0)
    }

    pub fn clear_leader_unit_type(&mut self) {
        self.leader_unit_type = ::std::option::Option::None;
    }

    pub fn has_leader_unit_type(&self) -> bool {
        self.leader_unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_unit_type(&mut self, v: u32) {
        self.leader_unit_type = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "control_group_index",
            |m: &ControlGroup| { &m.control_group_index },
            |m: &mut ControlGroup| { &mut m.control_group_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leader_unit_type",
            |m: &ControlGroup| { &m.leader_unit_type },
            |m: &mut ControlGroup| { &mut m.leader_unit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &ControlGroup| { &m.count },
            |m: &mut ControlGroup| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ControlGroup>(
            "ControlGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ControlGroup {
    const NAME: &'static str = "ControlGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.control_group_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.leader_unit_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.control_group_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.leader_unit_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.control_group_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leader_unit_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ControlGroup {
        ControlGroup::new()
    }

    fn clear(&mut self) {
        self.control_group_index = ::std::option::Option::None;
        self.leader_unit_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ControlGroup {
        static instance: ControlGroup = ControlGroup {
            control_group_index: ::std::option::Option::None,
            leader_unit_type: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ControlGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ControlGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ControlGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ControlGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.UnitInfo)
pub struct UnitInfo {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.unit_type)
    pub unit_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.player_relative)
    pub player_relative: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.health)
    pub health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.shields)
    pub shields: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.energy)
    pub energy: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.transport_slots_taken)
    pub transport_slots_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.build_progress)
    pub build_progress: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.add_on)
    pub add_on: ::protobuf::MessageField<UnitInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.max_health)
    pub max_health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.max_shields)
    pub max_shields: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.UnitInfo.max_energy)
    pub max_energy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.UnitInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnitInfo {
    fn default() -> &'a UnitInfo {
        <UnitInfo as ::protobuf::Message>::default_instance()
    }
}

impl UnitInfo {
    pub fn new() -> UnitInfo {
        ::std::default::Default::default()
    }

    // optional uint32 unit_type = 1;

    pub fn unit_type(&self) -> u32 {
        self.unit_type.unwrap_or(0)
    }

    pub fn clear_unit_type(&mut self) {
        self.unit_type = ::std::option::Option::None;
    }

    pub fn has_unit_type(&self) -> bool {
        self.unit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_type(&mut self, v: u32) {
        self.unit_type = ::std::option::Option::Some(v);
    }

    // optional uint32 player_relative = 2;

    pub fn player_relative(&self) -> u32 {
        self.player_relative.unwrap_or(0)
    }

    pub fn clear_player_relative(&mut self) {
        self.player_relative = ::std::option::Option::None;
    }

    pub fn has_player_relative(&self) -> bool {
        self.player_relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_relative(&mut self, v: u32) {
        self.player_relative = ::std::option::Option::Some(v);
    }

    // optional int32 health = 3;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional int32 shields = 4;

    pub fn shields(&self) -> i32 {
        self.shields.unwrap_or(0)
    }

    pub fn clear_shields(&mut self) {
        self.shields = ::std::option::Option::None;
    }

    pub fn has_shields(&self) -> bool {
        self.shields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shields(&mut self, v: i32) {
        self.shields = ::std::option::Option::Some(v);
    }

    // optional int32 energy = 5;

    pub fn energy(&self) -> i32 {
        self.energy.unwrap_or(0)
    }

    pub fn clear_energy(&mut self) {
        self.energy = ::std::option::Option::None;
    }

    pub fn has_energy(&self) -> bool {
        self.energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_energy(&mut self, v: i32) {
        self.energy = ::std::option::Option::Some(v);
    }

    // optional int32 transport_slots_taken = 6;

    pub fn transport_slots_taken(&self) -> i32 {
        self.transport_slots_taken.unwrap_or(0)
    }

    pub fn clear_transport_slots_taken(&mut self) {
        self.transport_slots_taken = ::std::option::Option::None;
    }

    pub fn has_transport_slots_taken(&self) -> bool {
        self.transport_slots_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_slots_taken(&mut self, v: i32) {
        self.transport_slots_taken = ::std::option::Option::Some(v);
    }

    // optional float build_progress = 7;

    pub fn build_progress(&self) -> f32 {
        self.build_progress.unwrap_or(0.)
    }

    pub fn clear_build_progress(&mut self) {
        self.build_progress = ::std::option::Option::None;
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: f32) {
        self.build_progress = ::std::option::Option::Some(v);
    }

    // optional int32 max_health = 9;

    pub fn max_health(&self) -> i32 {
        self.max_health.unwrap_or(0)
    }

    pub fn clear_max_health(&mut self) {
        self.max_health = ::std::option::Option::None;
    }

    pub fn has_max_health(&self) -> bool {
        self.max_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_health(&mut self, v: i32) {
        self.max_health = ::std::option::Option::Some(v);
    }

    // optional int32 max_shields = 10;

    pub fn max_shields(&self) -> i32 {
        self.max_shields.unwrap_or(0)
    }

    pub fn clear_max_shields(&mut self) {
        self.max_shields = ::std::option::Option::None;
    }

    pub fn has_max_shields(&self) -> bool {
        self.max_shields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_shields(&mut self, v: i32) {
        self.max_shields = ::std::option::Option::Some(v);
    }

    // optional int32 max_energy = 11;

    pub fn max_energy(&self) -> i32 {
        self.max_energy.unwrap_or(0)
    }

    pub fn clear_max_energy(&mut self) {
        self.max_energy = ::std::option::Option::None;
    }

    pub fn has_max_energy(&self) -> bool {
        self.max_energy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_energy(&mut self, v: i32) {
        self.max_energy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_type",
            |m: &UnitInfo| { &m.unit_type },
            |m: &mut UnitInfo| { &mut m.unit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_relative",
            |m: &UnitInfo| { &m.player_relative },
            |m: &mut UnitInfo| { &mut m.player_relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health",
            |m: &UnitInfo| { &m.health },
            |m: &mut UnitInfo| { &mut m.health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shields",
            |m: &UnitInfo| { &m.shields },
            |m: &mut UnitInfo| { &mut m.shields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "energy",
            |m: &UnitInfo| { &m.energy },
            |m: &mut UnitInfo| { &mut m.energy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport_slots_taken",
            |m: &UnitInfo| { &m.transport_slots_taken },
            |m: &mut UnitInfo| { &mut m.transport_slots_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_progress",
            |m: &UnitInfo| { &m.build_progress },
            |m: &mut UnitInfo| { &mut m.build_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitInfo>(
            "add_on",
            |m: &UnitInfo| { &m.add_on },
            |m: &mut UnitInfo| { &mut m.add_on },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_health",
            |m: &UnitInfo| { &m.max_health },
            |m: &mut UnitInfo| { &mut m.max_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_shields",
            |m: &UnitInfo| { &m.max_shields },
            |m: &mut UnitInfo| { &mut m.max_shields },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_energy",
            |m: &UnitInfo| { &m.max_energy },
            |m: &mut UnitInfo| { &mut m.max_energy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnitInfo>(
            "UnitInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnitInfo {
    const NAME: &'static str = "UnitInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.player_relative = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.shields = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.energy = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.transport_slots_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.build_progress = ::std::option::Option::Some(is.read_float()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_on)?;
                },
                72 => {
                    self.max_health = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.max_shields = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.max_energy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_relative {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.shields {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.energy {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.transport_slots_taken {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.build_progress {
            my_size += 1 + 4;
        }
        if let Some(v) = self.add_on.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_health {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.max_shields {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.max_energy {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_relative {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.health {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.shields {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.energy {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.transport_slots_taken {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.build_progress {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.add_on.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.max_health {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.max_shields {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.max_energy {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnitInfo {
        UnitInfo::new()
    }

    fn clear(&mut self) {
        self.unit_type = ::std::option::Option::None;
        self.player_relative = ::std::option::Option::None;
        self.health = ::std::option::Option::None;
        self.shields = ::std::option::Option::None;
        self.energy = ::std::option::Option::None;
        self.transport_slots_taken = ::std::option::Option::None;
        self.build_progress = ::std::option::Option::None;
        self.add_on.clear();
        self.max_health = ::std::option::Option::None;
        self.max_shields = ::std::option::Option::None;
        self.max_energy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnitInfo {
        static instance: UnitInfo = UnitInfo {
            unit_type: ::std::option::Option::None,
            player_relative: ::std::option::Option::None,
            health: ::std::option::Option::None,
            shields: ::std::option::Option::None,
            energy: ::std::option::Option::None,
            transport_slots_taken: ::std::option::Option::None,
            build_progress: ::std::option::Option::None,
            add_on: ::protobuf::MessageField::none(),
            max_health: ::std::option::Option::None,
            max_shields: ::std::option::Option::None,
            max_energy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnitInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnitInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnitInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.SinglePanel)
pub struct SinglePanel {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.SinglePanel.unit)
    pub unit: ::protobuf::MessageField<UnitInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SinglePanel.attack_upgrade_level)
    pub attack_upgrade_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SinglePanel.armor_upgrade_level)
    pub armor_upgrade_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SinglePanel.shield_upgrade_level)
    pub shield_upgrade_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.SinglePanel.buffs)
    pub buffs: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.SinglePanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SinglePanel {
    fn default() -> &'a SinglePanel {
        <SinglePanel as ::protobuf::Message>::default_instance()
    }
}

impl SinglePanel {
    pub fn new() -> SinglePanel {
        ::std::default::Default::default()
    }

    // optional int32 attack_upgrade_level = 2;

    pub fn attack_upgrade_level(&self) -> i32 {
        self.attack_upgrade_level.unwrap_or(0)
    }

    pub fn clear_attack_upgrade_level(&mut self) {
        self.attack_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_attack_upgrade_level(&self) -> bool {
        self.attack_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attack_upgrade_level(&mut self, v: i32) {
        self.attack_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 armor_upgrade_level = 3;

    pub fn armor_upgrade_level(&self) -> i32 {
        self.armor_upgrade_level.unwrap_or(0)
    }

    pub fn clear_armor_upgrade_level(&mut self) {
        self.armor_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_armor_upgrade_level(&self) -> bool {
        self.armor_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor_upgrade_level(&mut self, v: i32) {
        self.armor_upgrade_level = ::std::option::Option::Some(v);
    }

    // optional int32 shield_upgrade_level = 4;

    pub fn shield_upgrade_level(&self) -> i32 {
        self.shield_upgrade_level.unwrap_or(0)
    }

    pub fn clear_shield_upgrade_level(&mut self) {
        self.shield_upgrade_level = ::std::option::Option::None;
    }

    pub fn has_shield_upgrade_level(&self) -> bool {
        self.shield_upgrade_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shield_upgrade_level(&mut self, v: i32) {
        self.shield_upgrade_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitInfo>(
            "unit",
            |m: &SinglePanel| { &m.unit },
            |m: &mut SinglePanel| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attack_upgrade_level",
            |m: &SinglePanel| { &m.attack_upgrade_level },
            |m: &mut SinglePanel| { &mut m.attack_upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "armor_upgrade_level",
            |m: &SinglePanel| { &m.armor_upgrade_level },
            |m: &mut SinglePanel| { &mut m.armor_upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shield_upgrade_level",
            |m: &SinglePanel| { &m.shield_upgrade_level },
            |m: &mut SinglePanel| { &mut m.shield_upgrade_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffs",
            |m: &SinglePanel| { &m.buffs },
            |m: &mut SinglePanel| { &mut m.buffs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SinglePanel>(
            "SinglePanel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SinglePanel {
    const NAME: &'static str = "SinglePanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit)?;
                },
                16 => {
                    self.attack_upgrade_level = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.armor_upgrade_level = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.shield_upgrade_level = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.buffs)?;
                },
                40 => {
                    self.buffs.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.attack_upgrade_level {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.armor_upgrade_level {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.shield_upgrade_level {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.buffs {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.attack_upgrade_level {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.armor_upgrade_level {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.shield_upgrade_level {
            os.write_int32(4, v)?;
        }
        for v in &self.buffs {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SinglePanel {
        SinglePanel::new()
    }

    fn clear(&mut self) {
        self.unit.clear();
        self.attack_upgrade_level = ::std::option::Option::None;
        self.armor_upgrade_level = ::std::option::Option::None;
        self.shield_upgrade_level = ::std::option::Option::None;
        self.buffs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SinglePanel {
        static instance: SinglePanel = SinglePanel {
            unit: ::protobuf::MessageField::none(),
            attack_upgrade_level: ::std::option::Option::None,
            armor_upgrade_level: ::std::option::Option::None,
            shield_upgrade_level: ::std::option::Option::None,
            buffs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SinglePanel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SinglePanel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SinglePanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinglePanel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.MultiPanel)
pub struct MultiPanel {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.MultiPanel.units)
    pub units: ::std::vec::Vec<UnitInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.MultiPanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiPanel {
    fn default() -> &'a MultiPanel {
        <MultiPanel as ::protobuf::Message>::default_instance()
    }
}

impl MultiPanel {
    pub fn new() -> MultiPanel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "units",
            |m: &MultiPanel| { &m.units },
            |m: &mut MultiPanel| { &mut m.units },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiPanel>(
            "MultiPanel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiPanel {
    const NAME: &'static str = "MultiPanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.units.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.units {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.units {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiPanel {
        MultiPanel::new()
    }

    fn clear(&mut self) {
        self.units.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiPanel {
        static instance: MultiPanel = MultiPanel {
            units: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiPanel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiPanel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiPanel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.CargoPanel)
pub struct CargoPanel {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.CargoPanel.unit)
    pub unit: ::protobuf::MessageField<UnitInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.CargoPanel.passengers)
    pub passengers: ::std::vec::Vec<UnitInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.CargoPanel.slots_available)
    pub slots_available: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.CargoPanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CargoPanel {
    fn default() -> &'a CargoPanel {
        <CargoPanel as ::protobuf::Message>::default_instance()
    }
}

impl CargoPanel {
    pub fn new() -> CargoPanel {
        ::std::default::Default::default()
    }

    // optional int32 slots_available = 3;

    pub fn slots_available(&self) -> i32 {
        self.slots_available.unwrap_or(0)
    }

    pub fn clear_slots_available(&mut self) {
        self.slots_available = ::std::option::Option::None;
    }

    pub fn has_slots_available(&self) -> bool {
        self.slots_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots_available(&mut self, v: i32) {
        self.slots_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitInfo>(
            "unit",
            |m: &CargoPanel| { &m.unit },
            |m: &mut CargoPanel| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "passengers",
            |m: &CargoPanel| { &m.passengers },
            |m: &mut CargoPanel| { &mut m.passengers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slots_available",
            |m: &CargoPanel| { &m.slots_available },
            |m: &mut CargoPanel| { &mut m.slots_available },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CargoPanel>(
            "CargoPanel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CargoPanel {
    const NAME: &'static str = "CargoPanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit)?;
                },
                18 => {
                    self.passengers.push(is.read_message()?);
                },
                24 => {
                    self.slots_available = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.passengers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.slots_available {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.passengers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.slots_available {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CargoPanel {
        CargoPanel::new()
    }

    fn clear(&mut self) {
        self.unit.clear();
        self.passengers.clear();
        self.slots_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CargoPanel {
        static instance: CargoPanel = CargoPanel {
            unit: ::protobuf::MessageField::none(),
            passengers: ::std::vec::Vec::new(),
            slots_available: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CargoPanel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CargoPanel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CargoPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CargoPanel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.BuildItem)
pub struct BuildItem {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.BuildItem.ability_id)
    pub ability_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:SC2APIProtocol.BuildItem.build_progress)
    pub build_progress: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.BuildItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuildItem {
    fn default() -> &'a BuildItem {
        <BuildItem as ::protobuf::Message>::default_instance()
    }
}

impl BuildItem {
    pub fn new() -> BuildItem {
        ::std::default::Default::default()
    }

    // optional uint32 ability_id = 1;

    pub fn ability_id(&self) -> u32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: u32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional float build_progress = 2;

    pub fn build_progress(&self) -> f32 {
        self.build_progress.unwrap_or(0.)
    }

    pub fn clear_build_progress(&mut self) {
        self.build_progress = ::std::option::Option::None;
    }

    pub fn has_build_progress(&self) -> bool {
        self.build_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_progress(&mut self, v: f32) {
        self.build_progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &BuildItem| { &m.ability_id },
            |m: &mut BuildItem| { &mut m.ability_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_progress",
            |m: &BuildItem| { &m.build_progress },
            |m: &mut BuildItem| { &mut m.build_progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildItem>(
            "BuildItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuildItem {
    const NAME: &'static str = "BuildItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.build_progress = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.build_progress {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.build_progress {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuildItem {
        BuildItem::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.build_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuildItem {
        static instance: BuildItem = BuildItem {
            ability_id: ::std::option::Option::None,
            build_progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuildItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuildItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuildItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuildItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ProductionPanel)
pub struct ProductionPanel {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ProductionPanel.unit)
    pub unit: ::protobuf::MessageField<UnitInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ProductionPanel.build_queue)
    pub build_queue: ::std::vec::Vec<UnitInfo>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ProductionPanel.production_queue)
    pub production_queue: ::std::vec::Vec<BuildItem>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ProductionPanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductionPanel {
    fn default() -> &'a ProductionPanel {
        <ProductionPanel as ::protobuf::Message>::default_instance()
    }
}

impl ProductionPanel {
    pub fn new() -> ProductionPanel {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnitInfo>(
            "unit",
            |m: &ProductionPanel| { &m.unit },
            |m: &mut ProductionPanel| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "build_queue",
            |m: &ProductionPanel| { &m.build_queue },
            |m: &mut ProductionPanel| { &mut m.build_queue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "production_queue",
            |m: &ProductionPanel| { &m.production_queue },
            |m: &mut ProductionPanel| { &mut m.production_queue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductionPanel>(
            "ProductionPanel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductionPanel {
    const NAME: &'static str = "ProductionPanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unit)?;
                },
                18 => {
                    self.build_queue.push(is.read_message()?);
                },
                26 => {
                    self.production_queue.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.build_queue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.production_queue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.build_queue {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.production_queue {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductionPanel {
        ProductionPanel::new()
    }

    fn clear(&mut self) {
        self.unit.clear();
        self.build_queue.clear();
        self.production_queue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductionPanel {
        static instance: ProductionPanel = ProductionPanel {
            unit: ::protobuf::MessageField::none(),
            build_queue: ::std::vec::Vec::new(),
            production_queue: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductionPanel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductionPanel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductionPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductionPanel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionUI)
pub struct ActionUI {
    // message oneof groups
    pub action: ::std::option::Option<action_ui::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionUI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionUI {
    fn default() -> &'a ActionUI {
        <ActionUI as ::protobuf::Message>::default_instance()
    }
}

impl ActionUI {
    pub fn new() -> ActionUI {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionControlGroup control_group = 1;

    pub fn control_group(&self) -> &ActionControlGroup {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ControlGroup(ref v)) => v,
            _ => <ActionControlGroup as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_control_group(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_control_group(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ControlGroup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_control_group(&mut self, v: ActionControlGroup) {
        self.action = ::std::option::Option::Some(action_ui::Action::ControlGroup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_control_group(&mut self) -> &mut ActionControlGroup {
        if let ::std::option::Option::Some(action_ui::Action::ControlGroup(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::ControlGroup(ActionControlGroup::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ControlGroup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_control_group(&mut self) -> ActionControlGroup {
        if self.has_control_group() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::ControlGroup(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionControlGroup::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectArmy select_army = 2;

    pub fn select_army(&self) -> &ActionSelectArmy {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectArmy(ref v)) => v,
            _ => <ActionSelectArmy as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select_army(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_army(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectArmy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_army(&mut self, v: ActionSelectArmy) {
        self.action = ::std::option::Option::Some(action_ui::Action::SelectArmy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_army(&mut self) -> &mut ActionSelectArmy {
        if let ::std::option::Option::Some(action_ui::Action::SelectArmy(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::SelectArmy(ActionSelectArmy::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectArmy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_army(&mut self) -> ActionSelectArmy {
        if self.has_select_army() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::SelectArmy(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectArmy::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectWarpGates select_warp_gates = 3;

    pub fn select_warp_gates(&self) -> &ActionSelectWarpGates {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectWarpGates(ref v)) => v,
            _ => <ActionSelectWarpGates as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select_warp_gates(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_warp_gates(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectWarpGates(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_warp_gates(&mut self, v: ActionSelectWarpGates) {
        self.action = ::std::option::Option::Some(action_ui::Action::SelectWarpGates(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_warp_gates(&mut self) -> &mut ActionSelectWarpGates {
        if let ::std::option::Option::Some(action_ui::Action::SelectWarpGates(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::SelectWarpGates(ActionSelectWarpGates::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectWarpGates(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_warp_gates(&mut self) -> ActionSelectWarpGates {
        if self.has_select_warp_gates() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::SelectWarpGates(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectWarpGates::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectLarva select_larva = 4;

    pub fn select_larva(&self) -> &ActionSelectLarva {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectLarva(ref v)) => v,
            _ => <ActionSelectLarva as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select_larva(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_larva(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectLarva(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_larva(&mut self, v: ActionSelectLarva) {
        self.action = ::std::option::Option::Some(action_ui::Action::SelectLarva(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_larva(&mut self) -> &mut ActionSelectLarva {
        if let ::std::option::Option::Some(action_ui::Action::SelectLarva(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::SelectLarva(ActionSelectLarva::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectLarva(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_larva(&mut self) -> ActionSelectLarva {
        if self.has_select_larva() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::SelectLarva(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectLarva::new()
        }
    }

    // optional .SC2APIProtocol.ActionSelectIdleWorker select_idle_worker = 5;

    pub fn select_idle_worker(&self) -> &ActionSelectIdleWorker {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(ref v)) => v,
            _ => <ActionSelectIdleWorker as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_select_idle_worker(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_select_idle_worker(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select_idle_worker(&mut self, v: ActionSelectIdleWorker) {
        self.action = ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select_idle_worker(&mut self) -> &mut ActionSelectIdleWorker {
        if let ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(ActionSelectIdleWorker::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select_idle_worker(&mut self) -> ActionSelectIdleWorker {
        if self.has_select_idle_worker() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionSelectIdleWorker::new()
        }
    }

    // optional .SC2APIProtocol.ActionMultiPanel multi_panel = 6;

    pub fn multi_panel(&self) -> &ActionMultiPanel {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::MultiPanel(ref v)) => v,
            _ => <ActionMultiPanel as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_panel(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_multi_panel(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::MultiPanel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_panel(&mut self, v: ActionMultiPanel) {
        self.action = ::std::option::Option::Some(action_ui::Action::MultiPanel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_panel(&mut self) -> &mut ActionMultiPanel {
        if let ::std::option::Option::Some(action_ui::Action::MultiPanel(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::MultiPanel(ActionMultiPanel::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::MultiPanel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_panel(&mut self) -> ActionMultiPanel {
        if self.has_multi_panel() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::MultiPanel(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionMultiPanel::new()
        }
    }

    // optional .SC2APIProtocol.ActionCargoPanelUnload cargo_panel = 7;

    pub fn cargo_panel(&self) -> &ActionCargoPanelUnload {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::CargoPanel(ref v)) => v,
            _ => <ActionCargoPanelUnload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cargo_panel(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_cargo_panel(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::CargoPanel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cargo_panel(&mut self, v: ActionCargoPanelUnload) {
        self.action = ::std::option::Option::Some(action_ui::Action::CargoPanel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cargo_panel(&mut self) -> &mut ActionCargoPanelUnload {
        if let ::std::option::Option::Some(action_ui::Action::CargoPanel(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::CargoPanel(ActionCargoPanelUnload::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::CargoPanel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cargo_panel(&mut self) -> ActionCargoPanelUnload {
        if self.has_cargo_panel() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::CargoPanel(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionCargoPanelUnload::new()
        }
    }

    // optional .SC2APIProtocol.ActionProductionPanelRemoveFromQueue production_panel = 8;

    pub fn production_panel(&self) -> &ActionProductionPanelRemoveFromQueue {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ProductionPanel(ref v)) => v,
            _ => <ActionProductionPanelRemoveFromQueue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_production_panel(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_production_panel(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ProductionPanel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_production_panel(&mut self, v: ActionProductionPanelRemoveFromQueue) {
        self.action = ::std::option::Option::Some(action_ui::Action::ProductionPanel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_production_panel(&mut self) -> &mut ActionProductionPanelRemoveFromQueue {
        if let ::std::option::Option::Some(action_ui::Action::ProductionPanel(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::ProductionPanel(ActionProductionPanelRemoveFromQueue::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ProductionPanel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_production_panel(&mut self) -> ActionProductionPanelRemoveFromQueue {
        if self.has_production_panel() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::ProductionPanel(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionProductionPanelRemoveFromQueue::new()
        }
    }

    // optional .SC2APIProtocol.ActionToggleAutocast toggle_autocast = 9;

    pub fn toggle_autocast(&self) -> &ActionToggleAutocast {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ToggleAutocast(ref v)) => v,
            _ => <ActionToggleAutocast as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_toggle_autocast(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_toggle_autocast(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ToggleAutocast(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_toggle_autocast(&mut self, v: ActionToggleAutocast) {
        self.action = ::std::option::Option::Some(action_ui::Action::ToggleAutocast(v))
    }

    // Mutable pointer to the field.
    pub fn mut_toggle_autocast(&mut self) -> &mut ActionToggleAutocast {
        if let ::std::option::Option::Some(action_ui::Action::ToggleAutocast(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(action_ui::Action::ToggleAutocast(ActionToggleAutocast::new()));
        }
        match self.action {
            ::std::option::Option::Some(action_ui::Action::ToggleAutocast(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_toggle_autocast(&mut self) -> ActionToggleAutocast {
        if self.has_toggle_autocast() {
            match self.action.take() {
                ::std::option::Option::Some(action_ui::Action::ToggleAutocast(v)) => v,
                _ => panic!(),
            }
        } else {
            ActionToggleAutocast::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionControlGroup>(
            "control_group",
            ActionUI::has_control_group,
            ActionUI::control_group,
            ActionUI::mut_control_group,
            ActionUI::set_control_group,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSelectArmy>(
            "select_army",
            ActionUI::has_select_army,
            ActionUI::select_army,
            ActionUI::mut_select_army,
            ActionUI::set_select_army,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSelectWarpGates>(
            "select_warp_gates",
            ActionUI::has_select_warp_gates,
            ActionUI::select_warp_gates,
            ActionUI::mut_select_warp_gates,
            ActionUI::set_select_warp_gates,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSelectLarva>(
            "select_larva",
            ActionUI::has_select_larva,
            ActionUI::select_larva,
            ActionUI::mut_select_larva,
            ActionUI::set_select_larva,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionSelectIdleWorker>(
            "select_idle_worker",
            ActionUI::has_select_idle_worker,
            ActionUI::select_idle_worker,
            ActionUI::mut_select_idle_worker,
            ActionUI::set_select_idle_worker,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionMultiPanel>(
            "multi_panel",
            ActionUI::has_multi_panel,
            ActionUI::multi_panel,
            ActionUI::mut_multi_panel,
            ActionUI::set_multi_panel,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionCargoPanelUnload>(
            "cargo_panel",
            ActionUI::has_cargo_panel,
            ActionUI::cargo_panel,
            ActionUI::mut_cargo_panel,
            ActionUI::set_cargo_panel,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionProductionPanelRemoveFromQueue>(
            "production_panel",
            ActionUI::has_production_panel,
            ActionUI::production_panel,
            ActionUI::mut_production_panel,
            ActionUI::set_production_panel,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ActionToggleAutocast>(
            "toggle_autocast",
            ActionUI::has_toggle_autocast,
            ActionUI::toggle_autocast,
            ActionUI::mut_toggle_autocast,
            ActionUI::set_toggle_autocast,
        ));
        oneofs.push(action_ui::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionUI>(
            "ActionUI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionUI {
    const NAME: &'static str = "ActionUI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::ControlGroup(is.read_message()?));
                },
                18 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::SelectArmy(is.read_message()?));
                },
                26 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::SelectWarpGates(is.read_message()?));
                },
                34 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::SelectLarva(is.read_message()?));
                },
                42 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::SelectIdleWorker(is.read_message()?));
                },
                50 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::MultiPanel(is.read_message()?));
                },
                58 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::CargoPanel(is.read_message()?));
                },
                66 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::ProductionPanel(is.read_message()?));
                },
                74 => {
                    self.action = ::std::option::Option::Some(action_ui::Action::ToggleAutocast(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &action_ui::Action::ControlGroup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::SelectArmy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::SelectWarpGates(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::SelectLarva(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::SelectIdleWorker(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::MultiPanel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::CargoPanel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::ProductionPanel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &action_ui::Action::ToggleAutocast(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &action_ui::Action::ControlGroup(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &action_ui::Action::SelectArmy(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &action_ui::Action::SelectWarpGates(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &action_ui::Action::SelectLarva(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &action_ui::Action::SelectIdleWorker(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &action_ui::Action::MultiPanel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &action_ui::Action::CargoPanel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &action_ui::Action::ProductionPanel(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &action_ui::Action::ToggleAutocast(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionUI {
        ActionUI::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionUI {
        static instance: ActionUI = ActionUI {
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionUI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionUI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionUI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionUI`
pub mod action_ui {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:SC2APIProtocol.ActionUI.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.control_group)
        ControlGroup(super::ActionControlGroup),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.select_army)
        SelectArmy(super::ActionSelectArmy),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.select_warp_gates)
        SelectWarpGates(super::ActionSelectWarpGates),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.select_larva)
        SelectLarva(super::ActionSelectLarva),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.select_idle_worker)
        SelectIdleWorker(super::ActionSelectIdleWorker),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.multi_panel)
        MultiPanel(super::ActionMultiPanel),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.cargo_panel)
        CargoPanel(super::ActionCargoPanelUnload),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.production_panel)
        ProductionPanel(super::ActionProductionPanelRemoveFromQueue),
        // @@protoc_insertion_point(oneof_field:SC2APIProtocol.ActionUI.toggle_autocast)
        ToggleAutocast(super::ActionToggleAutocast),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ActionUI as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionControlGroup)
pub struct ActionControlGroup {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionControlGroup.action)
    pub action: ::std::option::Option<::protobuf::EnumOrUnknown<action_control_group::ControlGroupAction>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionControlGroup.control_group_index)
    pub control_group_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionControlGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionControlGroup {
    fn default() -> &'a ActionControlGroup {
        <ActionControlGroup as ::protobuf::Message>::default_instance()
    }
}

impl ActionControlGroup {
    pub fn new() -> ActionControlGroup {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionControlGroup.ControlGroupAction action = 1;

    pub fn action(&self) -> action_control_group::ControlGroupAction {
        match self.action {
            Some(e) => e.enum_value_or(action_control_group::ControlGroupAction::Recall),
            None => action_control_group::ControlGroupAction::Recall,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: action_control_group::ControlGroupAction) {
        self.action = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 control_group_index = 2;

    pub fn control_group_index(&self) -> u32 {
        self.control_group_index.unwrap_or(0)
    }

    pub fn clear_control_group_index(&mut self) {
        self.control_group_index = ::std::option::Option::None;
    }

    pub fn has_control_group_index(&self) -> bool {
        self.control_group_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_control_group_index(&mut self, v: u32) {
        self.control_group_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "action",
            |m: &ActionControlGroup| { &m.action },
            |m: &mut ActionControlGroup| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "control_group_index",
            |m: &ActionControlGroup| { &m.control_group_index },
            |m: &mut ActionControlGroup| { &mut m.control_group_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionControlGroup>(
            "ActionControlGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionControlGroup {
    const NAME: &'static str = "ActionControlGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.control_group_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.control_group_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.control_group_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionControlGroup {
        ActionControlGroup::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.control_group_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionControlGroup {
        static instance: ActionControlGroup = ActionControlGroup {
            action: ::std::option::Option::None,
            control_group_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionControlGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionControlGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionControlGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionControlGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionControlGroup`
pub mod action_control_group {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ActionControlGroup.ControlGroupAction)
    pub enum ControlGroupAction {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionControlGroup.ControlGroupAction.Recall)
        Recall = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionControlGroup.ControlGroupAction.Set)
        Set = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionControlGroup.ControlGroupAction.Append)
        Append = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionControlGroup.ControlGroupAction.SetAndSteal)
        SetAndSteal = 4,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionControlGroup.ControlGroupAction.AppendAndSteal)
        AppendAndSteal = 5,
    }

    impl ::protobuf::Enum for ControlGroupAction {
        const NAME: &'static str = "ControlGroupAction";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ControlGroupAction> {
            match value {
                1 => ::std::option::Option::Some(ControlGroupAction::Recall),
                2 => ::std::option::Option::Some(ControlGroupAction::Set),
                3 => ::std::option::Option::Some(ControlGroupAction::Append),
                4 => ::std::option::Option::Some(ControlGroupAction::SetAndSteal),
                5 => ::std::option::Option::Some(ControlGroupAction::AppendAndSteal),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ControlGroupAction] = &[
            ControlGroupAction::Recall,
            ControlGroupAction::Set,
            ControlGroupAction::Append,
            ControlGroupAction::SetAndSteal,
            ControlGroupAction::AppendAndSteal,
        ];
    }

    impl ::protobuf::EnumFull for ControlGroupAction {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActionControlGroup.ControlGroupAction").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ControlGroupAction::Recall => 0,
                ControlGroupAction::Set => 1,
                ControlGroupAction::Append => 2,
                ControlGroupAction::SetAndSteal => 3,
                ControlGroupAction::AppendAndSteal => 4,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ControlGroupAction {
        fn default() -> Self {
            ControlGroupAction::Recall
        }
    }

    impl ControlGroupAction {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ControlGroupAction>("ActionControlGroup.ControlGroupAction")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionSelectArmy)
pub struct ActionSelectArmy {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSelectArmy.selection_add)
    pub selection_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSelectArmy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSelectArmy {
    fn default() -> &'a ActionSelectArmy {
        <ActionSelectArmy as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectArmy {
    pub fn new() -> ActionSelectArmy {
        ::std::default::Default::default()
    }

    // optional bool selection_add = 1;

    pub fn selection_add(&self) -> bool {
        self.selection_add.unwrap_or(false)
    }

    pub fn clear_selection_add(&mut self) {
        self.selection_add = ::std::option::Option::None;
    }

    pub fn has_selection_add(&self) -> bool {
        self.selection_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_add(&mut self, v: bool) {
        self.selection_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_add",
            |m: &ActionSelectArmy| { &m.selection_add },
            |m: &mut ActionSelectArmy| { &mut m.selection_add },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSelectArmy>(
            "ActionSelectArmy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSelectArmy {
    const NAME: &'static str = "ActionSelectArmy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.selection_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selection_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selection_add {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSelectArmy {
        ActionSelectArmy::new()
    }

    fn clear(&mut self) {
        self.selection_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSelectArmy {
        static instance: ActionSelectArmy = ActionSelectArmy {
            selection_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSelectArmy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSelectArmy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSelectArmy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectArmy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionSelectWarpGates)
pub struct ActionSelectWarpGates {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSelectWarpGates.selection_add)
    pub selection_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSelectWarpGates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSelectWarpGates {
    fn default() -> &'a ActionSelectWarpGates {
        <ActionSelectWarpGates as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectWarpGates {
    pub fn new() -> ActionSelectWarpGates {
        ::std::default::Default::default()
    }

    // optional bool selection_add = 1;

    pub fn selection_add(&self) -> bool {
        self.selection_add.unwrap_or(false)
    }

    pub fn clear_selection_add(&mut self) {
        self.selection_add = ::std::option::Option::None;
    }

    pub fn has_selection_add(&self) -> bool {
        self.selection_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_add(&mut self, v: bool) {
        self.selection_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selection_add",
            |m: &ActionSelectWarpGates| { &m.selection_add },
            |m: &mut ActionSelectWarpGates| { &mut m.selection_add },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSelectWarpGates>(
            "ActionSelectWarpGates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSelectWarpGates {
    const NAME: &'static str = "ActionSelectWarpGates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.selection_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selection_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selection_add {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSelectWarpGates {
        ActionSelectWarpGates::new()
    }

    fn clear(&mut self) {
        self.selection_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSelectWarpGates {
        static instance: ActionSelectWarpGates = ActionSelectWarpGates {
            selection_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSelectWarpGates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSelectWarpGates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSelectWarpGates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectWarpGates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionSelectLarva)
pub struct ActionSelectLarva {
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSelectLarva.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSelectLarva {
    fn default() -> &'a ActionSelectLarva {
        <ActionSelectLarva as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectLarva {
    pub fn new() -> ActionSelectLarva {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSelectLarva>(
            "ActionSelectLarva",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSelectLarva {
    const NAME: &'static str = "ActionSelectLarva";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSelectLarva {
        ActionSelectLarva::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSelectLarva {
        static instance: ActionSelectLarva = ActionSelectLarva {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSelectLarva {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSelectLarva").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSelectLarva {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectLarva {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionSelectIdleWorker)
pub struct ActionSelectIdleWorker {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionSelectIdleWorker.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<action_select_idle_worker::Type>>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionSelectIdleWorker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionSelectIdleWorker {
    fn default() -> &'a ActionSelectIdleWorker {
        <ActionSelectIdleWorker as ::protobuf::Message>::default_instance()
    }
}

impl ActionSelectIdleWorker {
    pub fn new() -> ActionSelectIdleWorker {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionSelectIdleWorker.Type type = 1;

    pub fn type_(&self) -> action_select_idle_worker::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(action_select_idle_worker::Type::Set),
            None => action_select_idle_worker::Type::Set,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: action_select_idle_worker::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ActionSelectIdleWorker| { &m.type_ },
            |m: &mut ActionSelectIdleWorker| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionSelectIdleWorker>(
            "ActionSelectIdleWorker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionSelectIdleWorker {
    const NAME: &'static str = "ActionSelectIdleWorker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionSelectIdleWorker {
        ActionSelectIdleWorker::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionSelectIdleWorker {
        static instance: ActionSelectIdleWorker = ActionSelectIdleWorker {
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionSelectIdleWorker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionSelectIdleWorker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionSelectIdleWorker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectIdleWorker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionSelectIdleWorker`
pub mod action_select_idle_worker {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ActionSelectIdleWorker.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSelectIdleWorker.Type.Set)
        Set = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSelectIdleWorker.Type.Add)
        Add = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSelectIdleWorker.Type.All)
        All = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionSelectIdleWorker.Type.AddAll)
        AddAll = 4,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::Set),
                2 => ::std::option::Option::Some(Type::Add),
                3 => ::std::option::Option::Some(Type::All),
                4 => ::std::option::Option::Some(Type::AddAll),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::Set,
            Type::Add,
            Type::All,
            Type::AddAll,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActionSelectIdleWorker.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::Set => 0,
                Type::Add => 1,
                Type::All => 2,
                Type::AddAll => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::Set
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("ActionSelectIdleWorker.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionMultiPanel)
pub struct ActionMultiPanel {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionMultiPanel.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<action_multi_panel::Type>>,
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionMultiPanel.unit_index)
    pub unit_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionMultiPanel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionMultiPanel {
    fn default() -> &'a ActionMultiPanel {
        <ActionMultiPanel as ::protobuf::Message>::default_instance()
    }
}

impl ActionMultiPanel {
    pub fn new() -> ActionMultiPanel {
        ::std::default::Default::default()
    }

    // optional .SC2APIProtocol.ActionMultiPanel.Type type = 1;

    pub fn type_(&self) -> action_multi_panel::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(action_multi_panel::Type::SingleSelect),
            None => action_multi_panel::Type::SingleSelect,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: action_multi_panel::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 unit_index = 2;

    pub fn unit_index(&self) -> i32 {
        self.unit_index.unwrap_or(0)
    }

    pub fn clear_unit_index(&mut self) {
        self.unit_index = ::std::option::Option::None;
    }

    pub fn has_unit_index(&self) -> bool {
        self.unit_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_index(&mut self, v: i32) {
        self.unit_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ActionMultiPanel| { &m.type_ },
            |m: &mut ActionMultiPanel| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_index",
            |m: &ActionMultiPanel| { &m.unit_index },
            |m: &mut ActionMultiPanel| { &mut m.unit_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionMultiPanel>(
            "ActionMultiPanel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionMultiPanel {
    const NAME: &'static str = "ActionMultiPanel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.unit_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.unit_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.unit_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionMultiPanel {
        ActionMultiPanel::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.unit_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionMultiPanel {
        static instance: ActionMultiPanel = ActionMultiPanel {
            type_: ::std::option::Option::None,
            unit_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionMultiPanel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionMultiPanel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionMultiPanel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionMultiPanel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ActionMultiPanel`
pub mod action_multi_panel {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:SC2APIProtocol.ActionMultiPanel.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionMultiPanel.Type.SingleSelect)
        SingleSelect = 1,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionMultiPanel.Type.DeselectUnit)
        DeselectUnit = 2,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionMultiPanel.Type.SelectAllOfType)
        SelectAllOfType = 3,
        // @@protoc_insertion_point(enum_value:SC2APIProtocol.ActionMultiPanel.Type.DeselectAllOfType)
        DeselectAllOfType = 4,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::SingleSelect),
                2 => ::std::option::Option::Some(Type::DeselectUnit),
                3 => ::std::option::Option::Some(Type::SelectAllOfType),
                4 => ::std::option::Option::Some(Type::DeselectAllOfType),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::SingleSelect,
            Type::DeselectUnit,
            Type::SelectAllOfType,
            Type::DeselectAllOfType,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ActionMultiPanel.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::SingleSelect => 0,
                Type::DeselectUnit => 1,
                Type::SelectAllOfType => 2,
                Type::DeselectAllOfType => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::SingleSelect
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("ActionMultiPanel.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionCargoPanelUnload)
pub struct ActionCargoPanelUnload {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionCargoPanelUnload.unit_index)
    pub unit_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionCargoPanelUnload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionCargoPanelUnload {
    fn default() -> &'a ActionCargoPanelUnload {
        <ActionCargoPanelUnload as ::protobuf::Message>::default_instance()
    }
}

impl ActionCargoPanelUnload {
    pub fn new() -> ActionCargoPanelUnload {
        ::std::default::Default::default()
    }

    // optional int32 unit_index = 1;

    pub fn unit_index(&self) -> i32 {
        self.unit_index.unwrap_or(0)
    }

    pub fn clear_unit_index(&mut self) {
        self.unit_index = ::std::option::Option::None;
    }

    pub fn has_unit_index(&self) -> bool {
        self.unit_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_index(&mut self, v: i32) {
        self.unit_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_index",
            |m: &ActionCargoPanelUnload| { &m.unit_index },
            |m: &mut ActionCargoPanelUnload| { &mut m.unit_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionCargoPanelUnload>(
            "ActionCargoPanelUnload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionCargoPanelUnload {
    const NAME: &'static str = "ActionCargoPanelUnload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionCargoPanelUnload {
        ActionCargoPanelUnload::new()
    }

    fn clear(&mut self) {
        self.unit_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionCargoPanelUnload {
        static instance: ActionCargoPanelUnload = ActionCargoPanelUnload {
            unit_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionCargoPanelUnload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionCargoPanelUnload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionCargoPanelUnload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionCargoPanelUnload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionProductionPanelRemoveFromQueue)
pub struct ActionProductionPanelRemoveFromQueue {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionProductionPanelRemoveFromQueue.unit_index)
    pub unit_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionProductionPanelRemoveFromQueue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionProductionPanelRemoveFromQueue {
    fn default() -> &'a ActionProductionPanelRemoveFromQueue {
        <ActionProductionPanelRemoveFromQueue as ::protobuf::Message>::default_instance()
    }
}

impl ActionProductionPanelRemoveFromQueue {
    pub fn new() -> ActionProductionPanelRemoveFromQueue {
        ::std::default::Default::default()
    }

    // optional int32 unit_index = 1;

    pub fn unit_index(&self) -> i32 {
        self.unit_index.unwrap_or(0)
    }

    pub fn clear_unit_index(&mut self) {
        self.unit_index = ::std::option::Option::None;
    }

    pub fn has_unit_index(&self) -> bool {
        self.unit_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit_index(&mut self, v: i32) {
        self.unit_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unit_index",
            |m: &ActionProductionPanelRemoveFromQueue| { &m.unit_index },
            |m: &mut ActionProductionPanelRemoveFromQueue| { &mut m.unit_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionProductionPanelRemoveFromQueue>(
            "ActionProductionPanelRemoveFromQueue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionProductionPanelRemoveFromQueue {
    const NAME: &'static str = "ActionProductionPanelRemoveFromQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unit_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unit_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unit_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionProductionPanelRemoveFromQueue {
        ActionProductionPanelRemoveFromQueue::new()
    }

    fn clear(&mut self) {
        self.unit_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionProductionPanelRemoveFromQueue {
        static instance: ActionProductionPanelRemoveFromQueue = ActionProductionPanelRemoveFromQueue {
            unit_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionProductionPanelRemoveFromQueue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionProductionPanelRemoveFromQueue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionProductionPanelRemoveFromQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionProductionPanelRemoveFromQueue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SC2APIProtocol.ActionToggleAutocast)
pub struct ActionToggleAutocast {
    // message fields
    // @@protoc_insertion_point(field:SC2APIProtocol.ActionToggleAutocast.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:SC2APIProtocol.ActionToggleAutocast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionToggleAutocast {
    fn default() -> &'a ActionToggleAutocast {
        <ActionToggleAutocast as ::protobuf::Message>::default_instance()
    }
}

impl ActionToggleAutocast {
    pub fn new() -> ActionToggleAutocast {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(0)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ability_id",
            |m: &ActionToggleAutocast| { &m.ability_id },
            |m: &mut ActionToggleAutocast| { &mut m.ability_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionToggleAutocast>(
            "ActionToggleAutocast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionToggleAutocast {
    const NAME: &'static str = "ActionToggleAutocast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionToggleAutocast {
        ActionToggleAutocast::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionToggleAutocast {
        static instance: ActionToggleAutocast = ActionToggleAutocast {
            ability_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionToggleAutocast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionToggleAutocast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionToggleAutocast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionToggleAutocast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19s2clientprotocol/ui.proto\x12\x0eSC2APIProtocol\"\xb0\x02\n\rObser\
    vationUI\x124\n\x06groups\x18\x01\x20\x03(\x0b2\x1c.SC2APIProtocol.Contr\
    olGroupR\x06groups\x125\n\x06single\x18\x02\x20\x01(\x0b2\x1b.SC2APIProt\
    ocol.SinglePanelH\0R\x06single\x122\n\x05multi\x18\x03\x20\x01(\x0b2\x1a\
    .SC2APIProtocol.MultiPanelH\0R\x05multi\x122\n\x05cargo\x18\x04\x20\x01(\
    \x0b2\x1a.SC2APIProtocol.CargoPanelH\0R\x05cargo\x12A\n\nproduction\x18\
    \x05\x20\x01(\x0b2\x1f.SC2APIProtocol.ProductionPanelH\0R\nproductionB\
    \x07\n\x05panel\"~\n\x0cControlGroup\x12.\n\x13control_group_index\x18\
    \x01\x20\x01(\rR\x11controlGroupIndex\x12(\n\x10leader_unit_type\x18\x02\
    \x20\x01(\rR\x0eleaderUnitType\x12\x14\n\x05count\x18\x03\x20\x01(\rR\
    \x05count\"\x85\x03\n\x08UnitInfo\x12\x1b\n\tunit_type\x18\x01\x20\x01(\
    \rR\x08unitType\x12'\n\x0fplayer_relative\x18\x02\x20\x01(\rR\x0eplayerR\
    elative\x12\x16\n\x06health\x18\x03\x20\x01(\x05R\x06health\x12\x18\n\
    \x07shields\x18\x04\x20\x01(\x05R\x07shields\x12\x16\n\x06energy\x18\x05\
    \x20\x01(\x05R\x06energy\x122\n\x15transport_slots_taken\x18\x06\x20\x01\
    (\x05R\x13transportSlotsTaken\x12%\n\x0ebuild_progress\x18\x07\x20\x01(\
    \x02R\rbuildProgress\x12/\n\x06add_on\x18\x08\x20\x01(\x0b2\x18.SC2APIPr\
    otocol.UnitInfoR\x05addOn\x12\x1d\n\nmax_health\x18\t\x20\x01(\x05R\tmax\
    Health\x12\x1f\n\x0bmax_shields\x18\n\x20\x01(\x05R\nmaxShields\x12\x1d\
    \n\nmax_energy\x18\x0b\x20\x01(\x05R\tmaxEnergy\"\xe5\x01\n\x0bSinglePan\
    el\x12,\n\x04unit\x18\x01\x20\x01(\x0b2\x18.SC2APIProtocol.UnitInfoR\x04\
    unit\x120\n\x14attack_upgrade_level\x18\x02\x20\x01(\x05R\x12attackUpgra\
    deLevel\x12.\n\x13armor_upgrade_level\x18\x03\x20\x01(\x05R\x11armorUpgr\
    adeLevel\x120\n\x14shield_upgrade_level\x18\x04\x20\x01(\x05R\x12shieldU\
    pgradeLevel\x12\x14\n\x05buffs\x18\x05\x20\x03(\x05R\x05buffs\"<\n\nMult\
    iPanel\x12.\n\x05units\x18\x01\x20\x03(\x0b2\x18.SC2APIProtocol.UnitInfo\
    R\x05units\"\x9d\x01\n\nCargoPanel\x12,\n\x04unit\x18\x01\x20\x01(\x0b2\
    \x18.SC2APIProtocol.UnitInfoR\x04unit\x128\n\npassengers\x18\x02\x20\x03\
    (\x0b2\x18.SC2APIProtocol.UnitInfoR\npassengers\x12'\n\x0fslots_availabl\
    e\x18\x03\x20\x01(\x05R\x0eslotsAvailable\"Q\n\tBuildItem\x12\x1d\n\nabi\
    lity_id\x18\x01\x20\x01(\rR\tabilityId\x12%\n\x0ebuild_progress\x18\x02\
    \x20\x01(\x02R\rbuildProgress\"\xc0\x01\n\x0fProductionPanel\x12,\n\x04u\
    nit\x18\x01\x20\x01(\x0b2\x18.SC2APIProtocol.UnitInfoR\x04unit\x129\n\
    \x0bbuild_queue\x18\x02\x20\x03(\x0b2\x18.SC2APIProtocol.UnitInfoR\nbuil\
    dQueue\x12D\n\x10production_queue\x18\x03\x20\x03(\x0b2\x19.SC2APIProtoc\
    ol.BuildItemR\x0fproductionQueue\"\xdd\x05\n\x08ActionUI\x12I\n\rcontrol\
    _group\x18\x01\x20\x01(\x0b2\".SC2APIProtocol.ActionControlGroupH\0R\x0c\
    controlGroup\x12C\n\x0bselect_army\x18\x02\x20\x01(\x0b2\x20.SC2APIProto\
    col.ActionSelectArmyH\0R\nselectArmy\x12S\n\x11select_warp_gates\x18\x03\
    \x20\x01(\x0b2%.SC2APIProtocol.ActionSelectWarpGatesH\0R\x0fselectWarpGa\
    tes\x12F\n\x0cselect_larva\x18\x04\x20\x01(\x0b2!.SC2APIProtocol.ActionS\
    electLarvaH\0R\x0bselectLarva\x12V\n\x12select_idle_worker\x18\x05\x20\
    \x01(\x0b2&.SC2APIProtocol.ActionSelectIdleWorkerH\0R\x10selectIdleWorke\
    r\x12C\n\x0bmulti_panel\x18\x06\x20\x01(\x0b2\x20.SC2APIProtocol.ActionM\
    ultiPanelH\0R\nmultiPanel\x12I\n\x0bcargo_panel\x18\x07\x20\x01(\x0b2&.S\
    C2APIProtocol.ActionCargoPanelUnloadH\0R\ncargoPanel\x12a\n\x10productio\
    n_panel\x18\x08\x20\x01(\x0b24.SC2APIProtocol.ActionProductionPanelRemov\
    eFromQueueH\0R\x0fproductionPanel\x12O\n\x0ftoggle_autocast\x18\t\x20\
    \x01(\x0b2$.SC2APIProtocol.ActionToggleAutocastH\0R\x0etoggleAutocastB\
    \x08\n\x06action\"\xef\x01\n\x12ActionControlGroup\x12M\n\x06action\x18\
    \x01\x20\x01(\x0e25.SC2APIProtocol.ActionControlGroup.ControlGroupAction\
    R\x06action\x12.\n\x13control_group_index\x18\x02\x20\x01(\rR\x11control\
    GroupIndex\"Z\n\x12ControlGroupAction\x12\n\n\x06Recall\x10\x01\x12\x07\
    \n\x03Set\x10\x02\x12\n\n\x06Append\x10\x03\x12\x0f\n\x0bSetAndSteal\x10\
    \x04\x12\x12\n\x0eAppendAndSteal\x10\x05\"7\n\x10ActionSelectArmy\x12#\n\
    \rselection_add\x18\x01\x20\x01(\x08R\x0cselectionAdd\"<\n\x15ActionSele\
    ctWarpGates\x12#\n\rselection_add\x18\x01\x20\x01(\x08R\x0cselectionAdd\
    \"\x13\n\x11ActionSelectLarva\"\x88\x01\n\x16ActionSelectIdleWorker\x12?\
    \n\x04type\x18\x01\x20\x01(\x0e2+.SC2APIProtocol.ActionSelectIdleWorker.\
    TypeR\x04type\"-\n\x04Type\x12\x07\n\x03Set\x10\x01\x12\x07\n\x03Add\x10\
    \x02\x12\x07\n\x03All\x10\x03\x12\n\n\x06AddAll\x10\x04\"\xc4\x01\n\x10A\
    ctionMultiPanel\x129\n\x04type\x18\x01\x20\x01(\x0e2%.SC2APIProtocol.Act\
    ionMultiPanel.TypeR\x04type\x12\x1d\n\nunit_index\x18\x02\x20\x01(\x05R\
    \tunitIndex\"V\n\x04Type\x12\x10\n\x0cSingleSelect\x10\x01\x12\x10\n\x0c\
    DeselectUnit\x10\x02\x12\x13\n\x0fSelectAllOfType\x10\x03\x12\x15\n\x11D\
    eselectAllOfType\x10\x04\"7\n\x16ActionCargoPanelUnload\x12\x1d\n\nunit_\
    index\x18\x01\x20\x01(\x05R\tunitIndex\"E\n$ActionProductionPanelRemoveF\
    romQueue\x12\x1d\n\nunit_index\x18\x01\x20\x01(\x05R\tunitIndex\"5\n\x14\
    ActionToggleAutocast\x12\x1d\n\nability_id\x18\x01\x20\x01(\x05R\tabilit\
    yId\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(18);
            messages.push(ObservationUI::generated_message_descriptor_data());
            messages.push(ControlGroup::generated_message_descriptor_data());
            messages.push(UnitInfo::generated_message_descriptor_data());
            messages.push(SinglePanel::generated_message_descriptor_data());
            messages.push(MultiPanel::generated_message_descriptor_data());
            messages.push(CargoPanel::generated_message_descriptor_data());
            messages.push(BuildItem::generated_message_descriptor_data());
            messages.push(ProductionPanel::generated_message_descriptor_data());
            messages.push(ActionUI::generated_message_descriptor_data());
            messages.push(ActionControlGroup::generated_message_descriptor_data());
            messages.push(ActionSelectArmy::generated_message_descriptor_data());
            messages.push(ActionSelectWarpGates::generated_message_descriptor_data());
            messages.push(ActionSelectLarva::generated_message_descriptor_data());
            messages.push(ActionSelectIdleWorker::generated_message_descriptor_data());
            messages.push(ActionMultiPanel::generated_message_descriptor_data());
            messages.push(ActionCargoPanelUnload::generated_message_descriptor_data());
            messages.push(ActionProductionPanelRemoveFromQueue::generated_message_descriptor_data());
            messages.push(ActionToggleAutocast::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(action_control_group::ControlGroupAction::generated_enum_descriptor_data());
            enums.push(action_select_idle_worker::Type::generated_enum_descriptor_data());
            enums.push(action_multi_panel::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
